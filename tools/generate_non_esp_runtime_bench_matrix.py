#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import os
import subprocess
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List


HERO_BOARDS = [
    ("rp2040", "raspberry_pi_pico", "BASALT_RP2040_PORT"),
    ("stm32", "nucleo_f446re", "BASALT_STM32_PORT"),
    ("pic16", "curiosity_nano_pic16f13145", "BASALT_PIC16_PORT"),
]

DRIVER_STACK = ["gpio", "uart", "i2c", "spi", "timer", "pwm", "shell_full"]


def utc_now() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")


def has_pyserial() -> bool:
    try:
        import serial  # noqa: F401
        return True
    except Exception:
        return False


def serial_probe(port: str, timeout_s: float = 2.4) -> Dict[str, Any]:
    import serial

    with serial.Serial(port, baudrate=115200, timeout=0.1) as ser:
        ser.write(b"\n")
        ser.write(b"help\n")
        end = time.time() + timeout_s
        out: List[str] = []
        while time.time() < end:
            data = ser.read(ser.in_waiting or 1)
            if data:
                out.append(data.decode("utf-8", "replace"))
            else:
                time.sleep(0.02)
    text = "".join(out)
    return {
        "ok": bool(text.strip()),
        "bytes": len(text.encode("utf-8", "replace")),
        "snippet": text[:220],
    }


def run(root: Path, out_json: Path, out_md: Path) -> Dict[str, Any]:
    rows: List[Dict[str, Any]] = []
    pyserial_ok = has_pyserial()

    for platform, board, port_env in HERO_BOARDS:
        outdir = Path("/tmp") / f"non_esp_runtime_{platform}"
        log_path = Path("/tmp") / f"non_esp_runtime_{platform}_configure.log"

        cmd = [
            "python3",
            "tools/configure.py",
            "--platform",
            platform,
            "--board",
            board,
            "--enable-drivers",
            ",".join(DRIVER_STACK),
            "--outdir",
            str(outdir),
        ]
        proc = subprocess.run(cmd, cwd=root, capture_output=True, text=True)
        log_path.write_text((proc.stdout or "") + "\n" + (proc.stderr or ""), encoding="utf-8")

        configure_ok = proc.returncode == 0
        runtime_status = "skipped"
        runtime_note = "no serial port configured"
        runtime_probe = {}
        port = os.environ.get(port_env, "").strip()

        if configure_ok and port:
            if not Path(port).exists():
                runtime_status = "skipped"
                runtime_note = f"configured port not found: {port}"
            elif not pyserial_ok:
                runtime_status = "skipped"
                runtime_note = "pyserial not installed"
            else:
                try:
                    probe = serial_probe(port)
                    runtime_probe = probe
                    if probe["ok"]:
                        runtime_status = "pass"
                        runtime_note = f"serial probe returned {probe['bytes']} bytes"
                    else:
                        runtime_status = "fail"
                        runtime_note = "serial probe returned no data"
                except Exception as ex:
                    runtime_status = "fail"
                    runtime_note = f"serial probe error: {ex}"

        rows.append(
            {
                "platform": platform,
                "board": board,
                "port_env": port_env,
                "port": port,
                "configure_status": "pass" if configure_ok else "fail",
                "runtime_status": runtime_status,
                "runtime_note": runtime_note,
                "configure_log": str(log_path),
                "runtime_probe": runtime_probe,
            }
        )

    return {
        "generated_utc": utc_now(),
        "driver_stack": DRIVER_STACK,
        "rows": rows,
    }


def render_md(report: Dict[str, Any]) -> str:
    lines: List[str] = []
    lines.append("# Non-ESP Runtime Bench Matrix")
    lines.append("")
    lines.append("Auto-generated by `tools/generate_non_esp_runtime_bench_matrix.py`.")
    lines.append("")
    lines.append(f"- Driver stack: `{','.join(report.get('driver_stack', []))}`")
    lines.append("")
    lines.append("| Platform | Board | Configure | Runtime | Notes |")
    lines.append("|---|---|---|---|---|")
    for row in report.get("rows", []):
        lines.append(
            f"| {row['platform']} | {row['board']} | {row['configure_status']} | "
            f"{row['runtime_status']} | {row['runtime_note']} |"
        )
    return "\n".join(lines) + "\n"


def main() -> int:
    ap = argparse.ArgumentParser(description="Generate non-ESP runtime bench matrix report.")
    ap.add_argument("--json-out", required=True, type=Path)
    ap.add_argument("--md-out", required=True, type=Path)
    args = ap.parse_args()

    root = Path(__file__).resolve().parents[1]
    report = run(root, args.json_out, args.md_out)

    args.json_out.parent.mkdir(parents=True, exist_ok=True)
    args.md_out.parent.mkdir(parents=True, exist_ok=True)
    args.json_out.write_text(json.dumps(report, indent=2) + "\n", encoding="utf-8")
    args.md_out.write_text(render_md(report), encoding="utf-8")

    print(f"[non-esp-runtime] rows: {len(report.get('rows', []))}")
    print(f"[non-esp-runtime] wrote: {args.json_out}")
    print(f"[non-esp-runtime] wrote: {args.md_out}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
