#!/usr/bin/env python3
from __future__ import annotations

import argparse
import csv
import json
import re
from pathlib import Path
from typing import Any, Dict, List, Set

PRIMITIVE_RE = re.compile(r"^hal_([a-z0-9_]+)\.h$")


def discover_primitives(root: Path) -> List[str]:
    include_dir = root / "basalt_hal" / "include" / "hal"
    primitives: List[str] = []
    for hdr in sorted(include_dir.glob("hal_*.h")):
        m = PRIMITIVE_RE.match(hdr.name)
        if not m:
            continue
        prim = m.group(1)
        if prim == "types":
            continue
        primitives.append(prim)
    return primitives


def is_impl_for_primitive(src: Path, primitive: str) -> bool:
    text = src.read_text(encoding="utf-8")
    if text.lstrip().startswith("#pragma once"):
        return False
    if "BASALT_HAL_UNSUPPORTED_STUB" in text:
        return False
    return f"hal_{primitive}_" in text


def discover_ports(root: Path, primitives: List[str]) -> List[Dict[str, Any]]:
    ports_root = root / "basalt_hal" / "ports"
    out: List[Dict[str, Any]] = []
    for port_dir in sorted([p for p in ports_root.iterdir() if p.is_dir()]):
        present: List[str] = []
        missing: List[str] = []
        for primitive in primitives:
            src = port_dir / f"hal_{primitive}.c"
            if src.exists() and is_impl_for_primitive(src, primitive):
                present.append(primitive)
            else:
                missing.append(primitive)
        if len(present) == len(primitives):
            status = "complete"
        elif len(present) == 0:
            status = "missing"
        else:
            status = "partial"
        out.append(
            {
                "port": port_dir.name,
                "status": status,
                "present_count": len(present),
                "missing_count": len(missing),
                "present": present,
                "missing": missing,
            }
        )
    return out


def write_csv(rows: List[Dict[str, Any]], primitives: List[str], out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    fields = ["port", "status"] + [f"has_{p}" for p in primitives]
    with out_path.open("w", encoding="utf-8", newline="") as f:
        w = csv.DictWriter(f, fieldnames=fields)
        w.writeheader()
        for r in rows:
            row = {"port": r["port"], "status": r["status"]}
            present_set: Set[str] = set(r["present"])
            for p in primitives:
                row[f"has_{p}"] = "yes" if p in present_set else "no"
            w.writerow(row)


def write_json(rows: List[Dict[str, Any]], primitives: List[str], out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    summary = {
        "port_count": len(rows),
        "primitive_count": len(primitives),
        "status_counts": {
            "complete": sum(1 for r in rows if r["status"] == "complete"),
            "partial": sum(1 for r in rows if r["status"] == "partial"),
            "missing": sum(1 for r in rows if r["status"] == "missing"),
        },
        "ports_with_missing_primitives": [
            {"port": r["port"], "missing": r["missing"]}
            for r in rows
            if r["missing_count"] > 0
        ],
    }
    payload = {
        "version": "1.0.0",
        "generator": "tools/generate_hal_adapter_matrix.py",
        "primitives": primitives,
        "summary": summary,
        "rows": rows,
    }
    out_path.write_text(json.dumps(payload, indent=2) + "\n", encoding="utf-8")


def write_md(rows: List[Dict[str, Any]], primitives: List[str], out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    complete = sum(1 for r in rows if r["status"] == "complete")
    partial = sum(1 for r in rows if r["status"] == "partial")
    missing = sum(1 for r in rows if r["status"] == "missing")
    lines: List[str] = []
    lines.append("# HAL Adapter Matrix v1")
    lines.append("")
    lines.append("Auto-generated by `tools/generate_hal_adapter_matrix.py`.")
    lines.append("")
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- Ports discovered: {len(rows)}")
    lines.append(f"- HAL primitives tracked: {len(primitives)}")
    lines.append(f"- Complete adapters: {complete}")
    lines.append(f"- Partial adapters: {partial}")
    lines.append(f"- Missing adapters: {missing}")
    lines.append("")
    lines.append("| Port | Status | Present | Missing |")
    lines.append("|---|---|---|---|")
    for r in rows:
        present = ", ".join(r["present"]) if r["present"] else "-"
        missing_list = ", ".join(r["missing"]) if r["missing"] else "-"
        lines.append(f"| {r['port']} | {r['status']} | {present} | {missing_list} |")
    lines.append("")
    out_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


def main() -> int:
    ap = argparse.ArgumentParser(description="Generate HAL adapter capability matrix artifacts.")
    ap.add_argument("--csv-out", default="docs/planning/HAL_ADAPTER_MATRIX.csv")
    ap.add_argument("--json-out", default="docs/planning/HAL_ADAPTER_MATRIX.json")
    ap.add_argument("--md-out", default="docs/planning/HAL_ADAPTER_MATRIX.md")
    args = ap.parse_args()

    root = Path(__file__).resolve().parent.parent
    primitives = discover_primitives(root)
    rows = discover_ports(root, primitives)
    rows.sort(key=lambda x: x["port"])

    csv_out = (root / args.csv_out).resolve()
    json_out = (root / args.json_out).resolve()
    md_out = (root / args.md_out).resolve()

    write_csv(rows, primitives, csv_out)
    write_json(rows, primitives, json_out)
    write_md(rows, primitives, md_out)

    print(f"[hal-matrix] ports: {len(rows)}")
    print(f"[hal-matrix] primitives: {len(primitives)}")
    print(f"[hal-matrix] wrote: {csv_out}")
    print(f"[hal-matrix] wrote: {json_out}")
    print(f"[hal-matrix] wrote: {md_out}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
