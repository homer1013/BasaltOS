#!/usr/bin/env python3
from __future__ import annotations

import argparse
import csv
import json
from collections import Counter, defaultdict
from pathlib import Path
from typing import Any, Dict, List, Tuple


def read_json(path: Path) -> Dict[str, Any]:
    return json.loads(path.read_text(encoding="utf-8"))


def index_boards_by_key(idx: Dict[str, Any]) -> Dict[Tuple[str, str, str], Dict[str, Any]]:
    out: Dict[Tuple[str, str, str], Dict[str, Any]] = {}
    for row in idx.get("boards", []):
        if not isinstance(row, dict):
            continue
        k = (
            str(row.get("manufacturer") or "").strip(),
            str(row.get("platform") or "").strip(),
            str(row.get("board_dir") or "").strip(),
        )
        out[k] = row
    return out


def build_rows(seed: Dict[str, Any], idx_lookup: Dict[Tuple[str, str, str], Dict[str, Any]]) -> List[Dict[str, str]]:
    rows: List[Dict[str, str]] = []
    for c in seed.get("candidates", []):
        if not isinstance(c, dict):
            continue
        manufacturer = str(c.get("manufacturer") or "").strip()
        platform = str(c.get("platform") or "").strip()
        board_dir = str(c.get("board_dir") or "").strip()
        priority = str(c.get("priority") or "").strip()
        lane = str(c.get("lane") or "").strip()
        rationale = str(c.get("rationale") or "").strip()
        idx_row = idx_lookup.get((manufacturer, platform, board_dir))
        profile_present = "yes" if idx_row else "no"
        status = "PROFILE_PRESENT" if idx_row else "PLANNED_PROFILE"
        board_id = str((idx_row or {}).get("id") or "")
        family = str((idx_row or {}).get("family") or "")
        architecture = str((idx_row or {}).get("architecture") or "")
        mcu = str((idx_row or {}).get("mcu") or "")
        rows.append(
            {
                "manufacturer": manufacturer,
                "platform": platform,
                "board_dir": board_dir,
                "board_id": board_id,
                "family": family,
                "architecture": architecture,
                "mcu": mcu,
                "priority": priority,
                "lane": lane,
                "status": status,
                "profile_present": profile_present,
                "rationale": rationale,
            }
        )
    rows.sort(key=lambda r: (r["manufacturer"].lower(), r["priority"], r["platform"], r["board_dir"]))
    return rows


def write_csv(rows: List[Dict[str, str]], out_csv: Path) -> None:
    out_csv.parent.mkdir(parents=True, exist_ok=True)
    fields = [
        "manufacturer",
        "platform",
        "board_dir",
        "board_id",
        "family",
        "architecture",
        "mcu",
        "priority",
        "lane",
        "status",
        "profile_present",
        "rationale",
    ]
    with out_csv.open("w", encoding="utf-8", newline="") as f:
        w = csv.DictWriter(f, fieldnames=fields)
        w.writeheader()
        for r in rows:
            w.writerow(r)


def write_md(rows: List[Dict[str, str]], out_md: Path, seed_path: Path, idx_path: Path) -> None:
    out_md.parent.mkdir(parents=True, exist_ok=True)
    by_manu: Dict[str, List[Dict[str, str]]] = defaultdict(list)
    for r in rows:
        by_manu[r["manufacturer"]].append(r)

    status_counts = Counter(r["status"] for r in rows)
    lines: List[str] = []
    lines.append("# Manufacturer Starter Board Matrix")
    lines.append("")
    lines.append("Auto-generated by `tools/generate_manufacturer_matrix.py`.")
    lines.append("")
    lines.append(f"- Seed source: `{seed_path}`")
    lines.append(f"- Taxonomy source: `{idx_path}`")
    lines.append(f"- Candidates: {len(rows)}")
    lines.append(f"- Profile present: {status_counts.get('PROFILE_PRESENT', 0)}")
    lines.append(f"- Planned profiles: {status_counts.get('PLANNED_PROFILE', 0)}")
    lines.append("")
    for manu in sorted(by_manu.keys(), key=str.lower):
        grp = by_manu[manu]
        lines.append(f"## {manu}")
        lines.append("")
        lines.append("| Priority | Candidate | Status | Lane | Family | Notes |")
        lines.append("|---|---|---|---|---|---|")
        for r in grp:
            cand = f"{r['platform']}/{r['board_dir']}"
            fam = r["family"] or "-"
            notes = r["rationale"] or "-"
            lines.append(f"| {r['priority']} | {cand} | {r['status']} | {r['lane']} | {fam} | {notes} |")
        lines.append("")
    out_md.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


def main() -> int:
    ap = argparse.ArgumentParser(description="Generate manufacturer starter board matrix (CSV + MD).")
    ap.add_argument(
        "--seed",
        default="docs/planning/MANUFACTURER_STARTER_CANDIDATES.json",
        help="JSON seed candidates file",
    )
    ap.add_argument(
        "--taxonomy",
        default="docs/BOARD_TAXONOMY_INDEX.json",
        help="Board taxonomy index JSON path",
    )
    ap.add_argument(
        "--csv-out",
        default="docs/planning/MANUFACTURER_BOARD_MATRIX.csv",
        help="CSV output path",
    )
    ap.add_argument(
        "--md-out",
        default="docs/planning/MANUFACTURER_BOARD_MATRIX.md",
        help="Markdown output path",
    )
    args = ap.parse_args()

    root = Path(__file__).resolve().parent.parent
    seed_path = (root / args.seed).resolve()
    idx_path = (root / args.taxonomy).resolve()
    csv_out = (root / args.csv_out).resolve()
    md_out = (root / args.md_out).resolve()

    seed = read_json(seed_path)
    idx = read_json(idx_path)
    idx_lookup = index_boards_by_key(idx)
    rows = build_rows(seed, idx_lookup)

    write_csv(rows, csv_out)
    write_md(rows, md_out, seed_path.relative_to(root), idx_path.relative_to(root))

    print(f"[matrix] candidates: {len(rows)}")
    print(f"[matrix] wrote: {csv_out}")
    print(f"[matrix] wrote: {md_out}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
