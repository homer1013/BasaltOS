<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BasaltOS Configurator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Manrope", "Avenir Next", "Segoe UI", sans-serif;
            background: #f5f5f5;
            color: #1f2937;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .app-topbar {
            background: #ffffff;
            border: 1px solid #dbeafe;
            border-radius: 14px;
            padding: 14px 18px;
            margin-bottom: 16px;
            box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brand-mark {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: linear-gradient(135deg, #0369a1, #0ea5a4);
            color: #fff;
            font-weight: 800;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .brand-title {
            font-size: 18px;
            font-weight: 800;
            color: #0f172a;
        }

        .brand-sub {
            font-size: 12px;
            color: #475569;
        }

        .topbar-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .profile-chip {
            padding: 6px 10px;
            border-radius: 999px;
            background: #ecfeff;
            color: #155e75;
            font-weight: 700;
            font-size: 12px;
            border: 1px solid #a5f3fc;
        }

        .btn-nav {
            border: 1px solid #cbd5e1;
            background: #ffffff;
            color: #0f172a;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
        }

        .btn-nav:hover {
            background: #f8fafc;
        }

        .landing-home {
            background: #ffffff;
            color: #1f2937;
            border: 1px solid #dbeafe;
            border-radius: 16px;
            padding: 28px;
            margin-bottom: 24px;
            box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
        }

        .landing-grid {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            gap: 18px;
            align-items: stretch;
        }

        .landing-hero h1 {
            font-size: 34px;
            line-height: 1.1;
            margin-bottom: 12px;
            letter-spacing: -0.01em;
        }

        .landing-hero p {
            color: #475569;
            max-width: 60ch;
            margin-bottom: 18px;
        }

        .landing-cta {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .landing-card {
            border: 1px solid #dbeafe;
            background: #f8fbff;
            border-radius: 12px;
            padding: 14px;
        }

        .landing-card h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #1e3a8a;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .landing-card ul {
            list-style: none;
            font-size: 13px;
            color: #334155;
            display: grid;
            gap: 6px;
        }

        .landing-stat {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .landing-stat-box {
            border-radius: 10px;
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            padding: 8px;
            text-align: center;
            font-size: 12px;
        }

        .landing-stat-box strong {
            display: block;
            font-size: 18px;
            color: #1d4ed8;
        }

        #configurator-shell, #market-shell {
            display: none;
        }

        .market-shell {
            background: #ffffff;
            border-radius: 12px;
            padding: 22px;
            border: 1px solid #dbeafe;
            box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
        }

        .market-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 14px;
        }

        .market-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .market-card {
            border: 1px solid #dbeafe;
            border-radius: 10px;
            background: #f8fbff;
            padding: 12px;
        }

        .market-card h4 {
            margin-bottom: 6px;
            color: #0f172a;
        }

        .market-card p {
            font-size: 13px;
            color: #475569;
            min-height: 36px;
        }

        .market-meta {
            font-size: 12px;
            color: #64748b;
            margin-top: 8px;
        }

        .market-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .market-upload {
            margin-top: 20px;
            border-top: 1px solid #e2e8f0;
            padding-top: 14px;
        }

        .market-upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .market-upload-grid input,
        .market-upload-grid textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 13px;
        }

        .wizard-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .step {
            flex: 1;
            text-align: center;
            position: relative;
            padding: 15px;
        }

        .step:not(:last-child)::after {
            content: '‚Üí';
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
            font-size: 24px;
        }

        .step.active {
            color: #667eea;
            font-weight: 600;
        }

        .step.completed {
            color: #48bb78;
        }

        .step-number {
            display: inline-block;
            width: 30px;
            height: 30px;
            background: #e2e8f0;
            border-radius: 50%;
            line-height: 30px;
            margin-bottom: 5px;
        }

        .step.active .step-number {
            background: #667eea;
            color: white;
        }

        .step.completed .step-number {
            background: #48bb78;
            color: white;
        }

        .config-panel {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .sidebar {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            height: fit-content;
        }

        .sidebar h3 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 18px;
        }

        .board-list, .module-list {
            list-style: none;
        }

        .board-item, .module-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f7fafc;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .board-item:hover, .module-item:hover {
            background: #edf2f7;
        }

        .board-item.selected {
            background: #ebf4ff;
            border-color: #667eea;
            font-weight: 600;
        }

        .board-group {
            margin-bottom: 12px;
        }

        .board-group-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #718096;
            margin: 10px 0 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid #e2e8f0;
        }

        .profile-card {
            margin-top: 20px;
            padding: 12px;
            border-radius: 8px;
            background: #f8fbff;
            border: 1px solid #d9e7ff;
        }

        .profile-card label {
            display: block;
            font-size: 12px;
            color: #4a5568;
            margin-bottom: 6px;
        }

        .profile-card input[type="text"] {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .profile-stats {
            font-size: 12px;
            color: #2d3748;
            margin-bottom: 8px;
        }

        .inventory-panel {
            margin-top: 8px;
            border-top: 1px solid #d9e7ff;
            padding-top: 8px;
        }

        .inventory-list {
            max-height: 170px;
            overflow: auto;
            margin-top: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 8px;
            background: #fff;
        }

        .inventory-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 12px;
            color: #2d3748;
        }

        .board-empty {
            padding: 10px;
            border-radius: 6px;
            background: #f7fafc;
            color: #4a5568;
            font-size: 13px;
        }

        .main-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        .board-details {
            margin-bottom: 30px;
        }

        .board-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
        }

        .board-image {
            width: 150px;
            height: 150px;
            background: #f7fafc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #a0aec0;
            font-size: 48px;
        }

        .board-info h2 {
            font-size: 28px;
            margin-bottom: 8px;
            color: #2d3748;
        }

        .board-specs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .spec-item {
            background: #f7fafc;
            padding: 15px;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .spec-label {
            font-size: 12px;
            color: #718096;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .spec-value {
            font-size: 16px;
            font-weight: 600;
            color: #2d3748;
        }

        .module-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .module-section {
            margin-top: 14px;
            border: 1px solid #dbeafe;
            border-radius: 10px;
            background: #f8fbff;
            overflow: hidden;
        }

        .module-section summary {
            cursor: pointer;
            list-style: none;
            padding: 12px 14px;
            font-weight: 700;
            color: #1e3a8a;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .module-section summary::-webkit-details-marker {
            display: none;
        }

        .module-section-count {
            font-size: 12px;
            font-weight: 600;
            color: #475569;
            background: #e2e8f0;
            border-radius: 999px;
            padding: 2px 8px;
        }

        .module-subgrid {
            margin-top: 0;
            padding: 0 12px 12px 12px;
            grid-template-columns: repeat(auto-fill, minmax(230px, 1fr));
        }

        .module-card {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            transition: all 0.2s;
        }

        .module-card:hover {
            border-color: #cbd5e0;
        }

        .module-card.enabled {
            background: #ebf4ff;
            border-color: #667eea;
        }

        .module-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .module-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .module-name {
            font-weight: 600;
            font-size: 16px;
            color: #2d3748;
        }

        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e0;
            transition: .3s;
            border-radius: 26px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        .module-description {
            font-size: 14px;
            color: #718096;
            margin-bottom: 10px;
        }

        .module-pins {
            font-size: 12px;
            color: #a0aec0;
        }

        .module-options {
            margin-top: 15px;
            padding: 15px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            display: none;
        }

        .module-options.active {
            display: block;
        }

        .option-field {
            margin-bottom: 12px;
        }

        .option-field label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 5px;
        }

        .option-field input,
        .option-field select {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn-config {
            margin-top: 10px;
            padding: 6px 12px;
            background: #e2e8f0;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-config:hover {
            background: #cbd5e0;
        }

        .btn-config.active {
            background: #667eea;
            color: white;
        }

        .module-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .badge-dep {
            background: #fef3c7;
            color: #92400e;
        }

        .badge-provides {
            background: #dbeafe;
            color: #1e40af;
        }

        .badge-conflict {
            background: #fee2e2;
            color: #991b1b;
        }

        .badge-platform {
            background: #e0e7ff;
            color: #3730a3;
        }

        .module-icon {
            font-size: 22px;
            margin-right: 10px;
        }

        .pin-input.conflict {
            border-color: #f87171;
            background: #fef2f2;
        }

        .pin-input.valid {
            border-color: #34d399;
        }

        .pin-status {
            margin-left: 8px;
            font-size: 16px;
        }

        .pin-status.ok {
            color: #10b981;
        }

        .pin-status.warning {
            color: #f59e0b;
        }

        .pin-status.error {
            color: #ef4444;
        }

        .validation-panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .validation-item {
            display: flex;
            align-items: start;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
        }

        .validation-item.error {
            background: #fef2f2;
            border-left: 3px solid #ef4444;
        }

        .validation-item.warning {
            background: #fffbeb;
            border-left: 3px solid #f59e0b;
        }

        .validation-item.info {
            background: #eff6ff;
            border-left: 3px solid #3b82f6;
        }

        .validation-icon {
            margin-right: 10px;
            font-size: 18px;
        }

        .module-filters {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .module-filters input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
        }

        .module-filters label {
            font-size: 13px;
            color: #4a5568;
        }

        .module-layout-controls {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        .btn-mini {
            border: 1px solid #cbd5e1;
            background: #f8fafc;
            color: #334155;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            padding: 6px 10px;
            cursor: pointer;
        }

        .btn-mini:hover {
            background: #eef2ff;
            border-color: #a5b4fc;
        }

        .pin-config {
            margin-top: 30px;
        }

        .pin-config h3 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #2d3748;
        }

        .pin-table {
            width: 100%;
            border-collapse: collapse;
        }

        .pin-table th {
            background: #f7fafc;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #4a5568;
            border-bottom: 2px solid #e2e8f0;
        }

        .pin-table td {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
        }

        .pin-table input, .pin-table select {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-size: 14px;
        }

        .pin-table input:focus, .pin-table select:focus {
            outline: none;
            border-color: #667eea;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e2e8f0;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .btn-success {
            background: #48bb78;
            color: white;
        }

        .btn-success:hover {
            background: #38a169;
        }

        .code-preview {
            background: #1a202c;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin-top: 20px;
        }

        .code-preview pre {
            margin: 0;
        }

        .templates-section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }

        .templates-section h3 {
            margin-bottom: 20px;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
        }

        .template-card {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .template-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
            transform: translateY(-2px);
        }

        .template-card.popular::before {
            content: '‚≠ê Popular';
            position: absolute;
            top: 10px;
            right: 10px;
            background: #fbbf24;
            color: white;
            font-size: 11px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .template-icon {
            font-size: 48px;
            margin-bottom: 15px;
            display: block;
        }

        .template-card h4 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #2d3748;
        }

        .template-card p {
            font-size: 13px;
            color: #718096;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .template-modules {
            font-size: 12px;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .template-modules strong {
            display: block;
            margin-bottom: 5px;
        }

        .template-tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .template-tag {
            font-size: 11px;
            padding: 3px 8px;
            background: #e0e7ff;
            color: #4338ca;
            border-radius: 3px;
            font-weight: 600;
        }

        .template-quick-actions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
        }

        .btn-template {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-template-preview {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-template-preview:hover {
            background: #cbd5e0;
        }

        .btn-template-use {
            background: #667eea;
            color: white;
        }

        .btn-template-use:hover {
            background: #5568d3;
        }

        .template-filter {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-tag {
            padding: 8px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }

        .filter-tag:hover {
            border-color: #cbd5e0;
        }

        .filter-tag.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .template-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .template-modal.active {
            display: flex;
        }

        .template-modal-content {
            background: white;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 30px;
        }

        .template-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 20px;
        }

        .template-modal-close {
            font-size: 24px;
            cursor: pointer;
            color: #718096;
        }

        .template-modal-close:hover {
            color: #2d3748;
        }

        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .alert-info {
            background: #bee3f8;
            border-left: 4px solid #3182ce;
            color: #2c5282;
        }

        .alert-success {
            background: #c6f6d5;
            border-left: 4px solid #38a169;
            color: #22543d;
        }

        .alert-danger {
            background: #fed7d7;
            border-left: 4px solid #e53e3e;
            color: #742a2a;
        }

        .toast-container {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            pointer-events: auto;
            min-width: 260px;
            max-width: 460px;
            padding: 12px 14px;
            border-radius: 8px;
            color: #fff;
            box-shadow: 0 8px 22px rgba(0, 0, 0, 0.2);
            font-size: 13px;
            line-height: 1.4;
        }

        .toast.info { background: #2b6cb0; }
        .toast.success { background: #2f855a; }
        .toast.warning { background: #b7791f; }
        .toast.error { background: #c53030; }

        .inline-output {
            margin-top: 16px;
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
            color: #2d3748;
            display: none;
        }

        .web-flasher-panel {
            margin-top: 24px;
            border: 1px solid #d6e5f5;
            border-radius: 10px;
            background: linear-gradient(180deg, #f7fbff 0%, #edf5ff 100%);
            padding: 16px;
        }

        .web-flasher-panel h3 {
            margin: 0 0 8px 0;
        }

        .web-flasher-subtitle {
            color: #334155;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .web-flasher-badges {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 8px 0 10px 0;
        }

        .web-flasher-badge {
            font-size: 12px;
            font-weight: 700;
            border-radius: 999px;
            padding: 4px 10px;
            border: 1px solid #cbd5e1;
            background: #f8fafc;
            color: #1e293b;
        }

        .web-flasher-badge.ok {
            background: #dcfce7;
            border-color: #86efac;
            color: #166534;
        }

        .web-flasher-badge.warn {
            background: #fef3c7;
            border-color: #fcd34d;
            color: #92400e;
        }

        .web-flasher-badge.err {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .web-flasher-steps {
            margin: 8px 0 6px 18px;
            color: #1f2937;
            font-size: 13px;
            line-height: 1.4;
        }

        .web-flasher-hint {
            margin-top: 8px;
            font-size: 13px;
            color: #334155;
        }

        .web-flasher-controls {
            margin-top: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .web-flasher-notes {
            margin-top: 12px;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid #bfdbfe;
            background: #eff6ff;
            color: #1e3a8a;
            font-size: 12px;
            line-height: 1.5;
        }

        .web-flasher-notes code {
            font-size: 11px;
        }

        .web-flasher-status {
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            color: #2d3748;
        }

        .search-box {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            font-size: 14px;
        }

        .search-box:focus {
            outline: none;
            border-color: #667eea;
        }

        @media (max-width: 900px) {
            .landing-grid {
                grid-template-columns: 1fr;
            }

            .config-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="toast-container" class="toast-container"></div>
    <div class="container">
        <div class="app-topbar">
            <div class="brand">
                <span class="brand-mark">B</span>
                <div>
                    <div class="brand-title">BasaltOS Configurator</div>
                    <div class="brand-sub">Build, configure, flash, and manage your board setups</div>
                </div>
            </div>
            <div class="topbar-actions">
                <button id="btn-home" class="btn-nav" type="button">Home</button>
                <button id="btn-open-config" class="btn-nav" type="button">Open Configurator</button>
                <button id="btn-market" class="btn-nav" type="button">App Market</button>
                <button id="btn-login" class="btn-nav" type="button">Sign In</button>
                <div id="top-profile-chip" class="profile-chip">Guest</div>
            </div>
        </div>

        <section id="landing-home" class="landing-home">
            <div class="landing-grid">
                <div class="landing-hero">
                    <h1>Welcome to the BasaltOS Builder</h1>
                    <p>
                        Start from templates, tune modules and pins, then flash directly to ESP32 from the browser.
                        You can keep a profile and board inventory so the workspace feels personal and repeatable.
                    </p>
                    <div class="landing-cta">
                        <button id="btn-start-config" class="btn btn-success" type="button">Start Configuring</button>
                        <button id="btn-start-esp32" class="btn btn-secondary" type="button">Quick Start: ESP32</button>
                    </div>
                    <div class="landing-stat">
                        <div class="landing-stat-box"><strong id="stat-platforms">0</strong>Platforms</div>
                        <div class="landing-stat-box"><strong id="stat-boards">0</strong>Boards</div>
                        <div class="landing-stat-box"><strong id="stat-market">0</strong>Market Apps</div>
                    </div>
                </div>
                <div class="landing-card">
                    <h3>Getting Started</h3>
                    <ul>
                        <li>1. Pick a board or template</li>
                        <li>2. Enable modules, starter apps, and market apps</li>
                        <li>3. Generate + Build, then Connect & Flash</li>
                        <li>4. Run apps from shell: <code>run &lt;app&gt;</code></li>
                    </ul>
                    <h3 style="margin-top:12px;">Tips</h3>
                    <ul>
                        <li>Use profile inventory to filter boards you own.</li>
                        <li>Use templates for reproducible project presets.</li>
                        <li>Web flasher supports Windows COM and Linux/macOS tty devices.</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="market-shell" class="market-shell">
            <div class="market-header">
                <div>
                    <h2>App Market</h2>
                    <div style="font-size:13px; color:#475569; margin-top:4px;">
                        Browse curated apps, download packages, upload your own, and add apps to the current build.
                    </div>
                </div>
                <div class="market-actions">
                    <input type="text" id="market-page-search" class="search-box" placeholder="Search market apps..." style="margin:0; min-width: 260px;">
                    <button id="btn-market-refresh" class="btn btn-secondary" type="button">Refresh</button>
                    <button id="btn-market-to-config" class="btn btn-primary" type="button">Back to Configurator</button>
                </div>
            </div>
            <div id="market-page-grid" class="market-grid"></div>
            <div class="market-upload">
                <h3>Upload App Package</h3>
                <div style="font-size:13px; color:#475569;">Upload a zip with <code>main.py</code> at package root (or one top-level folder).</div>
                <div class="market-upload-grid">
                    <input id="market-upload-id" type="text" placeholder="App ID (e.g. paint_plus)">
                    <input id="market-upload-name" type="text" placeholder="Display name">
                    <input id="market-upload-version" type="text" placeholder="Version (e.g. 0.1.0)">
                    <input id="market-upload-author" type="text" placeholder="Author">
                    <input id="market-upload-platforms" type="text" value="esp32" placeholder="Platforms (comma-separated)">
                    <textarea id="market-upload-description" rows="2" placeholder="Description"></textarea>
                    <input id="market-upload-package" type="file" accept=".zip,application/zip">
                </div>
                <div class="market-actions">
                    <button id="btn-market-upload" class="btn btn-success" type="button">Upload to Market</button>
                </div>
            </div>
        </section>

        <div id="configurator-shell">
        <div class="wizard-steps">
            <div class="step active" data-step="1">
                <div class="step-number">1</div>
                <div>Platform & Board</div>
            </div>
            <div class="step" data-step="2">
                <div class="step-number">2</div>
                <div>Modules</div>
            </div>
            <div class="step" data-step="3">
                <div class="step-number">3</div>
                <div>Pin Configuration</div>
            </div>
            <div class="step" data-step="4">
                <div class="step-number">4</div>
                <div>Generate</div>
            </div>
        </div>

        <div class="config-panel">
            <!-- Sidebar -->
            <div class="sidebar">
                <div id="platform-selection">
                    <h3>Platform</h3>
                    <div class="alert alert-danger" id="platform-load-error" style="display:none; margin-bottom: 10px;"></div>
                    <select id="platform-select" class="search-box">
                        <!-- populated by JS from /api/platforms -->
                    </select>
                </div>

                <div id="board-selection" style="margin-top: 20px;">
                    <h3>Boards</h3>
                    <input type="text" class="search-box" placeholder="Search boards..." id="board-search">
                    <ul class="board-list" id="board-list">
                        <!-- Populated by JavaScript -->
                    </ul>
                </div>

                <div class="profile-card" id="profile-card">
                    <h3 style="margin-bottom: 10px;">Profile & Inventory</h3>
                    <label for="profile-name">Builder Name</label>
                    <input type="text" id="profile-name" placeholder="Your handle">
                    <div class="profile-stats" id="profile-stats">Owned boards: 0 ‚Ä¢ Points: 0</div>
                    <label style="margin: 0;">
                        <input type="checkbox" id="owned-only-toggle">
                        Show only boards in my inventory
                    </label>
                    <div class="inventory-panel">
                        <details>
                            <summary style="cursor:pointer; font-size:12px; color:#2d3748;">Manage board inventory</summary>
                            <div class="inventory-list" id="inventory-list"></div>
                        </details>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <!-- Step 1: Board Selection -->
                <div id="step-1" class="content-section active">
                    <div class="alert alert-info">
                        <strong>Welcome!</strong> Select a platform and board to get started with your BasaltOS configuration.
                    </div>

                    <div class="templates-section">
                        <h3>üöÄ Quick Start Templates</h3>
                        <div class="template-filter" id="template-filters">
                            <!-- Filter tags populated by JS -->
                        </div>
                        <div class="template-grid" id="templates-grid">
                            <!-- Templates populated by JS -->
                        </div>
                    </div>
                    
                    <div id="board-details" style="display: none;">
                        <div class="board-header">
                            <div class="board-image">üìü</div>
                            <div class="board-info">
                                <h2 id="board-name">CYD ESP32-3248S035R</h2>
                                <p id="board-description">3.5" TFT display with resistive touch, ESP32 powered</p>
                            </div>
                        </div>

                        <div class="board-specs">
                            <div class="spec-item">
                                <div class="spec-label">MCU</div>
                                <div class="spec-value" id="spec-mcu">ESP32-WROOM-32</div>
                            </div>
                            <div class="spec-item">
                                <div class="spec-label">Flash</div>
                                <div class="spec-value" id="spec-flash">4MB</div>
                            </div>
                            <div class="spec-item">
                                <div class="spec-label">RAM</div>
                                <div class="spec-value" id="spec-ram">520KB</div>
                            </div>
                            <div class="spec-item">
                                <div class="spec-label">Display</div>
                                <div class="spec-value" id="spec-display">320x480 ST7796</div>
                            </div>
                            <div class="spec-item">
                                <div class="spec-label">Target Profile</div>
                                <div class="spec-value" id="spec-target">‚Äî</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Module Selection -->
                <div id="step-2" class="content-section">
                    <h2 style="margin-bottom: 20px;">Select Modules</h2>
                    <div class="alert alert-info">
                        Enable or disable modules based on your application needs. Pin assignments will be configured in the next step.
                    </div>

                    <div class="module-filters">
                        <input type="text" id="module-search" placeholder="üîç Search modules...">
                        <label>
                            <input type="checkbox" id="show-enabled-only"> Show enabled only
                        </label>
                        <div class="module-layout-controls">
                            <button class="btn-mini" id="btn-expand-modules" type="button">Expand All</button>
                            <button class="btn-mini" id="btn-collapse-modules" type="button">Collapse All</button>
                        </div>
                    </div>

                    <div class="validation-panel" id="validation-warnings">
                        <!-- Validation messages appear here -->
                    </div>
                    
                    <div class="module-grid" id="module-grid">
                        <!-- Populated by JavaScript -->
                    </div>

                    <h3 style="margin-top: 30px;">Selected Apps</h3>
                    <div class="alert alert-info">
                        App selection is managed in the App Market page. This panel is read-only visibility for current build selection.
                    </div>
                    <div id="selected-apps-visibility" class="validation-panel"></div>
                    <div style="margin-top:10px;">
                        <button id="btn-open-market-from-config" class="btn btn-secondary" type="button">Manage Apps in App Market</button>
                    </div>
                </div>

                <!-- Step 3: Pin Configuration -->
                <div id="step-3" class="content-section">
                    <h2 style="margin-bottom: 20px;">Pin Configuration</h2>
                    <div class="alert alert-info">
                        Configure pin assignments for enabled modules. Default values are provided based on your board.
                    </div>

                    <div class="validation-panel" id="pin-validation">
                        <!-- Pin conflict warnings appear here -->
                    </div>

                    <div class="pin-config">
                        <h3>Pin Assignments</h3>
                        <table class="pin-table" id="pin-table">
                            <thead>
                                <tr>
                                    <th>Module</th>
                                    <th>Signal</th>
                                    <th>Pin</th>
                                    <th>Alternative Pins</th>
                                </tr>
                            </thead>
                            <tbody id="pin-table-body">
                                <!-- Populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Step 4: Generate -->
                <div id="step-4" class="content-section">
                    <h2 style="margin-bottom: 20px;">Generate Configuration</h2>
                    <div class="alert alert-success">
                        <strong>Configuration Complete!</strong> Review your settings and generate the configuration files.
                    </div>

                    <div style="margin-top: 30px;">
                        <h3>Configuration Summary</h3>
                        <div id="config-summary" style="margin-top: 15px;">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <div style="margin-top: 30px;">
                        <h3>Validation Report</h3>
                        <div class="validation-panel" id="validation-report">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <div style="margin-top: 30px;">
                        <h3>Preview: basalt_config.h</h3>
                        <div class="code-preview">
                            <pre id="config-preview">/* Generated configuration will appear here */</pre>
                        </div>
                    </div>

                    <div id="generate-output" class="inline-output"></div>

                    <div id="web-flasher-panel" class="web-flasher-panel" style="display:none;">
                        <h3>ESP32 Web Flasher</h3>
                        <div class="web-flasher-subtitle">Flash directly from this page via Web Serial (Chrome/Edge on <code>http://localhost</code> or HTTPS).</div>
                        <div class="web-flasher-badges">
                            <span id="badge-firmware" class="web-flasher-badge">Firmware: unknown</span>
                            <span id="badge-serial-port" class="web-flasher-badge">Serial port: unknown</span>
                        </div>
                        <ol class="web-flasher-steps">
                            <li>Click <strong>Check Firmware + Port</strong>.</li>
                            <li>Click <strong>Connect &amp; Flash</strong>, then choose the ESP32 USB serial device in the picker (<code>COMx</code> on Windows, <code>ttyUSB*</code>/<code>ttyACM*</code> on Linux).</li>
                            <li>If connect fails, click <strong>Release Browser Port Lock</strong> and retry.</li>
                        </ol>
                        <div class="web-flasher-controls">
                            <button class="btn btn-secondary" id="btn-refresh-flasher">Check Firmware + Port</button>
                            <button class="btn btn-secondary" id="btn-release-serial">Release Browser Port Lock</button>
                            <button class="btn btn-primary" id="btn-local-flash">Local Flash (idf.py)</button>
                            <esp-web-install-button id="esp-web-install" style="display:none;">
                                <button slot="activate" class="btn btn-primary">Connect &amp; Flash</button>
                            </esp-web-install-button>
                        </div>
                        <div id="web-flasher-hint" class="web-flasher-hint">Run a check before connecting.</div>
                        <details class="web-flasher-notes">
                            <summary><strong>Troubleshooting</strong></summary>
                            <div>1) In the picker, select the ESP32 USB serial device (<code>COMx</code> / <code>ttyUSB*</code> / <code>ttyACM*</code>), not unrelated system ports.</div>
                            <div>2) If ‚ÄúSerial port is not ready‚Äù, click <code>Release Browser Port Lock</code> and retry.</div>
                            <div>3) If still blocked, unplug/replug USB and run check again.</div>
                            <div>4) If needed, use <code>Local Flash (idf.py)</code> fallback.</div>
                        </details>
                        <div id="web-flasher-status" class="web-flasher-status"></div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="btn btn-secondary" id="btn-prev" style="display: none;">‚Üê Previous</button>
                    <button class="btn btn-primary" id="btn-next">Next ‚Üí</button>
                    <button class="btn btn-primary" id="btn-generate-build" style="display: none;">Generate + Build ESP32</button>
                    <button class="btn btn-success" id="btn-generate" style="display: none;">Generate Files</button>
                </div>
            </div>
        </div>
        </div>
    </div>

    <div class="template-modal" id="template-modal">
        <div class="template-modal-content" id="template-modal-body">
            <!-- Modal content populated by JS -->
        </div>
    </div>

    <script type="module" src="https://unpkg.com/esp-web-tools@10/dist/web/install-button.js?module"></script>
    <script>
        function notify(message, type = 'info', timeoutMs = 3600) {
            const container = document.getElementById('toast-container');
            if (!container) return;
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            window.setTimeout(() => toast.remove(), timeoutMs);
        }

        function showInlineOutput(text, type = 'info') {
            const output = document.getElementById('generate-output');
            if (!output) return;
            output.style.display = 'block';
            output.style.borderColor = type === 'error' ? '#feb2b2' : '#cbd5e0';
            output.style.background = type === 'error' ? '#fff5f5' : '#f7fafc';
            output.textContent = text;
        }

        function clearInlineOutput() {
            const output = document.getElementById('generate-output');
            if (!output) return;
            output.style.display = 'none';
            output.textContent = '';
        }

        function renderWebFlasherStatus(status) {
            const statusEl = document.getElementById('web-flasher-status');
            if (!statusEl) return;
            if (!status) {
                statusEl.textContent = 'No status available.';
                return;
            }

            const lines = [];
            lines.push(`Ready: ${status.ready ? 'yes' : 'no'}`);
            if (status.build_version) {
                lines.push(`Build version: ${status.build_version}`);
            }
            if (Array.isArray(status.missing_required) && status.missing_required.length > 0) {
                lines.push(`Missing required: ${status.missing_required.join(', ')}`);
                lines.push('Build command: SDKCONFIG_DEFAULTS=config/generated/sdkconfig.defaults idf.py -B build build');
            }
            if (Array.isArray(status.files)) {
                lines.push('');
                status.files.forEach(f => {
                    const sz = Number(f.size || 0);
                    const stamp = f.mtime_ns ? `, v=${f.mtime_ns}` : '';
                    lines.push(`${f.exists ? 'OK ' : 'MISS'} 0x${Number(f.offset).toString(16).toUpperCase().padStart(6, '0')}  ${f.name}  (${sz} bytes${stamp})`);
                });
            }
            statusEl.textContent = lines.join('\n');
        }

        function setFlasherBadges({ firmwareReady = null, portBusy = null, secureContext = true } = {}) {
            const fw = document.getElementById('badge-firmware');
            const sp = document.getElementById('badge-serial-port');
            if (fw) {
                fw.className = 'web-flasher-badge';
                if (firmwareReady === true) {
                    fw.classList.add('ok');
                    fw.textContent = 'Firmware: ready';
                } else if (firmwareReady === false) {
                    fw.classList.add('err');
                    fw.textContent = 'Firmware: missing artifacts';
                } else {
                    fw.textContent = 'Firmware: unknown';
                }
            }
            if (sp) {
                sp.className = 'web-flasher-badge';
                if (!secureContext) {
                    sp.classList.add('warn');
                    sp.textContent = 'Serial: blocked (context)';
                } else if (portBusy === true) {
                    sp.classList.add('err');
                    sp.textContent = 'Serial: busy';
                } else if (portBusy === false) {
                    sp.classList.add('ok');
                    sp.textContent = 'Serial: free';
                } else {
                    sp.textContent = 'Serial: unknown';
                }
            }
        }

        async function refreshWebFlasher({ silent = false } = {}) {
            const panel = document.getElementById('web-flasher-panel');
            const install = document.getElementById('esp-web-install');
            const statusEl = document.getElementById('web-flasher-status');
            const hintEl = document.getElementById('web-flasher-hint');
            if (!panel || !install || !statusEl) return;

            const isEsp32 = selectedPlatform === 'esp32';
            const canShow = currentStep === 4 && isEsp32;
            panel.style.display = canShow ? 'block' : 'none';
            if (!canShow) return;

            if (!window.isSecureContext) {
                install.style.display = 'none';
                statusEl.textContent = 'Web Serial requires secure context (use localhost or HTTPS).';
                setFlasherBadges({ secureContext: false });
                if (hintEl) hintEl.textContent = 'Open from localhost/HTTPS to enable browser flashing.';
                return;
            }

            try {
                const status = await apiFetchJson('/api/flash/esp32/status');
                renderWebFlasherStatus(status);
                let anyBusy = null;
                try {
                    const ports = await apiFetchJson('/api/flash/esp32/ports');
                    if (Array.isArray(ports.ports) && ports.ports.length > 0) {
                        const statusEl = document.getElementById('web-flasher-status');
                        const lines = [statusEl.textContent || '', '', 'Serial ports:'];
                        ports.ports.forEach(p => {
                            lines.push(`- ${p.path}: ${p.busy ? 'BUSY' : 'free'}`);
                            if (p.busy && Array.isArray(p.holders)) {
                                p.holders.forEach(h => lines.push(`    ${h}`));
                            }
                        });
                        statusEl.textContent = lines.join('\n').trim();
                        anyBusy = !!ports.any_busy;
                    }
                } catch (_portErr) {
                    // Keep flasher usable even if host serial probe is unavailable.
                }
                if (status.ready) {
                    const boardRef = selectedBoard?.id ? `?board_id=${encodeURIComponent(selectedBoard.id)}&t=${Date.now()}` : `?t=${Date.now()}`;
                    install.setAttribute('manifest', `/api/flash/esp32/manifest${boardRef}`);
                    install.style.display = 'inline-block';
                    setFlasherBadges({ firmwareReady: true, portBusy: anyBusy, secureContext: true });
                    if (hintEl) {
                        hintEl.textContent = anyBusy
                            ? 'Serial appears busy. Release browser port lock, then Connect & Flash.'
                            : 'Ready. Click Connect & Flash and select the ESP32 USB serial device (COMx/ttyUSB*/ttyACM*).';
                    }
                } else {
                    install.style.display = 'none';
                    setFlasherBadges({ firmwareReady: false, portBusy: anyBusy, secureContext: true });
                    if (hintEl) hintEl.textContent = 'Generate/build firmware artifacts first, then run check again.';
                }
            } catch (err) {
                install.style.display = 'none';
                statusEl.textContent = `Failed to load flash status: ${err.message || err}`;
                setFlasherBadges({ firmwareReady: null, portBusy: null, secureContext: true });
                if (hintEl) hintEl.textContent = 'Status check failed. Verify backend server and retry.';
                if (!silent) notify(statusEl.textContent, 'error');
            }
        }

        async function releaseBrowserSerialPorts() {
            if (!('serial' in navigator) || !navigator.serial?.getPorts) {
                notify('Web Serial API unavailable in this browser.', 'warning');
                return;
            }
            try {
                const ports = await navigator.serial.getPorts();
                let closed = 0;
                for (const p of ports) {
                    try {
                        await p.close();
                        closed++;
                    } catch (_e) {
                        // Ignore; port may already be closed.
                    }
                }
                notify(`Released ${closed} browser serial port(s).`, 'success');
                const hintEl = document.getElementById('web-flasher-hint');
                if (hintEl) hintEl.textContent = 'Browser port handles released. Run check, then connect again.';
                await refreshWebFlasher({ silent: true });
            } catch (err) {
                notify(`Failed to release serial ports: ${err.message || err}`, 'error');
            }
        }

        async function localFlashEsp32() {
            const btn = document.getElementById('btn-local-flash');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Flashing...';
            }
            try {
                const resp = await fetch('/api/flash/esp32/local', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const raw = await resp.text();
                let data = null;
                try {
                    data = raw ? JSON.parse(raw) : null;
                } catch (_e) {
                    data = null;
                }

                if (!resp.ok || !data?.success) {
                    const msg = data?.error || data?.message || raw || `HTTP ${resp.status}`;
                    const details = data?.output || raw || '';
                    showInlineOutput(`Local flash failed: ${msg}\n\n${details}`.trim(), 'error');
                    notify(`Local flash failed: ${msg}`, 'error');
                    return;
                }

                const output = data?.output ? String(data.output) : '(no output)';
                showInlineOutput(`Local flash succeeded on ${data.port || '(unknown)'}:\n\n${output}`, 'success');
                notify('Local flash completed successfully.', 'success');
            } catch (err) {
                const msg = `Local flash failed: ${err.message || err}`;
                showInlineOutput(msg, 'error');
                notify(msg, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Local Flash (idf.py)';
                }
                refreshWebFlasher({ silent: true });
            }
        }

        async function apiFetchJson(url, options = {}) {
            const fetchOptions = {
                cache: 'no-store',
                ...options,
            };
            const resp = await fetch(url, fetchOptions);
            const raw = await resp.text();
            let payload = null;
            try {
                payload = raw ? JSON.parse(raw) : null;
            } catch (_e) {
                payload = null;
            }
            if (!resp.ok) {
                const msg = payload?.error || payload?.message || raw || `HTTP ${resp.status}`;
                throw new Error(msg);
            }
            return payload;
        }

        function showPlatformError(msg) {
            const errorEl = document.getElementById('platform-load-error');
            if (!errorEl) return;
            errorEl.style.display = 'block';
            errorEl.textContent = msg;
            notify(msg, 'error', 5200);
        }

        window.addEventListener('error', (e) => {
            showPlatformError(`UI error: ${e.message}`);
        });

        // Data structures
        let platforms = [];
        let boards = {};
        let modules = [];
        let applets = [];
        let appletStates = {};
        let marketApps = [];
        let marketAppStates = {};
        let marketCatalog = [];
        let userProfile = {
            name: '',
            ownedBoards: []
        };
        let targets = {};
        let boardDetails = {};
        let moduleConfigs = {};
        let projectTemplates = [];
        let configuratorVisible = false;

        const MODULE_ICONS = {
            uart: 'üì°',
            spi: 'üîÑ',
            i2c: '‚ÜîÔ∏è',
            tft: 'üñ•Ô∏è',
            fs_spiffs: 'üíæ',
            fs_sd: 'üíø',
            wifi: 'üì∂',
            bluetooth: 'üìò',
            shell_full: '‚å®Ô∏è',
            shell_min: '‚å®Ô∏è',
            psram: 'üß†'
        };

        const APPLET_META = {
            blink: { name: 'Blink', description: 'Toggle a pin/LED repeatedly.', icon: 'üí°' },
            uart_echo: { name: 'UART Echo', description: 'Echo bytes over UART.', icon: 'üõ∞Ô∏è' },
            remote_node: { name: 'Remote Node', description: 'Simple UART remote node protocol.', icon: 'üì°' },
            system_info: { name: 'System Info', description: 'Print board, memory, and runtime status at startup.', icon: 'üìã' },
            tft_hello: { name: 'TFT Hello', description: 'Render a basic hello/status screen on TFT.', icon: 'üñ•Ô∏è', requires_capabilities: ['tft'] },
            sd_probe: { name: 'SD Probe', description: 'Check SD mount and list top-level files.', icon: 'üíø', requires_capabilities: ['sd_card'] },
            fs_smoke: { name: 'FS Smoke', description: 'Create/read/remove test file in storage.', icon: 'üß™' },
            i2c_scan: { name: 'I2C Scan', description: 'Scan I2C bus for attached devices.', icon: 'üîé', requires_capabilities: ['i2c'] },
            wifi_status: { name: 'WiFi Status', description: 'Show Wi-Fi status and station metadata.', icon: 'üì∂', requires_capabilities: ['wifi'] }
        };

        const PLATFORM_APPLETS = {
            esp32: ['blink', 'system_info', 'tft_hello', 'fs_smoke', 'sd_probe', 'i2c_scan', 'wifi_status']
        };

        let moduleSectionState = {};

        function getModuleIcon(moduleId) {
            return MODULE_ICONS[moduleId] || 'üì¶';
        }

        function getAppletMeta(appletId) {
            return APPLET_META[appletId] || { name: appletId, description: '', icon: 'üß©' };
        }

        function appletAllowedByBoard(appletId, board) {
            const meta = getAppletMeta(appletId);
            const req = Array.isArray(meta.requires_capabilities) ? meta.requires_capabilities : [];
            if (req.length === 0) return true;
            const caps = new Set((board?.capabilities || []).map(x => String(x)));
            return req.every(c => caps.has(c));
        }

        function availableAppletsForBoard(board) {
            const targetId = board?.target_profile;
            const target = targetId ? targets[targetId] : null;
            const fromTarget = Array.isArray(target?.applets) ? target.applets : [];
            if (fromTarget.length > 0) {
                return fromTarget.filter(a => appletAllowedByBoard(a, board));
            }
            const platformId = board?.platform || selectedPlatform;
            const fromPlatform = Array.isArray(PLATFORM_APPLETS[platformId]) ? PLATFORM_APPLETS[platformId] : [];
            return fromPlatform.filter(a => appletAllowedByBoard(a, board));
        }

        function availableMarketAppsForBoard(board) {
            const platformId = board?.platform || selectedPlatform;
            return marketCatalog.filter(item => {
                const plats = Array.isArray(item.platforms) ? item.platforms : [];
                return plats.length === 0 || plats.includes(platformId);
            });
        }

        function profileStorageKey() {
            return 'basaltos_profile_v1';
        }

        function updateTopProfileChip() {
            const chip = document.getElementById('top-profile-chip');
            const loginBtn = document.getElementById('btn-login');
            if (!chip) return;
            const name = String(userProfile?.name || '').trim();
            if (name) {
                chip.textContent = name;
                if (loginBtn) loginBtn.textContent = 'Switch User';
            } else {
                chip.textContent = 'Guest';
                if (loginBtn) loginBtn.textContent = 'Sign In';
            }
        }

        function updateLandingStats() {
            const platformCount = document.getElementById('stat-platforms');
            const boardCount = document.getElementById('stat-boards');
            const marketCount = document.getElementById('stat-market');
            const platformTotal = Array.isArray(platforms) ? platforms.length : 0;
            const boardTotal = Object.values(boards || {}).reduce((sum, list) => {
                return sum + (Array.isArray(list) ? list.length : 0);
            }, 0);
            const marketTotal = Array.isArray(marketCatalog) ? marketCatalog.length : 0;
            if (platformCount) platformCount.textContent = String(platformTotal);
            if (boardCount) boardCount.textContent = String(boardTotal);
            if (marketCount) marketCount.textContent = String(marketTotal);
        }

        function showLanding() {
            configuratorVisible = false;
            const landing = document.getElementById('landing-home');
            const shell = document.getElementById('configurator-shell');
            const marketShell = document.getElementById('market-shell');
            if (landing) landing.style.display = 'block';
            if (shell) shell.style.display = 'none';
            if (marketShell) marketShell.style.display = 'none';
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function enterConfigurator(step = null) {
            configuratorVisible = true;
            const landing = document.getElementById('landing-home');
            const shell = document.getElementById('configurator-shell');
            const marketShell = document.getElementById('market-shell');
            if (landing) landing.style.display = 'none';
            if (shell) shell.style.display = 'block';
            if (marketShell) marketShell.style.display = 'none';
            if (typeof step === 'number' && step >= 1 && step <= 4) {
                currentStep = step;
            }
            updateWizardSteps();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function showMarketPage() {
            const landing = document.getElementById('landing-home');
            const shell = document.getElementById('configurator-shell');
            const marketShell = document.getElementById('market-shell');
            if (landing) landing.style.display = 'none';
            if (shell) shell.style.display = 'none';
            if (marketShell) marketShell.style.display = 'block';
            renderMarketPage();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function starterCatalogForMarket() {
            const fromPlatform = Array.isArray(PLATFORM_APPLETS[selectedPlatform]) ? PLATFORM_APPLETS[selectedPlatform] : [];
            return fromPlatform.filter(Boolean);
        }

        function starterAllowedForCurrentBuild(appId) {
            if (!selectedBoard) return false;
            const allowed = new Set(availableAppletsForBoard(selectedBoard));
            return allowed.has(String(appId));
        }

        function marketAllowedForCurrentBuild(appId) {
            if (!selectedBoard) return false;
            const allowed = new Set(availableMarketAppsForBoard(selectedBoard).map(x => x.id));
            return allowed.has(String(appId));
        }

        function renderSelectedAppsVisibility() {
            const wrap = document.getElementById('selected-apps-visibility');
            if (!wrap) return;
            const selectedStarter = applets.filter(a => appletStates[a]);
            const selectedMarket = marketApps.filter(a => marketAppStates[a]);
            wrap.innerHTML = `
                <div class="validation-item info">
                    <span class="validation-icon">üì¶</span>
                    <div><strong>Starter Apps:</strong> ${selectedStarter.length ? selectedStarter.join(', ') : '(none)'}</div>
                </div>
                <div class="validation-item info">
                    <span class="validation-icon">üõí</span>
                    <div><strong>Market Apps:</strong> ${selectedMarket.length ? selectedMarket.join(', ') : '(none)'}</div>
                </div>
            `;
        }

        function renderMarketPage() {
            const grid = document.getElementById('market-page-grid');
            if (!grid) return;
            const search = String(document.getElementById('market-page-search')?.value || '').toLowerCase().trim();
            applets = starterCatalogForMarket();
            marketApps = (marketCatalog || []).map(item => item.id);
            const starter = starterCatalogForMarket().map(id => {
                const meta = getAppletMeta(id);
                return {
                    id,
                    name: meta.name || id,
                    description: meta.description || '',
                    kind: 'starter',
                    platforms: [selectedPlatform],
                    version: 'builtin',
                };
            }).filter(item => {
                const blob = `${item.id} ${item.name || ''} ${item.description || ''}`.toLowerCase();
                return !search || blob.includes(search);
            });
            const market = (marketCatalog || []).filter(item => {
                const blob = `${item.id} ${item.name || ''} ${item.description || ''}`.toLowerCase();
                return !search || blob.includes(search);
            });
            const items = [...starter, ...market.map(x => ({ ...x, kind: 'market' }))];
            grid.innerHTML = '';
            if (!items.length) {
                grid.innerHTML = '<div class="board-empty">No market apps found for current filters.</div>';
                return;
            }
            if (!selectedBoard) {
                const msg = document.createElement('div');
                msg.className = 'alert alert-warning';
                msg.style.gridColumn = '1 / -1';
                msg.textContent = 'Select platform and board in Configurator first. Add-to-build is disabled until board compatibility can be checked.';
                grid.appendChild(msg);
            }
            items.forEach(item => {
                const card = document.createElement('div');
                card.className = 'market-card';
                const enabled = item.kind === 'starter' ? !!appletStates[item.id] : !!marketAppStates[item.id];
                const allowed = item.kind === 'starter'
                    ? starterAllowedForCurrentBuild(item.id)
                    : marketAllowedForCurrentBuild(item.id);
                const reason = !selectedBoard
                    ? 'Select board first'
                    : (allowed ? 'Supported by current board' : 'Not supported by current board');
                card.innerHTML = `
                    <h4>${item.name || item.id}</h4>
                    <p>${item.description || ''}</p>
                    <div class="market-meta">
                        type: <code>${item.kind === 'starter' ? 'starter-app' : 'market-app'}</code><br>
                        id: <code>${item.id}</code><br>
                        version: <code>${item.version || '0.1.0'}</code><br>
                        platforms: <code>${(item.platforms || []).join(', ') || selectedPlatform}</code>
                    </div>
                    <div class="market-actions">
                        <label title="${reason}">
                            <input type="checkbox" data-market-page-add="${item.id}" data-market-kind="${item.kind}" ${enabled ? 'checked' : ''} ${allowed ? '' : 'disabled'}>
                            Add to current build
                        </label>
                        ${item.kind === 'market' ? `<button class="btn btn-secondary" type="button" data-market-download="${item.id}">Download</button>` : ''}
                    </div>
                `;
                grid.appendChild(card);
            });
            grid.querySelectorAll('[data-market-page-add]').forEach(el => {
                el.addEventListener('change', () => {
                    const id = el.getAttribute('data-market-page-add');
                    const kind = el.getAttribute('data-market-kind');
                    if (kind === 'starter') {
                        appletStates[id] = !!el.checked;
                    } else {
                        marketAppStates[id] = !!el.checked;
                    }
                    renderSelectedAppsVisibility();
                    notify(`${id} ${el.checked ? 'added to' : 'removed from'} current build.`, 'success', 1600);
                });
            });
            grid.querySelectorAll('[data-market-download]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const id = btn.getAttribute('data-market-download');
                    const platform = encodeURIComponent(selectedPlatform || '');
                    window.open(`/api/market/download/${encodeURIComponent(id)}?platform=${platform}`, '_blank');
                });
            });
        }

        async function uploadMarketApp() {
            const fileInput = document.getElementById('market-upload-package');
            const idInput = document.getElementById('market-upload-id');
            const nameInput = document.getElementById('market-upload-name');
            const descInput = document.getElementById('market-upload-description');
            const verInput = document.getElementById('market-upload-version');
            const authorInput = document.getElementById('market-upload-author');
            const platformsInput = document.getElementById('market-upload-platforms');
            const btn = document.getElementById('btn-market-upload');

            const file = fileInput?.files?.[0];
            if (!file) {
                notify('Choose a ZIP package to upload.', 'warning');
                return;
            }

            const fd = new FormData();
            fd.append('package', file);
            fd.append('id', String(idInput?.value || '').trim());
            fd.append('name', String(nameInput?.value || '').trim());
            fd.append('description', String(descInput?.value || '').trim());
            fd.append('version', String(verInput?.value || '').trim());
            fd.append('author', String(authorInput?.value || '').trim());
            fd.append('platforms', String(platformsInput?.value || selectedPlatform || 'esp32').trim());

            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Uploading...';
            }
            try {
                const resp = await fetch('/api/market/upload', { method: 'POST', body: fd, cache: 'no-store' });
                const raw = await resp.text();
                let data = null;
                try { data = raw ? JSON.parse(raw) : null; } catch (_e) { data = null; }
                if (!resp.ok || !data?.success) {
                    throw new Error(data?.error || raw || `HTTP ${resp.status}`);
                }
                await refreshMarketCatalogForPlatform(selectedPlatform);
                updateLandingStats();
                populateMarketAppGrid();
                renderMarketPage();
                if (idInput) idInput.value = '';
                if (nameInput) nameInput.value = '';
                if (descInput) descInput.value = '';
                if (verInput) verInput.value = '';
                if (authorInput) authorInput.value = '';
                if (fileInput) fileInput.value = '';
                notify(`Uploaded market app: ${data.app?.id || 'unknown'}`, 'success');
            } catch (err) {
                notify(`Upload failed: ${err.message || err}`, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Upload to Market';
                }
            }
        }

        function loadUserProfile() {
            try {
                const raw = localStorage.getItem(profileStorageKey());
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') return;
                userProfile.name = String(parsed.name || '');
                userProfile.ownedBoards = Array.isArray(parsed.ownedBoards) ? parsed.ownedBoards.map(x => String(x)) : [];
            } catch (_e) {
                userProfile = { name: '', ownedBoards: [] };
            }
        }

        function saveUserProfile() {
            try {
                localStorage.setItem(profileStorageKey(), JSON.stringify(userProfile));
            } catch (_e) {
                // ignore persistence errors
            }
            updateTopProfileChip();
        }

        function boardGroupLabel(board) {
            const id = String(board?.id || '').toLowerCase();
            const name = String(board?.name || '').toLowerCase();
            const mcu = String(board?.mcu || '').toLowerCase();
            const text = `${id} ${name}`;
            if (selectedPlatform !== 'esp32') return 'Boards';
            if (text.includes('cyd') || text.includes('display') || text.includes('t-display') || text.includes('m5')) return 'Display & Product Boards';
            if (text.includes('devkit') || text.includes('dev board') || text.includes('node') || text.includes('wroom') || text.includes('wrover')) return 'Dev Kits';
            if (text.includes('module') || text.includes('mini') || text.includes('supermini')) return 'Modules & Mini Boards';
            if (mcu.includes('c3')) return 'SoC Family: ESP32-C3';
            if (mcu.includes('s2')) return 'SoC Family: ESP32-S2';
            if (mcu.includes('s3')) return 'SoC Family: ESP32-S3';
            if (mcu.includes('c6')) return 'SoC Family: ESP32-C6';
            return 'SoC Family: ESP32';
        }

        function renderProfilePanel() {
            const nameInput = document.getElementById('profile-name');
            const ownedOnly = document.getElementById('owned-only-toggle');
            const stats = document.getElementById('profile-stats');
            const inventory = document.getElementById('inventory-list');
            if (!nameInput || !ownedOnly || !stats || !inventory) return;

            if (nameInput.value !== userProfile.name) {
                nameInput.value = userProfile.name || '';
            }

            const platformBoards = boards[selectedPlatform] || [];
            const ownedSet = new Set((userProfile.ownedBoards || []).map(String));
            const points = (ownedSet.size * 25);
            stats.textContent = `Owned boards: ${ownedSet.size} ‚Ä¢ Points: ${points}`;

            inventory.innerHTML = '';
            if (!platformBoards.length) {
                inventory.innerHTML = '<div class="board-empty">No boards available for this platform.</div>';
                return;
            }
            platformBoards.forEach(board => {
                const row = document.createElement('label');
                row.className = 'inventory-item';
                row.innerHTML = `
                    <input type="checkbox" data-owned-board="${board.id}" ${ownedSet.has(String(board.id)) ? 'checked' : ''}>
                    <span>${board.name}</span>
                `;
                inventory.appendChild(row);
            });
            updateTopProfileChip();
        }

        function moduleSectionFor(moduleId) {
            const id = String(moduleId || '');
            if (id.startsWith('fs_')) return 'storage';
            if (['uart', 'spi', 'i2c', 'remote_node'].includes(id)) return 'connectivity';
            if (['tft', 'shell_full', 'shell_min'].includes(id)) return 'ui_shell';
            if (['psram', 'adc', 'pwm', 'eeprom'].includes(id)) return 'advanced';
            return 'core';
        }

        function moduleSectionLabel(sectionId) {
            const map = {
                core: 'Core Runtime',
                connectivity: 'Connectivity & Buses',
                storage: 'Storage',
                ui_shell: 'UI & Shell',
                advanced: 'Advanced & Peripherals'
            };
            return map[sectionId] || sectionId;
        }
        
        function populateAppletGrid() {
            const available = availableAppletsForBoard(selectedBoard);
            applets = available;
            const grid = document.getElementById('applet-grid');
            if (!grid) return;
            grid.innerHTML = '';

            if (!available.length) {
                const empty = document.createElement('div');
                empty.className = 'module-description';
                empty.textContent = 'No starter apps available for this board/platform.';
                grid.appendChild(empty);
                return;
            }

            available.forEach(appletId => {
                const meta = getAppletMeta(appletId);
                const enabled = !!appletStates[appletId];
                const card = document.createElement('div');
                card.className = `module-card ${enabled ? 'enabled' : ''}`;
                card.id = `applet-card-${appletId}`;
                card.innerHTML = `
                    <div class="module-header">
                        <div style="display:flex; align-items:center;">
                            <span class="module-icon">${meta.icon}</span>
                            <div class="module-name">${meta.name}</div>
                        </div>
                        <label class="toggle">
                            <input type="checkbox" ${enabled ? 'checked' : ''} data-applet="${appletId}">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="module-description">${meta.description}</div>
                `;

                const toggle = card.querySelector('input[type="checkbox"]');
                toggle.onchange = () => {
                    appletStates[appletId] = toggle.checked;
                    card.classList.toggle('enabled', toggle.checked);
                    updateValidation();
                };

                grid.appendChild(card);
            });
        }

        function populateMarketAppGrid() {
            const allForBoard = availableMarketAppsForBoard(selectedBoard);
            marketApps = allForBoard.map(x => x.id);
            const grid = document.getElementById('market-app-grid');
            if (!grid) return;
            grid.innerHTML = '';

            const search = String(document.getElementById('market-search')?.value || '').toLowerCase();
            const available = allForBoard.filter(item => {
                if (!search) return true;
                const hay = `${item.id} ${item.name || ''} ${item.description || ''} ${(item.tags || []).join(' ')}`.toLowerCase();
                return hay.includes(search);
            });
            if (!available.length) {
                const empty = document.createElement('div');
                empty.className = 'module-description';
                empty.textContent = 'No curated apps available for this board/platform.';
                grid.appendChild(empty);
                return;
            }

            available.forEach(item => {
                const enabled = !!marketAppStates[item.id];
                const card = document.createElement('div');
                card.className = `module-card ${enabled ? 'enabled' : ''}`;
                card.id = `market-app-card-${item.id}`;
                const tags = Array.isArray(item.tags) ? item.tags.join(', ') : '';
                card.innerHTML = `
                    <div class="module-header">
                        <div style="display:flex; align-items:center;">
                            <span class="module-icon">üß∞</span>
                            <div class="module-name">${item.name || item.id}</div>
                        </div>
                        <label class="toggle">
                            <input type="checkbox" ${enabled ? 'checked' : ''} data-market-app="${item.id}">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="module-description">${item.description || ''}</div>
                    ${tags ? `<div class="module-meta">Tags: ${tags}</div>` : ''}
                `;

                const toggle = card.querySelector('input[type="checkbox"]');
                toggle.onchange = () => {
                    marketAppStates[item.id] = toggle.checked;
                    card.classList.toggle('enabled', toggle.checked);
                    updateValidation();
                };
                grid.appendChild(card);
            });
        }

        async function loadFromApi() {
            const isHttp = window.location.protocol.startsWith('http');
            if (!isHttp) {
                showPlatformError('Running from file:// - start the server and open http://localhost:5000');
                return false;
            }

            try {
                platforms = await apiFetchJson('/api/platforms');

                boards = {};
                for (const p of platforms) {
                    boards[p.id] = await apiFetchJson(`/api/boards/${p.id}`);
                }

                await refreshModulesForPlatform(selectedPlatform);
                modules.forEach(m => { if (!Array.isArray(m.pins)) m.pins = []; });

                try {
                    const tList = await apiFetchJson('/api/targets');
                    targets = {};
                    tList.forEach(t => { if (t && t.id) targets[t.id] = t; });
                } catch (err) {
                    console.warn('Failed to load targets:', err);
                    notify(`Targets API unavailable: ${err.message || err}`, 'warning');
                }

                try {
                    marketCatalog = await apiFetchJson(`/api/market/catalog?platform=${encodeURIComponent(selectedPlatform)}`);
                } catch (err) {
                    marketCatalog = [];
                    notify(`Market catalog unavailable: ${err.message || err}`, 'warning');
                }

                return true;
            } catch (err) {
                console.error('Failed to load from API:', err);
                showPlatformError(`Failed to load /api/platforms: ${err.message || err}`);
                return false;
            }
        }

        async function populatePlatformSelect() {
            const sel = document.getElementById('platform-select');
            sel.innerHTML = '';
            const errorEl = document.getElementById('platform-load-error');

            if (!platforms || platforms.length === 0) {
                try {
                    platforms = await apiFetchJson('/api/platforms');
                } catch (err) {
                    console.error('Failed to load platforms:', err);
                    if (errorEl) {
                        errorEl.style.display = 'block';
                        errorEl.textContent = `Failed to load platforms: ${err.message || err}`;
                    }
                }
            }

            if (!platforms || platforms.length === 0) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'No platforms loaded (check /api/platforms)';
                sel.appendChild(opt);
                sel.disabled = true;
                return;
            }

            sel.disabled = false;
            if (errorEl) errorEl.style.display = 'none';
            platforms.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = p.name || p.id;
                sel.appendChild(opt);
            });

            if (platforms.length > 0) {
                selectedPlatform = platforms[0].id;
                sel.value = selectedPlatform;
            }
        }

        async function refreshModulesForPlatform(platformId) {
            const url = platformId ? `/api/modules?platform=${platformId}` : '/api/modules';
            modules = await apiFetchJson(url);
            modules.forEach(m => { if (!Array.isArray(m.pins)) m.pins = []; });
        }

        async function refreshMarketCatalogForPlatform(platformId) {
            const url = platformId ? `/api/market/catalog?platform=${encodeURIComponent(platformId)}` : '/api/market/catalog';
            marketCatalog = await apiFetchJson(url);
            if (!Array.isArray(marketCatalog)) marketCatalog = [];
        }

        async function loadTemplates() {
            try {
                const data = await apiFetchJson('/api/templates');
                projectTemplates = data.templates || data;
            } catch (error) {
                console.warn('Using embedded templates, API unavailable.');
                projectTemplates = [];
            }

            if (projectTemplates.length === 0) {
                projectTemplates = [
                    {
                        id: 'display_app',
                        name: 'Display Application',
                        description: 'Basic TFT display application with console output and file storage',
                        icon: 'üñ•Ô∏è',
                        platforms: ['esp32'],
                        recommended_boards: ['cyd', 'm5stickc_plus2'],
                        enabled_modules: ['uart', 'spi', 'tft', 'fs_spiffs', 'shell_full'],
                        module_config: {},
                        tags: ['display', 'beginner', 'popular']
                    },
                    {
                        id: 'cyd_full_stack',
                        name: 'CYD Full Stack',
                        description: 'TFT console + SPIFFS + SD for the CYD display',
                        icon: 'üü®',
                        platforms: ['esp32'],
                        recommended_boards: ['cyd'],
                        enabled_modules: ['uart', 'spi', 'i2c', 'tft', 'fs_spiffs', 'fs_sd', 'shell_full'],
                        module_config: {},
                        tags: ['display', 'storage', 'popular']
                    },
                    {
                        id: 'iot_sensor',
                        name: 'IoT Sensor Hub',
                        description: 'WiFi-enabled sensor hub with I2C sensors and SD card data logging',
                        icon: 'üå°Ô∏è',
                        platforms: ['esp32'],
                        recommended_boards: ['esp32-devkitc_v4', 'cyd'],
                        enabled_modules: ['uart', 'i2c', 'wifi', 'fs_sd', 'shell_min'],
                        module_config: {},
                        tags: ['iot', 'sensors', 'wifi']
                    },
                    {
                        id: 'minimal_embedded',
                        name: 'Minimal System',
                        description: 'Bare minimum configuration for resource-constrained applications',
                        icon: '‚ö°',
                        platforms: ['esp32'],
                        recommended_boards: ['esp32-c3-supermini'],
                        enabled_modules: ['uart', 'shell_min'],
                        module_config: {},
                        tags: ['minimal', 'low-power', 'beginner']
                    },
                    {
                        id: 'mega2560_bringup',
                        name: 'Mega 2560 Bring-up',
                        description: 'GPIO + UART + Timer baseline for Arduino Mega 2560',
                        icon: 'üß∞',
                        platforms: ['avr'],
                        recommended_boards: ['mega2560'],
                        enabled_modules: ['gpio', 'uart', 'timer'],
                        module_config: { uart: { uart_num: 0, uart_baudrate: 115200 } },
                        tags: ['avr', 'baseline']
                    },
                    {
                        id: 'uno_minimal',
                        name: 'Uno Minimal',
                        description: 'ATmega328P minimal config (GPIO + UART)',
                        icon: 'üß±',
                        platforms: ['atmega'],
                        recommended_boards: ['arduino_uno_r3'],
                        enabled_modules: ['gpio', 'uart'],
                        module_config: { uart: { uart_num: 0, uart_baudrate: 115200 } },
                        tags: ['avr', 'minimal']
                    },
                    {
                        id: 'pico_sensors',
                        name: 'Pico Sensor Core',
                        description: 'RP2040 sensor-ready baseline (I2C + UART)',
                        icon: 'üß™',
                        platforms: ['rp2040'],
                        recommended_boards: ['raspberry_pi_pico'],
                        enabled_modules: ['gpio', 'uart', 'i2c', 'timer'],
                        module_config: {},
                        tags: ['rp2040', 'sensors']
                    },
                    {
                        id: 'nucleo_console',
                        name: 'Nucleo Console',
                        description: 'STM32 console + GPIO baseline',
                        icon: 'üß≠',
                        platforms: ['stm32'],
                        recommended_boards: ['nucleo_f401re'],
                        enabled_modules: ['gpio', 'uart', 'timer'],
                        module_config: {},
                        tags: ['stm32', 'baseline']
                    }
                ];
            }

            renderTemplateFilters();
            renderTemplates();
        }

        function renderTemplateFilters() {
            const allTags = new Set(['all']);
            projectTemplates.forEach(t => (t.tags || []).forEach(tag => allTags.add(tag)));

            const filterContainer = document.getElementById('template-filters');
            if (!filterContainer) return;

            filterContainer.innerHTML = Array.from(allTags).map(tag => `
                <span class="filter-tag ${tag === 'all' ? 'active' : ''}"
                      onclick="selectTemplateFilter('${tag}')">
                    ${tag.charAt(0).toUpperCase() + tag.slice(1)}
                </span>
            `).join('');
        }

        function selectTemplateFilter(tag) {
            document.querySelectorAll('.filter-tag').forEach(el => {
                el.classList.toggle('active', el.textContent.toLowerCase() === tag);
            });
            renderTemplates(tag);
        }

        function renderTemplates(filterTag = 'all') {
            const container = document.getElementById('templates-grid');
            if (!container) return;

            let filtered = projectTemplates;
            if (filterTag !== 'all') {
                filtered = projectTemplates.filter(t => t.tags && t.tags.includes(filterTag));
            }
            if (selectedPlatform && selectedPlatform !== 'all') {
                filtered = filtered.filter(t => t.platforms && t.platforms.includes(selectedPlatform));
            }

            container.innerHTML = filtered.map(template => `
                <div class="template-card ${template.tags?.includes('popular') ? 'popular' : ''}"
                     onclick="showTemplatePreview('${template.id}')">
                    <span class="template-icon">${template.icon || 'üì¶'}</span>
                    <h4>${template.name}</h4>
                    <p>${template.description}</p>
                    <div class="template-modules">
                        <strong>Modules:</strong>
                        ${template.enabled_modules.slice(0, 3).join(', ')}
                        ${template.enabled_modules.length > 3 ? ` +${template.enabled_modules.length - 3} more` : ''}
                    </div>
                    ${Array.isArray(template.applets) && template.applets.length > 0 ? `
                        <div class="template-modules">
                            <strong>Starter Apps:</strong> ${template.applets.length}
                        </div>
                    ` : ''}
                    <div class="template-tags">
                        ${(template.tags || []).map(tag =>
                            `<span class="template-tag">${tag}</span>`
                        ).join('')}
                    </div>
                    <div class="template-quick-actions" onclick="event.stopPropagation()">
                        <button class="btn-template btn-template-preview"
                                onclick="showTemplatePreview('${template.id}')">
                            Preview
                        </button>
                        <button class="btn-template btn-template-use"
                                onclick="applyTemplate('${template.id}')">
                            Use Template
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function showTemplatePreview(templateId) {
            const template = projectTemplates.find(t => t.id === templateId);
            if (!template) return;

            const modal = document.getElementById('template-modal');
            const content = document.getElementById('template-modal-body');

            content.innerHTML = `
                <div class="template-modal-header">
                    <div>
                        <h2>${template.icon || 'üì¶'} ${template.name}</h2>
                        <p style="color: #718096; margin-top: 5px;">${template.description}</p>
                    </div>
                    <span class="template-modal-close" onclick="closeTemplateModal()">√ó</span>
                </div>

                <div style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">Enabled Modules (${template.enabled_modules.length})</h3>
                    <div class="module-badges" style="margin-bottom: 20px;">
                        ${template.enabled_modules.map(m =>
                            `<span class="badge badge-provides">${m}</span>`
                        ).join('')}
                    </div>

                    <h3 style="margin-bottom: 10px;">Recommended Boards</h3>
                    <div class="module-badges" style="margin-bottom: 20px;">
                        ${(template.recommended_boards || []).map(b =>
                            `<span class="badge badge-platform">${b}</span>`
                        ).join('')}
                    </div>

                    ${Array.isArray(template.applets) && template.applets.length > 0 ? `
                        <h3 style="margin-bottom: 10px;">Starter Apps (${template.applets.length})</h3>
                        <div class="module-badges" style="margin-bottom: 20px;">
                            ${template.applets.map(a =>
                                `<span class="badge badge-platform">${a}</span>`
                            ).join('')}
                        </div>
                    ` : ''}

                    ${Object.keys(template.module_config || {}).length > 0 ? `
                        <h3 style="margin-bottom: 10px;">Module Configuration</h3>
                        <pre style="background: #f7fafc; padding: 15px; border-radius: 6px; overflow-x: auto;">
${JSON.stringify(template.module_config, null, 2)}</pre>
                    ` : ''}

                    <div style="margin-top: 30px; display: flex; gap: 15px;">
                        <button class="btn btn-secondary" onclick="closeTemplateModal()">
                            Cancel
                        </button>
                        <button class="btn btn-success" onclick="applyTemplate('${template.id}'); closeTemplateModal();">
                            Apply Template
                        </button>
                    </div>
                </div>
            `;

            modal.classList.add('active');
        }

        function closeTemplateModal() {
            document.getElementById('template-modal').classList.remove('active');
        }

        function applyTemplate(templateId) {
            const template = projectTemplates.find(t => t.id === templateId);
            if (!template) return;

            modules.forEach(module => {
                const shouldEnable = template.enabled_modules.includes(module.id);
                module.enabled = shouldEnable;
                moduleStates[module.id] = shouldEnable;
            });

            if (template.module_config) {
                Object.entries(template.module_config).forEach(([moduleId, config]) => {
                    moduleConfigs[moduleId] = { ...(moduleConfigs[moduleId] || {}), ...config };
                });
            }

            if (Array.isArray(template.applets)) {
                const available = new Set(availableAppletsForBoard(selectedBoard));
                Object.keys(appletStates).forEach(k => { appletStates[k] = false; });
                template.applets.forEach(a => {
                    if (available.has(a)) appletStates[a] = true;
                });
            }

            if (Array.isArray(template.market_apps)) {
                const available = new Set(availableMarketAppsForBoard(selectedBoard).map(x => x.id));
                Object.keys(marketAppStates).forEach(k => { marketAppStates[k] = false; });
                template.market_apps.forEach(a => {
                    if (available.has(a)) marketAppStates[a] = true;
                });
            }

            populateModuleGrid();
            populateAppletGrid();
            populateMarketAppGrid();
            updateValidation();
        }

        function renderModuleOptions(module) {
            if (!module.configuration_options) return '';

            return module.configuration_options.map(option => {
                const value = moduleConfigs[module.id]?.[option.id] ?? option.default;

                if (option.type === 'select') {
                    return `
                        <div class="option-field">
                            <label>${option.name}</label>
                            <select data-module="${module.id}" data-option="${option.id}">
                                ${option.options.map(opt =>
                                    `<option value="${opt}" ${String(opt) === String(value) ? 'selected' : ''}>${opt}</option>`
                                ).join('')}
                            </select>
                        </div>
                    `;
                }
                if (option.type === 'number') {
                    return `
                        <div class="option-field">
                            <label>${option.name}</label>
                            <input type="number"
                                   value="${value}"
                                   min="${option.min ?? ''}"
                                   max="${option.max ?? ''}"
                                   data-module="${module.id}"
                                   data-option="${option.id}">
                        </div>
                    `;
                }
                if (option.type === 'text') {
                    return `
                        <div class="option-field">
                            <label>${option.name}</label>
                            <input type="text"
                                   value="${value}"
                                   data-module="${module.id}"
                                   data-option="${option.id}">
                        </div>
                    `;
                }
                return '';
            }).join('');
        }

        function toggleModuleOptions(moduleId, buttonEl) {
            const optionsPanel = document.getElementById(`options-${moduleId}`);
            const btn = buttonEl;
            if (!optionsPanel || !btn) return;

            if (optionsPanel.classList.contains('active')) {
                optionsPanel.classList.remove('active');
                btn.classList.remove('active');
                btn.textContent = '‚öôÔ∏è Configure';
            } else {
                optionsPanel.classList.add('active');
                btn.classList.add('active');
                btn.textContent = '‚öôÔ∏è Hide Config';
            }
        }

        function wireModuleOptionInputs(container) {
            container.querySelectorAll('.module-options input, .module-options select').forEach(el => {
                el.addEventListener('change', () => {
                    const moduleId = el.dataset.module;
                    const optionId = el.dataset.option;
                    if (!moduleId || !optionId) return;
                    if (!moduleConfigs[moduleId]) moduleConfigs[moduleId] = {};
                    const raw = el.value;
                    const num = Number(raw);
                    moduleConfigs[moduleId][optionId] = Number.isFinite(num) && String(raw) === String(num) ? num : raw;
                    updateValidation();
                });
            });
        }

        function collectModuleConfigFromUI() {
            document.querySelectorAll('.module-options input, .module-options select').forEach(el => {
                const moduleId = el.dataset.module;
                const optionId = el.dataset.option;
                if (!moduleId || !optionId) return;
                if (!moduleConfigs[moduleId]) moduleConfigs[moduleId] = {};
                const raw = el.value;
                const num = Number(raw);
                moduleConfigs[moduleId][optionId] = Number.isFinite(num) && String(raw) === String(num) ? num : raw;
            });
            return moduleConfigs;
        }

        function handleModuleToggle(moduleId, enabled) {
            const module = modules.find(m => m.id === moduleId);
            if (!module) return;

            module.enabled = enabled;
            moduleStates[moduleId] = enabled;

            const card = document.getElementById(`module-card-${moduleId}`);
            if (card) card.classList.toggle('enabled', enabled);

            if (enabled) {
                const depends = Array.isArray(module.depends) ? module.depends : [];
                depends.forEach(depId => {
                    const depModule = modules.find(m => m.id === depId);
                    if (depModule && !depModule.enabled) {
                        depModule.enabled = true;
                        moduleStates[depId] = true;

                        const depCard = document.getElementById(`module-card-${depId}`);
                        if (depCard) {
                            depCard.classList.add('enabled');
                            const checkbox = depCard.querySelector('input[type="checkbox"]');
                            if (checkbox) checkbox.checked = true;
                        }
                    }
                });

                const conflicts = Array.isArray(module.conflicts) ? module.conflicts : [];
                conflicts.forEach(conflictId => {
                    const conflictModule = modules.find(m => m.id === conflictId);
                    if (conflictModule && conflictModule.enabled) {
                        showWarning(`Module "${module.name}" conflicts with "${conflictModule.name}".`);
                    }
                });
            }

            refreshModuleSectionCounts();
            updateValidation();
        }

        function syncModuleStatesFromUI() {
            document.querySelectorAll('#module-grid input[type="checkbox"][data-module]').forEach(input => {
                const moduleId = input.dataset.module;
                const module = modules.find(m => m.id === moduleId);
                if (module) module.enabled = input.checked;
            });
        }

        function signalIoType(signal) {
            const pinDef = selectedBoard?.pin_definitions?.[signal];
            if (pinDef && typeof pinDef === 'object') {
                const t = String(pinDef.type || '').toLowerCase();
                if (t === 'input' || t === 'output' || t === 'bidirectional') return t;
            }
            const s = String(signal || '').toLowerCase();
            const outputSuffixes = ['_tx', '_mosi', '_sclk', '_clk', '_sck', '_cs', '_dc', '_rst', '_bl', '_led', '_pwm'];
            const inputSuffixes = ['_rx', '_miso', '_irq', '_int', '_button'];
            if (outputSuffixes.some(x => s.endsWith(x))) return 'output';
            if (inputSuffixes.some(x => s.endsWith(x))) return 'input';
            return 'bidirectional';
        }

        function spiShareKind(signal) {
            const s = String(signal || '').toLowerCase();
            if (s.endsWith('_mosi')) return 'mosi';
            if (s.endsWith('_miso')) return 'miso';
            if (s.endsWith('_sclk') || s.endsWith('_clk') || s.endsWith('_sck')) return 'sclk';
            return null;
        }

        function checkPinConflicts() {
            const pinUsage = {};
            const errors = [];
            const warnings = [];
            const platform = String(selectedBoard?.platform || selectedPlatform || '').toLowerCase();

            document.querySelectorAll('.pin-input').forEach(input => {
                const raw = (input.value || '').trim();
                const signal = input.dataset.pin;

                input.classList.remove('conflict', 'valid');
                const oldStatus = input.nextElementSibling;
                if (oldStatus && oldStatus.classList.contains('pin-status')) {
                    oldStatus.remove();
                }

                if (!raw) return;

                let key;
                if (/^-?\d+$/.test(raw)) {
                    const pinNum = parseInt(raw, 10);
                    if (Number.isNaN(pinNum) || pinNum < 0) return;
                    key = pinNum;
                } else {
                    key = raw;
                }

                if (typeof key === 'number' && platform === 'esp32') {
                    if (key > 39) {
                        errors.push({ pin: key, signals: [signal], reason: `GPIO${key} is out of range for ESP32 (0-39)` });
                    } else if (key >= 6 && key <= 11) {
                        errors.push({ pin: key, signals: [signal], reason: `GPIO${key} is reserved for SPI flash` });
                    }
                    const ioType = signalIoType(signal);
                    if ((ioType === 'output' || ioType === 'bidirectional') && key >= 34 && key <= 39) {
                        errors.push({ pin: key, signals: [signal], reason: `GPIO${key} is input-only on ESP32` });
                    }
                    if ([0, 2, 4, 5, 12, 15].includes(key)) {
                        warnings.push({ pin: key, signals: [signal], reason: `GPIO${key} is a strapping pin; use with caution` });
                    }
                }

                if (!pinUsage[key]) pinUsage[key] = [];
                if (!pinUsage[key].includes(signal)) pinUsage[key].push(signal);
            });

            Object.entries(pinUsage).forEach(([pin, signals]) => {
                if (signals.length <= 1) return;
                const kinds = signals.map(spiShareKind);
                const shareableSpi = kinds.every(k => k !== null) && (new Set(kinds)).size === 1;
                if (!shareableSpi) {
                    errors.push({
                        pin,
                        signals,
                        reason: `Pin ${pin} is assigned to ${signals.join(' and ')}`
                    });
                }
            });

            const conflictSignals = new Set();
            errors.forEach(e => {
                (e.signals || []).forEach(s => conflictSignals.add(s));
            });
            document.querySelectorAll('.pin-input').forEach(input => {
                const signal = input.dataset.pin;
                const status = document.createElement('span');
                if (conflictSignals.has(signal)) {
                    input.classList.add('conflict');
                    status.className = 'pin-status error';
                    status.textContent = '‚ùå';
                    status.title = 'Pin assignment issue';
                } else {
                    input.classList.add('valid');
                    status.className = 'pin-status ok';
                    status.textContent = '‚úì';
                    status.title = 'Pin assignment looks valid';
                }
                input.after(status);
            });

            const pinPanel = document.getElementById('pin-validation');
            if (pinPanel) {
                if (errors.length === 0 && warnings.length === 0) {
                    pinPanel.innerHTML = `
                        <div class="validation-item info">
                            <span class="validation-icon">‚úÖ</span>
                            <div>No pin conflicts detected.</div>
                        </div>
                    `;
                } else {
                    const errorHtml = errors.map(conflict => `
                        <div class="validation-item error">
                            <span class="validation-icon">‚ùå</span>
                            <div>${conflict.reason}</div>
                        </div>
                    `).join('');
                    const warnHtml = warnings.map(warn => `
                        <div class="validation-item warning">
                            <span class="validation-icon">‚ö†Ô∏è</span>
                            <div>${warn.reason}</div>
                        </div>
                    `).join('');
                    pinPanel.innerHTML = `${errorHtml}${warnHtml}`;
                }
            }

            return { errors, warnings };
        }

        function updateValidation() {
            const validationPanel = document.getElementById('validation-warnings');
            if (!validationPanel) return;

            const issues = buildValidationIssues({ includePins: true });

            if (issues.length === 0) {
                validationPanel.innerHTML = `
                    <div class="validation-item info">
                        <span class="validation-icon">‚úÖ</span>
                        <div>Configuration is valid!</div>
                    </div>
                `;
            } else {
                validationPanel.innerHTML = issues.map(issue => `
                    <div class="validation-item ${issue.type}">
                        <span class="validation-icon">
                            ${issue.type === 'error' ? '‚ùå' : issue.type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'}
                        </span>
                        <div>${issue.message}</div>
                    </div>
                `).join('');
            }
        }

        function showWarning(message) {
            console.warn(message);
            notify(message, 'warning');
        }

        function initModuleFilters() {
            const searchInput = document.getElementById('module-search');
            const showEnabledOnly = document.getElementById('show-enabled-only');

            function filterModules() {
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
                const enabledOnly = showEnabledOnly ? showEnabledOnly.checked : false;

                document.querySelectorAll('.module-card').forEach(card => {
                    const moduleId = card.id.replace('module-card-', '');
                    const module = modules.find(m => m.id === moduleId);
                    if (!module) return;

                    let show = true;

                    if (searchTerm) {
                        const matchesSearch =
                            (module.name || '').toLowerCase().includes(searchTerm) ||
                            (module.description || '').toLowerCase().includes(searchTerm) ||
                            module.id.toLowerCase().includes(searchTerm);
                        if (!matchesSearch) show = false;
                    }

                    if (enabledOnly && !module.enabled) {
                        show = false;
                    }

                    card.style.display = show ? 'block' : 'none';
                });

                document.querySelectorAll('.module-section').forEach(section => {
                    const visible = Array.from(section.querySelectorAll('.module-card'))
                        .some(card => card.style.display !== 'none');
                    section.style.display = visible ? 'block' : 'none';
                });
            }

            if (searchInput) searchInput.oninput = filterModules;
            if (showEnabledOnly) showEnabledOnly.onchange = filterModules;
            filterModules();
        }

        function setAllModuleSections(open) {
            document.querySelectorAll('.module-section').forEach(section => {
                section.open = open;
                const key = section.dataset.group;
                if (key) moduleSectionState[key] = open;
            });
        }

        function refreshModuleSectionCounts() {
            document.querySelectorAll('.module-section').forEach(section => {
                const cards = Array.from(section.querySelectorAll('.module-card'));
                const enabled = cards.filter(card => card.classList.contains('enabled')).length;
                const badge = section.querySelector('.module-section-count');
                if (badge) badge.textContent = `${enabled}/${cards.length} enabled`;
            });
        }
        

        // State
        let currentStep = 1;
        let selectedPlatform = 'esp32';
        let selectedBoard = null;
        let moduleStates = {};

        // Initialize
        async function init() {
            loadUserProfile();
            const ok = await loadFromApi();
            await populatePlatformSelect();
            if (!ok || !platforms || platforms.length === 0) {
                showPlatformError('No platforms loaded. Check http://localhost:5000/api/platforms');
            }
            renderProfilePanel();
            populateBoardList();
            populateModuleGrid();
            loadTemplates();
            updateLandingStats();
            showLanding();
            renderMarketPage();
            renderSelectedAppsVisibility();
            attachEventListeners();
            const flasherBtn = document.getElementById('btn-refresh-flasher');
            if (flasherBtn) {
                flasherBtn.addEventListener('click', () => refreshWebFlasher());
            }
            const releaseBtn = document.getElementById('btn-release-serial');
            if (releaseBtn) {
                releaseBtn.addEventListener('click', () => releaseBrowserSerialPorts());
            }
            const localFlashBtn = document.getElementById('btn-local-flash');
            if (localFlashBtn) {
                localFlashBtn.addEventListener('click', () => localFlashEsp32());
            }
            notify('Welcome to BasaltOS Configurator.', 'success', 1800);
        }

        function populateBoardList() {
            const boardList = document.getElementById('board-list');
            boardList.innerHTML = '';

            const ownedOnly = !!document.getElementById('owned-only-toggle')?.checked;
            const ownedSet = new Set((userProfile.ownedBoards || []).map(String));
            const platformBoards = (boards[selectedPlatform] || []).filter(board => {
                return !ownedOnly || ownedSet.has(String(board.id));
            });

            if (!platformBoards.length) {
                boardList.innerHTML = '<li class="board-empty">No boards match your current filter.</li>';
                return;
            }

            const groups = {};
            platformBoards.forEach(board => {
                const group = boardGroupLabel(board);
                if (!groups[group]) groups[group] = [];
                groups[group].push(board);
            });

            Object.keys(groups).sort().forEach(groupName => {
                const groupWrap = document.createElement('li');
                groupWrap.className = 'board-group';

                const title = document.createElement('div');
                title.className = 'board-group-title';
                title.textContent = `${groupName} (${groups[groupName].length})`;
                groupWrap.appendChild(title);

                groups[groupName].sort((a, b) => String(a.name).localeCompare(String(b.name))).forEach(board => {
                    const li = document.createElement('div');
                    li.className = 'board-item';
                    li.textContent = board.name;
                    li.dataset.boardId = board.id;
                    if (selectedBoard && String(selectedBoard.id) === String(board.id)) {
                        li.classList.add('selected');
                    }
                    li.onclick = () => selectBoard(board, li);
                    groupWrap.appendChild(li);
                });

                boardList.appendChild(groupWrap);
            });
        }

        function selectBoard(board, sourceEl) {
            selectedBoard = board;
            
            // Update UI
            document.querySelectorAll('.board-item').forEach(item => {
                item.classList.remove('selected');
            });
            if (sourceEl) sourceEl.classList.add('selected');
            
            // Show board details
            document.getElementById('board-details').style.display = 'block';
            document.getElementById('board-name').textContent = board.name;
            document.getElementById('board-description').textContent = board.description;
            document.getElementById('spec-mcu').textContent = board.mcu;
            document.getElementById('spec-flash').textContent = board.flash;
            document.getElementById('spec-ram').textContent = board.ram;
            document.getElementById('spec-display').textContent = board.display;
            const targetId = board.target_profile;
            const targetName = targetId && targets[targetId] ? targets[targetId].name : (targetId || '‚Äî');
            document.getElementById('spec-target').textContent = targetName;
            
            // Auto-enable modules based on board capabilities
            if (board.defaults && Array.isArray(board.defaults.modules)) {
                modules.forEach(m => { m.enabled = false; });
                board.defaults.modules.forEach(id => {
                    const mod = modules.find(m => m.id === id);
                    if (mod) mod.enabled = true;
                });
            } else {
                autoEnableByBoardCapabilities(board);
            }
            
            const availableApplets = availableAppletsForBoard(board);
            appletStates = {};
            if (board.defaults && Array.isArray(board.defaults.applets)) {
                board.defaults.applets.forEach(id => { appletStates[id] = true; });
            } else {
                availableApplets.forEach(id => { appletStates[id] = false; });
            }

            const availableMarket = availableMarketAppsForBoard(board);
            marketAppStates = {};
            if (board.defaults && Array.isArray(board.defaults.market_apps)) {
                board.defaults.market_apps.forEach(id => { marketAppStates[id] = true; });
            } else {
                availableMarket.forEach(item => { marketAppStates[item.id] = false; });
            }

            populateModuleGrid();
            populateAppletGrid();
            populateMarketAppGrid();
            renderSelectedAppsVisibility();
            renderMarketPage();
            clearInlineOutput();
            refreshWebFlasher({ silent: true });
        }

        function autoEnableByBoardCapabilities(board) {
            const caps = new Set(board.capabilities || []);
            const enable = (id) => {
                const mod = modules.find(m => m.id === id);
                if (mod) mod.enabled = true;
            };
            if (caps.has('spi')) enable('spi');
            if (caps.has('uart')) enable('uart');
            if (caps.has('tft')) enable('tft');
            // Default to SPIFFS for internal storage
            enable('fs_spiffs');
            if (caps.has('psram')) enable('psram');
            if (caps.has('uart')) enable('shell_full');
        }

        function moduleAllowed(module, caps) {
            if (module.platforms && !module.platforms.includes(selectedPlatform)) return false;
            const targetId = selectedBoard?.target_profile;
            const target = targetId ? targets[targetId] : null;
            const policy = target?.module_policy;
            if (policy && policy.mode === 'allowlist' && Array.isArray(policy.allowed)) {
                if (!policy.allowed.includes(module.id)) return false;
            }
            if (policy && policy.mode === 'denylist' && Array.isArray(policy.denied)) {
                if (policy.denied.includes(module.id)) return false;
            }
            if (caps.size === 0) return true;
            if (caps.has(module.id)) return true;
            if (module.id.startsWith('shell_')) return caps.has('uart');
            if (module.id === 'fs_spiffs') return true; // internal storage
            if (module.id === 'fs_sd') return caps.has('sd_card');
            if (module.id === 'psram') return caps.has('psram');
            return caps.has(module.id.replace('fs_', ''));
        }

        function populateModuleGrid() {
            const grid = document.getElementById('module-grid');
            grid.innerHTML = '';

            const caps = new Set(selectedBoard?.capabilities || []);
            const sectionOrder = ['core', 'connectivity', 'storage', 'ui_shell', 'advanced'];
            const groupedCards = {};
            sectionOrder.forEach(s => { groupedCards[s] = []; });

            modules.forEach(module => {
                const enabled = !!module.enabled;
                moduleStates[module.id] = enabled;

                const allowed = moduleAllowed(module, caps);

                const card = document.createElement('div');
                card.className = `module-card ${enabled ? 'enabled' : ''}`;
                card.id = `module-card-${module.id}`;
                if (!allowed) card.classList.add('disabled');
                const hasOptions = module.configuration_options && module.configuration_options.length > 0;
                const depends = Array.isArray(module.depends) ? module.depends : [];
                const provides = Array.isArray(module.provides) ? module.provides : [];
                const conflicts = Array.isArray(module.conflicts) ? module.conflicts : [];
                card.innerHTML = `
                    <div class="module-header">
                        <div style="display:flex; align-items:center;">
                            <span class="module-icon">${getModuleIcon(module.id)}</span>
                        <div class="module-name">${module.name}</div>
                        </div>
                        <label class="toggle">
                            <input type="checkbox" ${enabled ? 'checked' : ''} data-module="${module.id}" ${allowed ? '' : 'disabled'}>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="module-description">${module.description || ""}</div>
                    <div class="module-badges">
                        ${depends.length ? `<span class="badge badge-dep">Requires: ${depends.join(', ')}</span>` : ''}
                        ${provides.length ? `<span class="badge badge-provides">Provides: ${provides.join(', ')}</span>` : ''}
                        ${conflicts.length ? `<span class="badge badge-conflict">Conflicts: ${conflicts.join(', ')}</span>` : ''}
                    </div>
                    ${(module.pins && module.pins.length > 0) ? `<div class="module-pins">üìå ${module.pins.length} pins required</div>` : ''}
                    ${hasOptions ? `
                        <button class="btn-config" data-module="${module.id}">‚öôÔ∏è Configure</button>
                        <div class="module-options" id="options-${module.id}">
                            ${renderModuleOptions(module)}
                        </div>
                    ` : ''}
                `;

                const toggle = card.querySelector('input[type="checkbox"]');
                if (allowed) {
                    toggle.onchange = () => handleModuleToggle(module.id, toggle.checked);
                }

                const configBtn = card.querySelector('.btn-config');
                if (configBtn) {
                    configBtn.onclick = () => toggleModuleOptions(module.id, configBtn);
                }

                wireModuleOptionInputs(card);
                const section = moduleSectionFor(module.id);
                if (!groupedCards[section]) groupedCards[section] = [];
                groupedCards[section].push({ card, enabled });
            });

            sectionOrder.forEach(sectionId => {
                const cards = groupedCards[sectionId] || [];
                if (cards.length === 0) return;
                const enabledCount = cards.filter(c => c.enabled).length;
                const details = document.createElement('details');
                details.className = 'module-section';
                details.dataset.group = sectionId;
                details.open = moduleSectionState[sectionId] !== false;
                details.innerHTML = `
                    <summary>
                        <span>${moduleSectionLabel(sectionId)}</span>
                        <span class="module-section-count">${enabledCount}/${cards.length} enabled</span>
                    </summary>
                `;
                details.addEventListener('toggle', () => {
                    moduleSectionState[sectionId] = details.open;
                });

                const sub = document.createElement('div');
                sub.className = 'module-grid module-subgrid';
                cards.forEach(c => sub.appendChild(c.card));
                details.appendChild(sub);
                grid.appendChild(details);
            });

            initModuleFilters();
            refreshModuleSectionCounts();
            updateValidation();
        }

        function populatePinTable() {
            const tbody = document.getElementById('pin-table-body');
            tbody.innerHTML = '';

            const boardPins = selectedBoard ? (selectedBoard.pins || {}) : {};
            const getModulePinSignals = (module) => {
                const signals = new Set();
                if (Array.isArray(module.pins) && module.pins.length > 0) {
                    module.pins.forEach(p => signals.add(p));
                }
                if (module.pin_requirements && typeof module.pin_requirements === 'object') {
                    Object.keys(module.pin_requirements).forEach(p => signals.add(p));
                }
                const prefixes = new Set();
                if (module.id) prefixes.add(`${module.id}_`);
                if (module.id && module.id.startsWith('fs_')) {
                    prefixes.add(`${module.id.replace('fs_', '')}_`);
                }
                if (module.id === 'fs_sd') prefixes.add('sd_');
                if (module.id === 'i2c') prefixes.add('i2c_');
                if (module.id === 'spi') prefixes.add('spi_');
                if (module.id === 'uart') prefixes.add('uart_');
                if (module.id === 'uart') {
                    prefixes.add('uart0_');
                    prefixes.add('uart1_');
                    prefixes.add('uart2_');
                    prefixes.add('uart3_');
                }
                if (module.id === 'tft') prefixes.add('tft_');
                if (module.id === 'touch') prefixes.add('touch_');
                if (Array.isArray(module.provides)) {
                    module.provides.forEach(p => prefixes.add(`${p}_`));
                }
                if (Array.isArray(module.depends)) {
                    module.depends.forEach(p => prefixes.add(`${p}_`));
                }
                Object.keys(boardPins).forEach(key => {
                    prefixes.forEach(prefix => {
                        if (key.startsWith(prefix)) signals.add(key);
                    });
                });
                return Array.from(signals);
            };

            const enabledModules = modules.filter(m => m.enabled);
            const enabledWithPins = enabledModules.filter(m => Array.isArray(m.pins) && m.pins.length > 0);
            const enabledDerived = enabledModules
                .filter(m => !Array.isArray(m.pins) || m.pins.length === 0)
                .map(m => ({ module: m, pins: getModulePinSignals(m) }))
                .filter(x => x.pins.length > 0);

            if (enabledWithPins.length === 0 && enabledDerived.length === 0 && selectedBoard) {
                const pinDefs = selectedBoard.pin_definitions || {};
                const pins = selectedBoard.pins || {};
                const entries = Object.keys(pinDefs).length > 0
                    ? Object.entries(pinDefs)
                    : Object.entries(pins).map(([k]) => [k, {}]);

                entries.forEach(([pin, def]) => {
                    const tr = document.createElement('tr');
                    const defaultPin = selectedBoard.pins && selectedBoard.pins[pin] !== undefined
                        ? selectedBoard.pins[pin]
                        : -1;
                    const alternatives = def.alternatives ? def.alternatives.join(', ') : '';
                    const isNumeric = typeof defaultPin === 'number' && Number.isFinite(defaultPin);
                    tr.innerHTML = `
                        <td>board</td>
                        <td>${pin.toUpperCase()}</td>
                        <td><input type="${isNumeric ? 'number' : 'text'}" class="pin-input" value="${defaultPin}" data-pin="${pin}" data-pin-type="${isNumeric ? 'number' : 'text'}" ${isNumeric ? 'min="-1" max="40"' : ''}></td>
                        <td>${alternatives}</td>
                    `;
                    tbody.appendChild(tr);
                });
                checkPinConflicts();
                return;
            }

            enabledWithPins.forEach(module => {
                module.pins.forEach(pin => {
                    const tr = document.createElement('tr');
                    const defaultPin = selectedBoard && selectedBoard.pins[pin] !== undefined 
                        ? selectedBoard.pins[pin] 
                        : -1;
                    const pinDef = selectedBoard?.pin_definitions?.[pin] || {};
                    const altPins = Array.isArray(pinDef.alternatives) ? pinDef.alternatives : [];
                    const isNumeric = typeof defaultPin === 'number' && Number.isFinite(defaultPin);
                    
                    tr.innerHTML = `
                        <td>${module.name}</td>
                        <td>${pin.toUpperCase()}</td>
                        <td><input type="${isNumeric ? 'number' : 'text'}" class="pin-input" value="${defaultPin}" data-pin="${pin}" data-pin-type="${isNumeric ? 'number' : 'text'}" ${isNumeric ? 'min="-1" max="40"' : ''}></td>
                        <td>
                            <select class="pin-alt" data-pin="${pin}">
                                <option value="${defaultPin}">Default</option>
                                ${altPins.map(p => `<option value="${p}">${p}</option>`).join('')}
                                <option value="-1">Disabled</option>
                            </select>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });

                if (module.id === 'uart') {
                    const extraPins = getModulePinSignals(module).filter(p => !module.pins.includes(p));
                    extraPins.forEach(pin => {
                        const tr = document.createElement('tr');
                        const defaultPin = selectedBoard && selectedBoard.pins[pin] !== undefined
                            ? selectedBoard.pins[pin]
                            : -1;
                        const pinDef = selectedBoard?.pin_definitions?.[pin] || {};
                        const altPins = Array.isArray(pinDef.alternatives) ? pinDef.alternatives : [];
                        const isNumeric = typeof defaultPin === 'number' && Number.isFinite(defaultPin);
                        tr.innerHTML = `
                            <td>${module.name}</td>
                            <td>${pin.toUpperCase()}</td>
                            <td><input type="${isNumeric ? 'number' : 'text'}" class="pin-input" value="${defaultPin}" data-pin="${pin}" data-pin-type="${isNumeric ? 'number' : 'text'}" ${isNumeric ? 'min="-1" max="40"' : ''}></td>
                            <td>
                                <select class="pin-alt" data-pin="${pin}">
                                    <option value="${defaultPin}">Default</option>
                                    ${altPins.map(p => `<option value="${p}">${p}</option>`).join('')}
                                    <option value="-1">Disabled</option>
                                </select>
                            </td>
                        `;
                        tbody.appendChild(tr);
                    });
                }
            });

            enabledDerived.forEach(({ module, pins }) => {
                pins.forEach(pin => {
                    const tr = document.createElement('tr');
                    const defaultPin = selectedBoard && selectedBoard.pins[pin] !== undefined
                        ? selectedBoard.pins[pin]
                        : -1;
                    const pinDef = selectedBoard?.pin_definitions?.[pin] || {};
                    const altPins = Array.isArray(pinDef.alternatives) ? pinDef.alternatives : [];
                    const isNumeric = typeof defaultPin === 'number' && Number.isFinite(defaultPin);
                    tr.innerHTML = `
                        <td>${module.name}</td>
                        <td>${pin.toUpperCase()}</td>
                        <td><input type="${isNumeric ? 'number' : 'text'}" class="pin-input" value="${defaultPin}" data-pin="${pin}" data-pin-type="${isNumeric ? 'number' : 'text'}" ${isNumeric ? 'min="-1" max="40"' : ''}></td>
                        <td>
                            <select class="pin-alt" data-pin="${pin}">
                                <option value="${defaultPin}">Default</option>
                                ${altPins.map(p => `<option value="${p}">${p}</option>`).join('')}
                                <option value="-1">Disabled</option>
                            </select>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            });

            tbody.querySelectorAll('.pin-alt').forEach(select => {
                select.addEventListener('change', () => {
                    const pin = select.dataset.pin;
                    const input = tbody.querySelector(`.pin-input[data-pin="${pin}"]`);
                    if (input) {
                        input.value = select.value;
                        checkPinConflicts();
                    }
                });
            });

            tbody.querySelectorAll('.pin-input').forEach(input => {
                input.addEventListener('change', () => {
                    checkPinConflicts();
                });
            });

            checkPinConflicts();
        }

        async function generateConfigPreview() {
            const previewEl = document.getElementById('config-preview');
            renderValidationReport();

            // Summary
            const summary = document.getElementById('config-summary');
            summary.innerHTML = `
                <div class="board-specs">
                    <div class="spec-item">
                        <div class="spec-label">Board</div>
                        <div class="spec-value">${selectedBoard ? selectedBoard.name : 'None'}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Platform</div>
                        <div class="spec-value">${selectedPlatform.toUpperCase()}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Target</div>
                        <div class="spec-value">${selectedBoard?.target_profile || '‚Äî'}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Modules Enabled</div>
                        <div class="spec-value">${modules.filter(m => m.enabled).length}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Starter Apps Enabled</div>
                        <div class="spec-value">${applets.filter(a => appletStates[a]).length}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Market Apps</div>
                        <div class="spec-value">${marketApps.filter(a => marketAppStates[a]).length}</div>
                    </div>
                </div>
            `;

            const isHttp = window.location.protocol.startsWith('http');
            if (!isHttp || !selectedBoard) {
                previewEl.textContent = 'Select a board to preview configuration.';
                return;
            }

            const enabled_modules = modules.filter(m => m.enabled).map(m => m.id);
            const module_config = collectModuleConfigFromUI();
            const enabled_applets = applets.filter(a => appletStates[a]);
            const selected_market_apps = marketApps.filter(a => marketAppStates[a]);
            const custom_pins = {};
            document.querySelectorAll('#pin-table-body input[data-pin]').forEach(input => {
                const key = input.dataset.pin;
                const raw = (input.value || '').trim();
                if (!raw) return;
                if (input.dataset.pinType === 'number') {
                    const val = parseInt(raw, 10);
                    if (!Number.isNaN(val)) custom_pins[key] = val;
                } else {
                    custom_pins[key] = raw;
                }
            });

            try {
                const data = await apiFetchJson('/api/preview/basalt_config_h', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        platform: selectedPlatform,
                        board_id: selectedBoard.id,
                        target_profile: selectedBoard.target_profile || null,
                        enabled_modules,
                        applets: enabled_applets,
                        market_apps: selected_market_apps,
                        module_config,
                        custom_pins
                    })
                });
                if (!data.success) throw new Error(data.error || 'Preview failed');
                previewEl.textContent = data.content;
            } catch (err) {
                previewEl.textContent = `Preview failed: ${err.message || err}`;
                notify(`Preview failed: ${err.message || err}`, 'error');
            }
            
        }

        function buildValidationIssues({ includePins = true } = {}) {
            const issues = [];

            modules.filter(m => m.enabled).forEach(module => {
                const depends = Array.isArray(module.depends) ? module.depends : [];
                depends.forEach(depId => {
                    const depModule = modules.find(m => m.id === depId);
                    if (!depModule || !depModule.enabled) {
                        issues.push({
                            type: 'error',
                            message: `Module "${module.name}" requires "${depId}" which is not enabled`
                        });
                    }
                });

                const conflicts = Array.isArray(module.conflicts) ? module.conflicts : [];
                conflicts.forEach(conflictId => {
                    const conflictModule = modules.find(m => m.id === conflictId);
                    if (conflictModule && conflictModule.enabled) {
                        issues.push({
                            type: 'warning',
                            message: `Module "${module.name}" conflicts with "${conflictModule.name}"`
                        });
                    }
                });
            });

            if (includePins) {
                const pinResult = checkPinConflicts();
                if ((pinResult.errors || []).length > 0) {
                    issues.push({
                        type: 'error',
                        message: `${pinResult.errors.length} pin assignment error(s) detected`
                    });
                }
            }

            const targetId = selectedBoard?.target_profile;
            const target = targetId ? targets[targetId] : null;
            const enabledModules = modules.filter(m => m.enabled).map(m => m.id);

            if (target?.module_policy?.allowed?.length) {
                const allowed = new Set(target.module_policy.allowed);
                const blocked = enabledModules.filter(m => !allowed.has(m));
                if (blocked.length > 0) {
                    issues.push({
                        type: 'error',
                        message: `Target "${targetId}" does not allow: ${blocked.join(', ')}.`
                    });
                }
            }

            if (selectedBoard?.capabilities?.length) {
                const caps = new Set(selectedBoard.capabilities);
                const requires = {
                    wifi: 'wifi',
                    bluetooth: 'bluetooth',
                    tft: 'tft',
                    touch: 'touch',
                    psram: 'psram',
                    fs_sd: 'sd_card'
                };

                Object.entries(requires).forEach(([moduleId, cap]) => {
                    if (enabledModules.includes(moduleId) && !caps.has(cap)) {
                        issues.push({
                            type: 'warning',
                            message: `Board capabilities do not list "${cap}" but module "${moduleId}" is enabled.`
                        });
                    }
                });
            }

            if (target?.applets?.length) {
                const allowedApplets = new Set(target.applets);
                const enabledApplets = applets.filter(a => appletStates[a]);
                const invalid = enabledApplets.filter(a => !allowedApplets.has(a));
                if (invalid.length > 0) {
                    issues.push({
                        type: 'warning',
                        message: `Selected starter apps not supported by target: ${invalid.join(', ')}.`
                    });
                }
            } else if (applets.length > 0) {
                const allowedApplets = new Set(availableAppletsForBoard(selectedBoard));
                const enabledApplets = applets.filter(a => appletStates[a]);
                const invalid = enabledApplets.filter(a => !allowedApplets.has(a));
                if (invalid.length > 0) {
                    issues.push({
                        type: 'warning',
                        message: `Selected starter apps not supported by board/platform: ${invalid.join(', ')}.`
                    });
                }
            }

            if (marketApps.length > 0) {
                const allowedMarket = new Set(availableMarketAppsForBoard(selectedBoard).map(x => x.id));
                const enabledMarket = marketApps.filter(a => marketAppStates[a]);
                const invalid = enabledMarket.filter(a => !allowedMarket.has(a));
                if (invalid.length > 0) {
                    issues.push({
                        type: 'warning',
                        message: `Selected market apps not supported by board/platform: ${invalid.join(', ')}.`
                    });
                }
            }

            const module_config = collectModuleConfigFromUI();
            const uartAssignments = [];
            Object.entries(module_config).forEach(([modId, opts]) => {
                if (!opts || typeof opts !== 'object') return;
                const port = opts.uart_port !== undefined ? opts.uart_port : opts.uart_num;
                if (port === undefined || port === null || port === '') return;
                uartAssignments.push({ modId, port: Number(port) });
            });

            if (targetId === 'mega2560' && uartAssignments.length > 0) {
                const invalid = uartAssignments.filter(a => Number.isNaN(a.port) || a.port < 0 || a.port > 3);
                if (invalid.length > 0) {
                    issues.push({
                        type: 'warning',
                        message: 'UART port must be 0-3 on Mega 2560.'
                    });
                }
                const seen = {};
                uartAssignments.forEach(a => {
                    const key = String(a.port);
                    if (!seen[key]) seen[key] = [];
                    seen[key].push(a.modId);
                });
                Object.entries(seen).forEach(([port, mods]) => {
                    if (mods.length > 1) {
                        issues.push({
                            type: 'warning',
                            message: `UART${port} is selected by multiple modules: ${mods.join(', ')}.`
                        });
                    }
                });
            }

            return issues;
        }

        function renderValidationReport() {
            const reportEl = document.getElementById('validation-report');
            if (!reportEl) return;

            if (!selectedBoard) {
                reportEl.innerHTML = `
                    <div class="validation-item info">
                        <span class="validation-icon">‚ÑπÔ∏è</span>
                        <div>Select a board to view validation status.</div>
                    </div>
                `;
                return;
            }

            const issues = buildValidationIssues({ includePins: true });
            if (issues.length === 0) {
                reportEl.innerHTML = `
                    <div class="validation-item info">
                        <span class="validation-icon">‚úÖ</span>
                        <div>All checks passed for this configuration.</div>
                    </div>
                `;
                return;
            }

            reportEl.innerHTML = issues.map(issue => `
                <div class="validation-item ${issue.type}">
                    <span class="validation-icon">
                        ${issue.type === 'error' ? '‚ùå' : issue.type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'}
                    </span>
                    <div>${issue.message}</div>
                </div>
            `).join('');
        }

        function collectCurrentConfigPayload() {
            const enabled_modules = modules.filter(m => m.enabled).map(m => m.id);
            const module_config = collectModuleConfigFromUI();
            const enabled_applets = applets.filter(a => appletStates[a]);
            const market_apps = marketApps.filter(a => marketAppStates[a]);
            const custom_pins = {};
            document.querySelectorAll('#pin-table-body input[data-pin]').forEach(input => {
                const key = input.dataset.pin;
                const raw = (input.value || '').trim();
                if (!raw) return;
                if (input.dataset.pinType === 'number') {
                    const val = parseInt(raw, 10);
                    if (!Number.isNaN(val)) custom_pins[key] = val;
                } else {
                    custom_pins[key] = raw;
                }
            });
            return {
                platform: selectedPlatform,
                board_id: selectedBoard?.id,
                target_profile: selectedBoard?.target_profile || null,
                enabled_modules,
                applets: enabled_applets,
                market_apps,
                module_config,
                custom_pins
            };
        }

        function updateWizardSteps() {
            document.querySelectorAll('.step').forEach((step, index) => {
                step.classList.remove('active', 'completed');
                if (index + 1 === currentStep) {
                    step.classList.add('active');
                } else if (index + 1 < currentStep) {
                    step.classList.add('completed');
                }
            });
            
            // Show/hide content sections
            document.querySelectorAll('.content-section').forEach((section, index) => {
                section.classList.remove('active');
                if (index + 1 === currentStep) {
                    section.classList.add('active');
                }
            });
            
            // Update buttons
            document.getElementById('btn-prev').style.display = currentStep > 1 ? 'block' : 'none';
            document.getElementById('btn-next').style.display = currentStep < 4 ? 'block' : 'none';
            document.getElementById('btn-generate').style.display = currentStep === 4 ? 'block' : 'none';
            const btnGenerateBuild = document.getElementById('btn-generate-build');
            if (btnGenerateBuild) {
                btnGenerateBuild.style.display = (currentStep === 4 && selectedPlatform === 'esp32') ? 'block' : 'none';
            }
            
            // Populate data for current step
            if (currentStep === 3) {
                syncModuleStatesFromUI();
                if (selectedBoard && modules.every(m => !m.enabled)) {
                    autoEnableByBoardCapabilities(selectedBoard);
                    populateModuleGrid();
                }
                populatePinTable();
            } else if (currentStep === 2) {
                updateValidation();
                renderSelectedAppsVisibility();
            } else if (currentStep === 4) {
                generateConfigPreview();
                refreshWebFlasher({ silent: true });
            }
        }

        function nextStep() {
            if (currentStep < 4) {
                currentStep++;
                updateWizardSteps();
            }
        }

        function prevStep() {
            if (currentStep > 1) {
                currentStep--;
                updateWizardSteps();
            }
        }

        async function generateFiles() {
            clearInlineOutput();
            if (!selectedBoard) {
                notify('Select a board first.', 'warning');
                return;
            }
            const payload = collectCurrentConfigPayload();

            const btnGenerate = document.getElementById('btn-generate');
            if (btnGenerate) {
                btnGenerate.disabled = true;
                btnGenerate.textContent = 'Generating...';
            }
            try {
                const data = await apiFetchJson('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!data.success) throw new Error(data.error || 'Generate failed');

                const fileLines = Object.keys(data.files || {}).map(k => `${k}: ${data.files[k]}`).join('\n');
                const buildMsg = selectedPlatform === 'avr'
                    ? [
                        'Build with (Arduino CLI):',
                        'arduino-cli compile --fqbn arduino:avr:mega .',
                        '',
                        'Upload with (Arduino CLI):',
                        'arduino-cli upload -p /dev/ttyACM0 --fqbn arduino:avr:mega .'
                    ]
                    : [
                        'Build with (ESP32 targets):',
                        'SDKCONFIG_DEFAULTS=config/generated/sdkconfig.defaults idf.py -B build build flash monitor'
                    ];

                const msg = [
                    'Generated configuration files:',
                    fileLines || '(none)',
                    '',
                    ...buildMsg
                ].join('\n');

                showInlineOutput(msg, 'success');
                notify('Configuration files generated successfully.', 'success');
                refreshWebFlasher({ silent: true });
            } catch (err) {
                const msg = `Generate failed: ${err.message || err}`;
                showInlineOutput(msg, 'error');
                notify(msg, 'error');
            } finally {
                if (btnGenerate) {
                    btnGenerate.disabled = false;
                    btnGenerate.textContent = 'Generate Files';
                }
            }
        }

        async function generateAndBuildEsp32() {
            clearInlineOutput();
            if (!selectedBoard) {
                notify('Select a board first.', 'warning');
                return;
            }
            if (selectedPlatform !== 'esp32') {
                notify('Generate + Build is currently implemented for ESP32 only.', 'warning');
                return;
            }

            const payload = collectCurrentConfigPayload();
            const btn = document.getElementById('btn-generate-build');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Generating + Building...';
            }
            try {
                const gen = await apiFetchJson('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!gen.success) throw new Error(gen.error || 'Generate failed');

                const buildResp = await fetch('/api/build/esp32', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const raw = await buildResp.text();
                let build = null;
                try { build = raw ? JSON.parse(raw) : null; } catch (_e) { build = null; }

                if (!buildResp.ok || !build?.success) {
                    const msg = build?.error || raw || `HTTP ${buildResp.status}`;
                    const details = build?.output || raw || '';
                    showInlineOutput(`Generate succeeded, but build failed: ${msg}\n\n${details}`.trim(), 'error');
                    notify(`Build failed: ${msg}`, 'error');
                    return;
                }

                const genLines = Object.keys(gen.files || {}).map(k => `${k}: ${gen.files[k]}`).join('\n');
                const output = build.output ? String(build.output) : '(no build output)';
                const msg = [
                    'Generate + Build completed successfully.',
                    '',
                    'Generated files:',
                    genLines || '(none)',
                    '',
                    'Build output (tail):',
                    output
                ].join('\n');
                showInlineOutput(msg, 'success');
                notify('ESP32 firmware rebuilt. Web Flasher now uses latest selection.', 'success');
                refreshWebFlasher({ silent: true });
            } catch (err) {
                const msg = `Generate + Build failed: ${err.message || err}`;
                showInlineOutput(msg, 'error');
                notify(msg, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Generate + Build ESP32';
                }
            }
        }

        function attachEventListeners() {
            const startBtn = document.getElementById('btn-start-config');
            if (startBtn) startBtn.addEventListener('click', () => enterConfigurator(1));
            const startEsp32Btn = document.getElementById('btn-start-esp32');
            if (startEsp32Btn) {
                startEsp32Btn.addEventListener('click', async () => {
                    const platformSel = document.getElementById('platform-select');
                    if (platformSel && selectedPlatform !== 'esp32') {
                        platformSel.value = 'esp32';
                        platformSel.dispatchEvent(new Event('change'));
                    }
                    enterConfigurator(1);
                });
            }
            const topOpenBtn = document.getElementById('btn-open-config');
            if (topOpenBtn) topOpenBtn.addEventListener('click', () => enterConfigurator());
            const topMarketBtn = document.getElementById('btn-market');
            if (topMarketBtn) topMarketBtn.addEventListener('click', () => showMarketPage());
            const topHomeBtn = document.getElementById('btn-home');
            if (topHomeBtn) topHomeBtn.addEventListener('click', () => showLanding());
            const btnMarketToConfig = document.getElementById('btn-market-to-config');
            if (btnMarketToConfig) btnMarketToConfig.addEventListener('click', () => enterConfigurator());
            const btnOpenMarketFromConfig = document.getElementById('btn-open-market-from-config');
            if (btnOpenMarketFromConfig) btnOpenMarketFromConfig.addEventListener('click', () => showMarketPage());
            const btnMarketRefresh = document.getElementById('btn-market-refresh');
            if (btnMarketRefresh) {
                btnMarketRefresh.addEventListener('click', async () => {
                    await refreshMarketCatalogForPlatform(selectedPlatform);
                    updateLandingStats();
                    renderMarketPage();
                    notify('Market refreshed.', 'success', 1400);
                });
            }
            const marketPageSearch = document.getElementById('market-page-search');
            if (marketPageSearch) marketPageSearch.addEventListener('input', () => renderMarketPage());
            const btnMarketUpload = document.getElementById('btn-market-upload');
            if (btnMarketUpload) btnMarketUpload.addEventListener('click', () => uploadMarketApp());
            const loginBtn = document.getElementById('btn-login');
            if (loginBtn) {
                loginBtn.addEventListener('click', () => {
                    const current = String(userProfile?.name || '').trim();
                    const next = window.prompt('Enter your builder name', current);
                    if (next === null) return;
                    userProfile.name = String(next || '').trim();
                    saveUserProfile();
                    renderProfilePanel();
                    notify(userProfile.name ? `Signed in as ${userProfile.name}` : 'Signed out to guest mode.', 'success');
                });
            }

            document.getElementById('platform-select').onchange = async (e) => {
                selectedPlatform = e.target.value;
                renderProfilePanel();
                populateBoardList();
                await refreshModulesForPlatform(selectedPlatform);
                await refreshMarketCatalogForPlatform(selectedPlatform);
                updateLandingStats();
                populateModuleGrid();
                populateAppletGrid();
                populateMarketAppGrid();
                renderMarketPage();
                renderTemplateFilters();
                renderTemplates();
                clearInlineOutput();
                refreshWebFlasher({ silent: true });
            };

            const profileNameInput = document.getElementById('profile-name');
            if (profileNameInput) {
                profileNameInput.addEventListener('change', () => {
                    userProfile.name = (profileNameInput.value || '').trim();
                    saveUserProfile();
                    renderProfilePanel();
                });
            }

            const ownedOnlyToggle = document.getElementById('owned-only-toggle');
            if (ownedOnlyToggle) {
                ownedOnlyToggle.checked = false;
                ownedOnlyToggle.addEventListener('change', () => {
                    populateBoardList();
                });
            }

            const inventoryList = document.getElementById('inventory-list');
            if (inventoryList) {
                inventoryList.addEventListener('change', (e) => {
                    const target = e.target;
                    if (!(target instanceof HTMLInputElement)) return;
                    const boardId = target.dataset.ownedBoard;
                    if (!boardId) return;
                    const owned = new Set((userProfile.ownedBoards || []).map(String));
                    if (target.checked) owned.add(String(boardId));
                    else owned.delete(String(boardId));
                    userProfile.ownedBoards = Array.from(owned);
                    saveUserProfile();
                    renderProfilePanel();
                    populateBoardList();
                });
            }

            const marketSearch = document.getElementById('market-search');
            if (marketSearch) {
                marketSearch.addEventListener('input', () => {
                    populateMarketAppGrid();
                });
            }
            
            document.getElementById('board-search').oninput = (e) => {
                const search = e.target.value.toLowerCase();
                document.querySelectorAll('.board-item').forEach(item => {
                    const text = item.textContent.toLowerCase();
                    item.style.display = text.includes(search) ? 'block' : 'none';
                });
                document.querySelectorAll('.board-group').forEach(group => {
                    const hasVisible = Array.from(group.querySelectorAll('.board-item'))
                        .some(item => item.style.display !== 'none');
                    const title = group.querySelector('.board-group-title');
                    if (title) title.style.display = hasVisible ? 'block' : 'none';
                });
            };
            
            document.getElementById('btn-next').onclick = nextStep;
            document.getElementById('btn-prev').onclick = prevStep;
            document.getElementById('btn-generate').onclick = generateFiles;
            const btnGenerateBuild = document.getElementById('btn-generate-build');
            if (btnGenerateBuild) btnGenerateBuild.onclick = generateAndBuildEsp32;
            const expandBtn = document.getElementById('btn-expand-modules');
            if (expandBtn) expandBtn.onclick = () => setAllModuleSections(true);
            const collapseBtn = document.getElementById('btn-collapse-modules');
            if (collapseBtn) collapseBtn.onclick = () => setAllModuleSections(false);
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
