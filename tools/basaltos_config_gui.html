<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BasaltOS Configurator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Manrope", "Avenir Next", "Segoe UI", sans-serif;
            background: #f5f5f5;
            color: #1f2937;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .app-topbar {
            background: #ffffff;
            border: 1px solid #dbeafe;
            border-radius: 14px;
            padding: 14px 18px;
            margin-bottom: 16px;
            box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brand-mark {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: linear-gradient(135deg, #0369a1, #0ea5a4);
            color: #fff;
            font-weight: 800;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .brand-title {
            font-size: 18px;
            font-weight: 800;
            color: #0f172a;
        }

        .brand-sub {
            font-size: 12px;
            color: #475569;
        }

        .topbar-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .topbar-menu {
            position: relative;
        }

        .btn-overflow {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            border: 1px solid #cbd5e1;
            background: #ffffff;
            color: #0f172a;
            font-size: 18px;
            line-height: 1;
            font-weight: 800;
            cursor: pointer;
        }

        .overflow-menu {
            position: absolute;
            right: 0;
            top: calc(100% + 8px);
            min-width: 210px;
            background: #ffffff;
            border: 1px solid #cbd5e1;
            border-radius: 10px;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.14);
            padding: 6px;
            display: none;
            z-index: 60;
        }

        .overflow-menu.active {
            display: block;
        }

        .overflow-menu button {
            display: block;
            width: 100%;
            text-align: left;
            border: none;
            background: transparent;
            color: #0f172a;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .overflow-menu button:hover {
            background: #f1f5f9;
        }

        .btn-nav {
            border: 1px solid #cbd5e1;
            background: #ffffff;
            color: #0f172a;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
        }

        .btn-nav:hover {
            background: #f8fafc;
        }

        .landing-home {
            background: #ffffff;
            color: #1f2937;
            border: 1px solid #dbeafe;
            border-radius: 16px;
            padding: 28px;
            margin-bottom: 24px;
            box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
        }

        .landing-grid {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            gap: 18px;
            align-items: stretch;
        }

        .landing-hero h1 {
            font-size: 34px;
            line-height: 1.1;
            margin-bottom: 12px;
            letter-spacing: -0.01em;
        }

        .landing-hero p {
            color: #475569;
            max-width: 60ch;
            margin-bottom: 18px;
        }

        .landing-cta {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .landing-card {
            border: 1px solid #dbeafe;
            background: #f8fbff;
            border-radius: 12px;
            padding: 14px;
        }

        .landing-card h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #1e3a8a;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .landing-card ul {
            list-style: none;
            font-size: 13px;
            color: #334155;
            display: grid;
            gap: 6px;
        }

        .landing-stat {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .landing-stat-box {
            border-radius: 10px;
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            padding: 8px;
            text-align: center;
            font-size: 12px;
        }

        .landing-stat-box strong {
            display: block;
            font-size: 18px;
            color: #1d4ed8;
        }

        #configurator-shell {
            display: none;
        }

        .wizard-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: sticky;
            top: 10px;
            z-index: 20;
            border: 1px solid #e2e8f0;
        }

        .step {
            flex: 1;
            text-align: center;
            position: relative;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .step:hover {
            background: #f8fafc;
        }

        .step:not(:last-child)::after {
            content: '→';
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
            font-size: 24px;
        }

        .step.active {
            color: #667eea;
            font-weight: 600;
        }

        .step.completed {
            color: #48bb78;
        }

        .step-number {
            display: inline-block;
            width: 30px;
            height: 30px;
            background: #e2e8f0;
            border-radius: 50%;
            line-height: 30px;
            margin-bottom: 5px;
        }

        .step.active .step-number {
            background: #667eea;
            color: white;
        }

        .step.completed .step-number {
            background: #48bb78;
            color: white;
        }

        .config-panel {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .sidebar {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            height: fit-content;
            position: sticky;
            top: 108px;
        }

        .sidebar h3 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 18px;
        }

        .selector-stack {
            display: grid;
            gap: 10px;
        }

        .selector-stack label {
            font-size: 12px;
            color: #475569;
            font-weight: 700;
            letter-spacing: 0.01em;
        }

        .board-browser-note {
            margin-top: 8px;
            font-size: 12px;
            color: #64748b;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 8px 10px;
        }

        .hardware-path {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .hardware-chip {
            font-size: 11px;
            color: #1e3a8a;
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 999px;
            padding: 3px 8px;
            font-weight: 700;
        }

        .board-list, .module-list {
            list-style: none;
        }

        .board-item, .module-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f7fafc;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .board-item:hover, .module-item:hover {
            background: #edf2f7;
        }

        .board-item.selected {
            background: #ebf4ff;
            border-color: #667eea;
            font-weight: 600;
        }

        .board-item:focus-visible {
            outline: 2px solid #2b6cb0;
            outline-offset: 2px;
        }

        .board-group {
            margin-bottom: 12px;
        }

        .board-group-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #718096;
            margin: 10px 0 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid #e2e8f0;
        }

        .board-empty {
            padding: 10px;
            border-radius: 6px;
            background: #f7fafc;
            color: #4a5568;
            font-size: 13px;
        }

        #board-list.board-list {
            max-height: 430px;
            overflow-y: auto;
            padding-right: 4px;
        }

        #board-list.virtualized .board-group-title-row,
        #board-list.virtualized .board-item {
            margin-bottom: 6px;
        }

        .board-virtual-spacer {
            margin: 0;
            padding: 0;
            border: 0;
            list-style: none;
            background: transparent;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .board-perf-panel {
            margin-top: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px dashed #cbd5e0;
            background: #f8fafc;
            color: #475569;
            font-size: 11px;
            line-height: 1.45;
            display: none;
        }

        .main-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .content-section {
            display: none;
            animation: stepFadeIn 0.18s ease-in;
        }

        .content-section.active {
            display: block;
        }

        @keyframes stepFadeIn {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .flow-context {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 0 0 14px 0;
            padding: 10px 12px;
            border: 1px solid #dbeafe;
            background: #f8fbff;
            border-radius: 10px;
        }

        .flow-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 5px 10px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 700;
            border: 1px solid #bfdbfe;
            color: #1e3a8a;
            background: #eff6ff;
        }

        .flow-pill.warn {
            color: #92400e;
            border-color: #fdba74;
            background: #ffedd5;
        }

        .flow-progress {
            margin: 0 0 14px 0;
            border: 1px solid #dbeafe;
            border-radius: 10px;
            padding: 10px 12px;
            background: #f8fbff;
        }

        .flow-progress-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-size: 12px;
            color: #334155;
            margin-bottom: 8px;
        }

        .flow-progress-track {
            height: 10px;
            background: #dbeafe;
            border-radius: 999px;
            overflow: hidden;
        }

        .flow-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3b82f6, #22c55e);
            transition: width 0.25s ease;
        }

        .flow-progress-meta-wrap {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .flow-save-chip {
            border: 1px solid #bfdbfe;
            background: #eff6ff;
            color: #1e3a8a;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 700;
        }

        .flow-alert {
            display: none;
            margin: 0 0 14px 0;
            border: 1px solid #fdba74;
            background: #fff7ed;
            border-radius: 10px;
            padding: 10px 12px;
            color: #7c2d12;
            font-size: 13px;
        }

        .flow-alert.active {
            display: block;
        }

        .flow-alert-actions {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .board-details {
            margin-bottom: 30px;
        }

        .board-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
        }

        .board-image {
            width: 150px;
            height: 150px;
            background: #f7fafc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #a0aec0;
            font-size: 48px;
        }

        .board-info h2 {
            font-size: 28px;
            margin-bottom: 8px;
            color: #2d3748;
        }

        .board-specs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .spec-item {
            background: #f7fafc;
            padding: 15px;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .spec-label {
            font-size: 12px;
            color: #718096;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .spec-value {
            font-size: 16px;
            font-weight: 600;
            color: #2d3748;
        }

        .module-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .module-section {
            margin-top: 14px;
            border: 1px solid #dbeafe;
            border-radius: 10px;
            background: #f8fbff;
            overflow: hidden;
        }

        .module-section summary {
            cursor: pointer;
            list-style: none;
            padding: 12px 14px;
            font-weight: 700;
            color: #1e3a8a;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .module-section summary::-webkit-details-marker {
            display: none;
        }

        .module-section-count {
            font-size: 12px;
            font-weight: 600;
            color: #475569;
            background: #e2e8f0;
            border-radius: 999px;
            padding: 2px 8px;
        }

        .module-subgrid {
            margin-top: 0;
            padding: 0 12px 12px 12px;
            grid-template-columns: repeat(auto-fill, minmax(230px, 1fr));
        }

        .module-card {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            transition: all 0.2s;
        }

        .module-card:hover {
            border-color: #cbd5e0;
        }

        .module-card.enabled {
            background: #ebf4ff;
            border-color: #667eea;
        }

        .module-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .module-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .module-name {
            font-weight: 600;
            font-size: 16px;
            color: #2d3748;
        }

        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e0;
            transition: .3s;
            border-radius: 26px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        .module-description {
            font-size: 14px;
            color: #718096;
            margin-bottom: 10px;
        }

        .module-pins {
            font-size: 12px;
            color: #a0aec0;
        }

        .module-options {
            margin-top: 15px;
            padding: 15px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            display: none;
        }

        .module-options.active {
            display: block;
        }

        .option-field {
            margin-bottom: 12px;
        }

        .option-field label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 5px;
        }

        .option-field input,
        .option-field select {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn-config {
            margin-top: 10px;
            padding: 6px 12px;
            background: #e2e8f0;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-config:hover {
            background: #cbd5e0;
        }

        .btn-config.active {
            background: #667eea;
            color: white;
        }

        .module-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .badge-dep {
            background: #fef3c7;
            color: #92400e;
        }

        .badge-provides {
            background: #dbeafe;
            color: #1e40af;
        }

        .badge-conflict {
            background: #fee2e2;
            color: #991b1b;
        }

        .badge-platform {
            background: #e0e7ff;
            color: #3730a3;
        }

        .module-icon {
            font-size: 22px;
            margin-right: 10px;
        }

        .pin-input.conflict {
            border-color: #f87171;
            background: #fef2f2;
        }

        .pin-input.valid {
            border-color: #34d399;
        }

        .pin-status {
            margin-left: 8px;
            font-size: 16px;
        }

        .pin-status.ok {
            color: #10b981;
        }

        .pin-status.warning {
            color: #f59e0b;
        }

        .pin-status.error {
            color: #ef4444;
        }

        .validation-panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .validation-item {
            display: flex;
            align-items: start;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
        }

        .validation-item.error {
            background: #fef2f2;
            border-left: 3px solid #ef4444;
        }

        .validation-item.warning {
            background: #fffbeb;
            border-left: 3px solid #f59e0b;
        }

        .validation-item.info {
            background: #eff6ff;
            border-left: 3px solid #3b82f6;
        }

        .memory-panel {
            background: #f8fbff;
            border: 1px solid #dbeafe;
            border-radius: 10px;
            padding: 12px;
            margin-top: 12px;
        }

        .memory-note {
            font-size: 12px;
            color: #475569;
            margin-bottom: 8px;
        }

        .memory-row {
            margin-bottom: 10px;
        }

        .memory-row:last-child {
            margin-bottom: 0;
        }

        .memory-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #1f2937;
            margin-bottom: 4px;
        }

        .memory-track {
            width: 100%;
            height: 10px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }

        .memory-fill {
            height: 100%;
            background: #2563eb;
            width: 0%;
            transition: width 0.25s ease;
        }

        .memory-fill.warn { background: #d97706; }
        .memory-fill.err { background: #dc2626; }

        .validation-icon {
            margin-right: 10px;
            font-size: 18px;
        }

        .module-filters {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            position: sticky;
            top: 120px;
            z-index: 12;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 8px;
        }

        .module-filters input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
        }

        .module-filters label {
            font-size: 13px;
            color: #4a5568;
        }

        .module-layout-controls {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        .btn-mini {
            border: 1px solid #cbd5e1;
            background: #f8fafc;
            color: #334155;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            padding: 6px 10px;
            cursor: pointer;
        }

        .btn-mini:hover {
            background: #eef2ff;
            border-color: #a5b4fc;
        }

        .pin-config {
            margin-top: 30px;
        }

        .pin-config h3 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #2d3748;
        }

        .pin-table {
            width: 100%;
            border-collapse: collapse;
        }

        .pin-table th {
            background: #f7fafc;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #4a5568;
            border-bottom: 2px solid #e2e8f0;
        }

        .pin-table td {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
        }

        .pin-table input, .pin-table select {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-size: 14px;
        }

        .pin-table input:focus, .pin-table select:focus {
            outline: none;
            border-color: #667eea;
        }

        .action-buttons {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            margin-top: 30px;
            padding: 14px;
            border: 1px solid #dbeafe;
            border-radius: 12px;
            background: rgba(248, 250, 252, 0.96);
            position: sticky;
            bottom: 10px;
            z-index: 25;
            box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
            backdrop-filter: blur(2px);
        }

        .step-guidance {
            flex: 1;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px 12px;
            color: #334155;
            font-size: 14px;
            min-height: 46px;
            display: flex;
            align-items: center;
        }

        .step-guidance strong {
            color: #0f172a;
        }

        .step-guidance.error {
            background: #fff5f5;
            border-color: #fed7d7;
            color: #9b2c2c;
        }

        .step-tip {
            margin: 10px 0 16px;
            border: 1px solid #dbeafe;
            border-radius: 10px;
            background: #f8fbff;
            padding: 10px 12px;
            font-size: 13px;
            color: #334155;
        }

        .step-tip strong {
            color: #1e3a8a;
        }

        .kbd-hint {
            margin-top: 10px;
            font-size: 12px;
            color: #475569;
        }

        .kbd-hint code {
            background: #e2e8f0;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            padding: 1px 6px;
            font-size: 11px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        }

        .action-controls {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary:disabled {
            opacity: 1;
            background: #cbd5e1;
            color: #475569;
            border: 1px solid #94a3b8;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .btn-success {
            background: #48bb78;
            color: white;
        }

        .btn-success:hover {
            background: #38a169;
        }

        .code-preview {
            background: #1a202c;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin-top: 20px;
        }

        .code-preview pre {
            margin: 0;
        }

        .templates-section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }

        .templates-section h3 {
            margin-bottom: 20px;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
        }

        .template-card {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .template-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
            transform: translateY(-2px);
        }

        .template-card.popular::before {
            content: '⭐ Popular';
            position: absolute;
            top: 10px;
            right: 10px;
            background: #fbbf24;
            color: white;
            font-size: 11px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .template-icon {
            font-size: 48px;
            margin-bottom: 15px;
            display: block;
        }

        .template-card h4 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #2d3748;
        }

        .template-card p {
            font-size: 13px;
            color: #718096;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .template-modules {
            font-size: 12px;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .template-modules strong {
            display: block;
            margin-bottom: 5px;
        }

        .template-tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .template-tag {
            font-size: 11px;
            padding: 3px 8px;
            background: #e0e7ff;
            color: #4338ca;
            border-radius: 3px;
            font-weight: 600;
        }

        .template-quick-actions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
        }

        .btn-template {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-template-preview {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-template-preview:hover {
            background: #cbd5e0;
        }

        .btn-template-use {
            background: #667eea;
            color: white;
        }

        .btn-template-use:hover {
            background: #5568d3;
        }

        .template-filter {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-tag {
            padding: 8px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }

        .filter-tag:hover {
            border-color: #cbd5e0;
        }

        .filter-tag.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .template-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .template-modal.active {
            display: flex;
        }

        .template-modal-content {
            background: white;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 30px;
        }

        .template-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 20px;
        }

        .template-modal-close {
            font-size: 24px;
            cursor: pointer;
            color: #718096;
        }

        .template-modal-close:hover {
            color: #2d3748;
        }

        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .alert-info {
            background: #bee3f8;
            border-left: 4px solid #3182ce;
            color: #2c5282;
        }

        .alert-success {
            background: #c6f6d5;
            border-left: 4px solid #38a169;
            color: #22543d;
        }

        .alert-danger {
            background: #fed7d7;
            border-left: 4px solid #e53e3e;
            color: #742a2a;
        }

        .toast-container {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            pointer-events: auto;
            min-width: 260px;
            max-width: 460px;
            padding: 12px 14px;
            border-radius: 8px;
            color: #fff;
            box-shadow: 0 8px 22px rgba(0, 0, 0, 0.2);
            font-size: 13px;
            line-height: 1.4;
        }

        .toast.info { background: #2b6cb0; }
        .toast.success { background: #2f855a; }
        .toast.warning { background: #b7791f; }
        .toast.error { background: #c53030; }

        .inline-output {
            margin-top: 16px;
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
            color: #2d3748;
            display: none;
        }

        .web-flasher-panel {
            margin-top: 24px;
            border: 1px solid #d6e5f5;
            border-radius: 10px;
            background: linear-gradient(180deg, #f7fbff 0%, #edf5ff 100%);
            padding: 16px;
        }

        .web-flasher-panel h3 {
            margin: 0 0 8px 0;
        }

        .web-flasher-subtitle {
            color: #334155;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .web-flasher-badges {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 8px 0 10px 0;
        }

        .web-flasher-badge {
            font-size: 12px;
            font-weight: 700;
            border-radius: 999px;
            padding: 4px 10px;
            border: 1px solid #cbd5e1;
            background: #f8fafc;
            color: #1e293b;
        }

        .web-flasher-badge.ok {
            background: #dcfce7;
            border-color: #86efac;
            color: #166534;
        }

        .web-flasher-badge.warn {
            background: #fef3c7;
            border-color: #fcd34d;
            color: #92400e;
        }

        .web-flasher-badge.err {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .web-flasher-steps {
            margin: 8px 0 6px 18px;
            color: #1f2937;
            font-size: 13px;
            line-height: 1.4;
        }

        .web-flasher-hint {
            margin-top: 8px;
            font-size: 13px;
            color: #334155;
        }

        .web-flasher-controls {
            margin-top: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .web-flasher-notes {
            margin-top: 12px;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid #bfdbfe;
            background: #eff6ff;
            color: #1e3a8a;
            font-size: 12px;
            line-height: 1.5;
        }

        .web-flasher-notes code {
            font-size: 11px;
        }

        .web-flasher-status {
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            color: #2d3748;
        }

        .serial-panel {
            margin-top: 16px;
            border: 1px solid #d6e5f5;
            border-radius: 10px;
            background: #f8fbff;
            padding: 12px;
        }

        .serial-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .serial-log {
            min-height: 140px;
            max-height: 260px;
            overflow: auto;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            background: #0f172a;
            color: #e2e8f0;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            white-space: pre-wrap;
        }

        .serial-send {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .flash-progress-wrap {
            margin-top: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            background: #f8fafc;
            padding: 8px 10px;
        }

        .flash-progress-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 12px;
            color: #334155;
        }

        .flash-status-pill {
            display: inline-flex;
            align-items: center;
            border-radius: 999px;
            border: 1px solid #cbd5e1;
            padding: 2px 8px;
            font-weight: 700;
            font-size: 11px;
            background: #f8fafc;
            color: #1e293b;
        }

        .flash-status-pill.ok {
            background: #dcfce7;
            border-color: #86efac;
            color: #166534;
        }

        .flash-status-pill.warn {
            background: #fef3c7;
            border-color: #fcd34d;
            color: #92400e;
        }

        .flash-status-pill.err {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .flash-progress-track {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            overflow: hidden;
            background: #e2e8f0;
        }

        .flash-progress-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            background: #2563eb;
        }

        .search-box {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            font-size: 14px;
        }

        .search-box:focus {
            outline: none;
            border-color: #667eea;
        }

        .driver-tabs {
            display: flex;
            gap: 8px;
            margin: 10px 0 14px;
            flex-wrap: wrap;
        }

        .driver-tab {
            border: 1px solid #cbd5e1;
            background: #ffffff;
            color: #0f172a;
            border-radius: 999px;
            padding: 7px 12px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
        }

        .driver-tab.active {
            background: #dbeafe;
            border-color: #93c5fd;
            color: #1e3a8a;
        }

        .status-chips {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 8px 0 12px;
        }

        .status-chip {
            border-radius: 999px;
            font-size: 12px;
            font-weight: 700;
            padding: 5px 9px;
            border: 1px solid #cbd5e1;
            background: #f8fafc;
            color: #334155;
        }

        .status-chip.ok {
            color: #166534;
            background: #dcfce7;
            border-color: #86efac;
        }

        .status-chip.warn {
            color: #92400e;
            background: #ffedd5;
            border-color: #fdba74;
        }

        .status-chip.err {
            color: #991b1b;
            background: #fee2e2;
            border-color: #fca5a5;
        }

        .compat-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 999px;
            margin-top: 8px;
            border: 1px solid #cbd5e1;
        }

        .compat-badge.ok {
            color: #166534;
            background: #dcfce7;
            border-color: #86efac;
        }

        .compat-badge.warn {
            color: #92400e;
            background: #ffedd5;
            border-color: #fdba74;
        }

        .compat-badge.err {
            color: #991b1b;
            background: #fee2e2;
            border-color: #fca5a5;
        }

        .plain-help {
            margin-top: 10px;
            border: 1px solid #dbeafe;
            border-radius: 8px;
            padding: 8px 10px;
            background: #f8fbff;
            font-size: 12px;
            color: #334155;
        }

        .plain-help summary {
            cursor: pointer;
            font-weight: 700;
            color: #1e3a8a;
        }

        @media (max-width: 900px) {
            .landing-grid {
                grid-template-columns: 1fr;
            }

            .config-panel {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: static;
                top: auto;
            }

            .wizard-steps {
                position: static;
                top: auto;
            }

            .action-buttons {
                flex-direction: column;
                align-items: stretch;
                position: static;
                bottom: auto;
            }

            .action-controls {
                width: 100%;
                justify-content: space-between;
            }

        }
    </style>
</head>
<body>
    <div id="toast-container" class="toast-container"></div>
    <div class="container">
        <div class="app-topbar">
            <div class="brand">
                <span class="brand-mark">B</span>
                <div>
                    <div class="brand-title">BasaltOS Configurator</div>
                    <div class="brand-sub">Local-first config and generation for BasaltOS boards</div>
                </div>
            </div>
            <div class="topbar-actions">
                <button id="btn-home" class="btn-nav" type="button">Home</button>
                <button id="btn-open-config" class="btn-nav" type="button">Open Configurator</button>
                <div class="topbar-menu">
                    <button id="btn-overflow-menu" class="btn-overflow" type="button" aria-label="More options">⋯</button>
                    <div id="overflow-menu" class="overflow-menu">
                        <button id="menu-diy-board" type="button">DIY Board Creator</button>
                    </div>
                </div>
            </div>
        </div>

        <section id="landing-home" class="landing-home">
            <div class="landing-grid">
                <div class="landing-hero">
                    <h1>BasaltOS Local Configurator</h1>
                    <p>
                        Choose a board, enable drivers, and generate deterministic config outputs for local builds.
                        This tool is local-first and intentionally excludes accounts, cloud storage, and hosted platform features.
                    </p>
                    <div class="landing-cta">
                        <button id="btn-start-config" class="btn btn-success" type="button">Start Configuring</button>
                        <button id="btn-start-esp32" class="btn btn-secondary" type="button">Quick Start: ESP32</button>
                        <button id="btn-resume-last" class="btn btn-secondary" type="button" style="display:none;">Resume Last Session</button>
                    </div>
                    <div id="resume-last-meta" style="margin-top:8px; font-size:12px; color:#475569; display:none;"></div>
                    <div class="landing-stat">
                        <div class="landing-stat-box"><strong id="stat-platforms">0</strong>Platforms</div>
                        <div class="landing-stat-box"><strong id="stat-boards">0</strong>Boards</div>
                    </div>
                </div>
                <div class="landing-card">
                    <h3>Getting Started</h3>
                    <ul>
                        <li>1. Pick a board or template</li>
                        <li>2. Enable drivers required by your board and build profile</li>
                        <li>3. Generate outputs, then Build and Flash</li>
                        <li>4. Run apps from shell: <code>run &lt;app&gt;</code></li>
                    </ul>
                    <h3 style="margin-top:12px;">Tips</h3>
                    <ul>
                        <li>Use templates for reproducible project presets.</li>
                        <li>Use board capability checks to avoid invalid driver combos.</li>
                        <li>Watch memory bars in every step and keep usage below ~85% when possible.</li>
                        <li>Web flasher supports Windows COM and Linux/macOS tty devices.</li>
                    </ul>
                </div>
            </div>
        </section>

        <div id="configurator-shell">
        <div class="wizard-steps">
            <div class="step active" data-step="1">
                <div class="step-number">1</div>
                <div class="step-title">Platform & Board</div>
            </div>
            <div class="step" data-step="2">
                <div class="step-number">2</div>
                <div class="step-title">Drivers</div>
            </div>
            <div class="step" data-step="3">
                <div class="step-number">3</div>
                <div class="step-title">Runtime Options</div>
            </div>
            <div class="step" data-step="4">
                <div class="step-number">4</div>
                <div class="step-title">Generate</div>
            </div>
        </div>
        <div class="flow-progress">
            <div class="flow-progress-head">
                <span id="flow-progress-title">Step Progress</span>
                <span class="flow-progress-meta-wrap">
                    <span id="flow-progress-meta">0%</span>
                    <span id="flow-save-chip" class="flow-save-chip">Saved just now</span>
                </span>
            </div>
            <div class="flow-progress-track">
                <div id="flow-progress-fill" class="flow-progress-fill"></div>
            </div>
        </div>
        <div id="flow-alert" class="flow-alert"></div>

        <div class="config-panel">
            <!-- Sidebar -->
            <div class="sidebar">
                <div id="platform-selection">
                    <h3>Select Hardware</h3>
                    <div class="alert alert-danger" id="platform-load-error" style="display:none; margin-bottom: 10px;"></div>
                    <div class="selector-stack">
                        <div>
                            <label for="manufacturer-select">Manufacturer</label>
                            <select id="manufacturer-select" class="search-box"></select>
                        </div>
                        <div>
                            <label for="architecture-select">Architecture</label>
                            <select id="architecture-select" class="search-box"></select>
                        </div>
                        <div>
                            <label for="family-select">Family</label>
                            <select id="family-select" class="search-box"></select>
                        </div>
                        <div>
                            <label for="silicon-select">Processor / Silicon</label>
                            <select id="silicon-select" class="search-box"></select>
                        </div>
                    </div>
                    <div class="board-browser-note">
                        Pick broad criteria first, then choose your exact board below.
                    </div>
                    <select id="platform-select" class="search-box" style="display:none;" aria-hidden="true" tabindex="-1">
                        <!-- hidden internal platform binding -->
                    </select>
                </div>

                <div id="board-selection" style="margin-top: 20px;">
                    <h3>Boards</h3>
                    <div id="hardware-path" class="hardware-path"></div>
                    <label for="board-search" class="sr-only">Search boards</label>
                    <input type="text" class="search-box" placeholder="Search boards..." id="board-search" aria-label="Search boards" aria-controls="board-list">
                    <ul class="board-list" id="board-list" role="listbox" tabindex="0" aria-label="Board picker">
                        <!-- Populated by JavaScript -->
                    </ul>
                    <div id="board-list-status" class="sr-only" role="status" aria-live="polite"></div>
                    <div id="board-perf-panel" class="board-perf-panel"></div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <div id="flow-context" class="flow-context"></div>
                <!-- Step 1: Board Selection -->
                <div id="step-1" class="content-section active">
                    <h2 style="margin-bottom: 10px;">Choose Platform and Board</h2>
                    <div class="alert alert-info">
                        <strong>Welcome.</strong> Start by selecting your exact board so driver defaults and validation rules match your hardware.
                    </div>
                    <div class="step-tip">
                        <strong>Quick flow:</strong> pick manufacturer/family, click your board in the left list, then continue to Drivers.
                        <div style="margin-top:8px;">
                            <button id="btn-quick-m5" class="btn btn-secondary" type="button" style="padding:7px 10px; font-size:12px;">Use M5Stack Plus2 (Quick Pick)</button>
                        </div>
                        <div class="kbd-hint">Shortcuts: <code>Alt+1</code>..<code>Alt+4</code> navigate steps, <code>Ctrl+G</code> generate on Step 4.</div>
                    </div>
                    <div id="memory-step1-panel" class="memory-panel"></div>

                    <div id="board-details" style="display: none;">
                        <div class="board-header">
                            <div class="board-image">📟</div>
                            <div class="board-info">
                                <h2 id="board-name">CYD ESP32-3248S035R</h2>
                                <p id="board-description">3.5" TFT display with resistive touch, ESP32 powered</p>
                            </div>
                        </div>

                        <div class="board-specs">
                            <div class="spec-item">
                                <div class="spec-label">MCU</div>
                                <div class="spec-value" id="spec-mcu">ESP32-WROOM-32</div>
                            </div>
                            <div class="spec-item">
                                <div class="spec-label">Flash</div>
                                <div class="spec-value" id="spec-flash">4MB</div>
                            </div>
                            <div class="spec-item">
                                <div class="spec-label">RAM</div>
                                <div class="spec-value" id="spec-ram">520KB</div>
                            </div>
                            <div class="spec-item">
                                <div class="spec-label">Display</div>
                                <div class="spec-value" id="spec-display">320x480 ST7796</div>
                            </div>
                            <div class="spec-item">
                                <div class="spec-label">Target Profile</div>
                                <div class="spec-value" id="spec-target">—</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Driver Selection -->
                <div id="step-2" class="content-section">
                    <h2 style="margin-bottom: 20px;">Select Drivers</h2>
                    <div class="alert alert-info">
                        Enable or disable drivers based on your application needs. Runtime options are configured in the next step.
                    </div>
                    <div class="step-tip">
                        <strong>Tip:</strong> start with <em>Essential</em>, then add only what you need. If warnings appear, use <em>Apply Quick Fixes</em>.
                    </div>

                    <div class="module-filters">
                        <input type="text" id="module-search" placeholder="🔍 Search drivers...">
                        <label>
                            <input type="checkbox" id="show-enabled-only"> Show enabled only
                        </label>
                        <div class="module-layout-controls">
                            <button class="btn-mini" id="btn-board-defaults" type="button">Use Board Recommended Defaults</button>
                            <button class="btn-mini" id="btn-optimize-size" type="button">Optimize For Size</button>
                            <button class="btn-mini" id="btn-expand-modules" type="button">Expand All</button>
                            <button class="btn-mini" id="btn-collapse-modules" type="button">Collapse All</button>
                        </div>
                    </div>
                    <div class="driver-tabs" id="driver-tabs">
                        <button class="driver-tab active" type="button" data-driver-view="essential">Essential</button>
                        <button class="driver-tab" type="button" data-driver-view="advanced">Advanced</button>
                        <button class="driver-tab" type="button" data-driver-view="experimental">Experimental</button>
                        <button class="driver-tab" type="button" data-driver-view="all">All</button>
                    </div>
                    <div id="status-chips" class="status-chips"></div>
                    <details class="plain-help">
                        <summary>Help & quick fixes</summary>
                        <div style="margin-top:6px;">If your setup shows warnings/errors, you can apply safe defaults to reduce conflicts and memory pressure.</div>
                        <div style="margin-top:8px;">
                            <button id="btn-build-health-fix" class="btn btn-secondary" type="button">Apply Quick Fixes</button>
                        </div>
                    </details>
                    <details class="plain-help">
                        <summary>New here? Read this in plain language</summary>
                        <div style="margin-top:6px;">Essential drivers are the safest starting point. Advanced adds more features and memory usage. Experimental includes in-progress or hardware-specific integrations that may require extra setup.</div>
                    </details>

                    <div class="validation-panel" id="validation-warnings">
                        <!-- Validation messages appear here -->
                    </div>
                    <div id="memory-estimate-panel" class="memory-panel"></div>
                    
                    <div class="module-grid" id="module-grid">
                        <!-- Populated by JavaScript -->
                    </div>
                    <div id="module-grid-status" class="sr-only" role="status" aria-live="polite"></div>

                    <h3 style="margin-top: 30px;">Selected Apps</h3>
                    <div class="alert alert-info">
                        This panel shows current runtime app selections. Edit them in Step 3 (Runtime Options).
                    </div>
                    <div id="selected-apps-visibility" class="validation-panel"></div>
                </div>

                <!-- Step 3: Pin Configuration -->
                <div id="step-3" class="content-section">
                    <h2 style="margin-bottom: 20px;">Runtime Options</h2>
                    <div class="alert alert-info">
                        Choose starter applets and market apps for this build. Pin mapping is available below as an optional advanced section.
                    </div>
                    <div class="step-tip">
                        <strong>Tip:</strong> keep this step minimal first, then add applets incrementally and re-check memory bars.
                    </div>
                    <div id="memory-step3-panel" class="memory-panel"></div>

                    <div class="pin-config">
                        <h3>Starter Applets</h3>
                        <div class="validation-panel" id="runtime-applets-list">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <div class="pin-config" style="margin-top: 18px;">
                        <h3>Market Apps</h3>
                        <div class="validation-panel" id="runtime-market-apps-list">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <details id="advanced-pin-config" class="plain-help" style="margin-top:16px;">
                        <summary>Advanced: Pin Configuration (Optional)</summary>
                        <div class="alert alert-info" style="margin-top: 10px;">
                            Optional override layer for board pin defaults. Leave untouched unless you need custom wiring.
                        </div>
                        <div class="validation-panel" id="pin-validation">
                            <!-- Pin conflict warnings appear here -->
                        </div>
                        <div class="pin-config">
                            <h3>Pin Assignments</h3>
                            <table class="pin-table" id="pin-table">
                                <thead>
                                    <tr>
                                        <th>Driver</th>
                                        <th>Signal</th>
                                        <th>Pin</th>
                                        <th>Alternative Pins</th>
                                    </tr>
                                </thead>
                                <tbody id="pin-table-body">
                                    <!-- Populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </details>

                    <div id="avr-config-panel" class="validation-panel" style="display:none; margin-top:16px;">
                        <h3 style="margin-bottom:10px;">AVR Runtime Overrides (Optional)</h3>
                        <div class="alert alert-info" style="margin-bottom:10px;">
                            AVR clock and fuse values can brick or destabilize a board if misconfigured.
                        </div>
                        <details class="plain-help" style="margin-bottom:10px;">
                            <summary>What this means (plain language)</summary>
                            <div style="margin-top:6px;">Clock controls timing speed. Fuse bits set low-level chip behavior. Wrong values can make upload fail until recovered with a programmer. If unsure, keep defaults and leave advanced edit off.</div>
                        </details>
                        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px;">
                            <label style="display:flex; align-items:center; gap:8px; margin:0;">
                                <input id="avr-advanced-toggle" type="checkbox">
                                Edit Clock/Fuses (Advanced)
                            </label>
                            <button id="btn-avr-restore-defaults" class="btn btn-secondary" type="button" style="padding:8px 12px; font-size:13px;">Restore Board Defaults</button>
                        </div>
                        <div id="avr-advanced-warning" class="alert alert-danger" style="display:none; margin-bottom:10px;">
                            Advanced editing is enabled. Double-check clock and fuse bytes before generating/flashing.
                        </div>
                        <div class="module-grid" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:10px;">
                            <div>
                                <label for="avr-clock-hz">Clock (Hz)</label>
                                <input id="avr-clock-hz" type="number" min="1" class="search-box" style="margin-top:6px;" placeholder="16000000">
                            </div>
                            <div>
                                <label for="avr-upload-method">Upload Method</label>
                                <select id="avr-upload-method" class="search-box" style="margin-top:6px;">
                                    <option value="bootloader">Bootloader (Arduino)</option>
                                    <option value="isp">ISP (avrdude)</option>
                                    <option value="updi">UPDI (avrdude)</option>
                                </select>
                            </div>
                            <div>
                                <label for="avr-fqbn">FQBN</label>
                                <input id="avr-fqbn" type="text" class="search-box" style="margin-top:6px;" placeholder="arduino:avr:mega">
                            </div>
                            <div>
                                <label for="avr-mcu">MCU</label>
                                <input id="avr-mcu" type="text" class="search-box" style="margin-top:6px;" placeholder="atmega2560">
                            </div>
                            <div>
                                <label for="avr-programmer">Programmer</label>
                                <input id="avr-programmer" type="text" class="search-box" style="margin-top:6px;" placeholder="wiring / usbasp / serialupdi">
                            </div>
                            <div>
                                <label for="avr-baud">Baud</label>
                                <input id="avr-baud" type="number" min="1" class="search-box" style="margin-top:6px;" placeholder="115200">
                            </div>
                            <div>
                                <label for="avr-port">Port (optional)</label>
                                <input id="avr-port" type="text" class="search-box" style="margin-top:6px;" placeholder="COM5 or /dev/ttyACM0">
                            </div>
                        </div>
                        <div class="module-grid" style="grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:10px; margin-top:6px;">
                            <div><label for="avr-fuse-l">LFUSE</label><input id="avr-fuse-l" type="text" class="search-box" style="margin-top:6px;" placeholder="0xFF"></div>
                            <div><label for="avr-fuse-h">HFUSE</label><input id="avr-fuse-h" type="text" class="search-box" style="margin-top:6px;" placeholder="0xD8"></div>
                            <div><label for="avr-fuse-e">EFUSE</label><input id="avr-fuse-e" type="text" class="search-box" style="margin-top:6px;" placeholder="0xFD"></div>
                            <div><label for="avr-fuse-lock">LOCK</label><input id="avr-fuse-lock" type="text" class="search-box" style="margin-top:6px;" placeholder="0x0F"></div>
                        </div>
                        <div style="font-size:12px; color:#475569; margin-top:8px;">
                            Use bootloader for Mega over USB serial. Use ISP/UPDI for external programmers and ATmega3208-style targets.
                        </div>
                    </div>
                </div>

                <!-- Step 4: Generate -->
                <div id="step-4" class="content-section">
                    <h2 style="margin-bottom: 20px;">Generate Configuration</h2>
                    <div class="alert alert-success">
                        <strong>Configuration Complete!</strong> Review your settings and generate the configuration files.
                    </div>
                    <div class="step-tip">
                        <strong>Final pass:</strong> confirm validation is clean, generate files, then use Build/Flash controls below.
                    </div>

                    <div style="margin-top: 30px;">
                        <h3>Configuration Summary</h3>
                        <div id="config-summary" style="margin-top: 15px;">
                            <!-- Populated by JavaScript -->
                        </div>
                        <div id="memory-summary-panel" class="memory-panel"></div>
                    </div>

                    <div style="margin-top: 30px;">
                        <h3>Validation Report</h3>
                        <div class="validation-panel" id="validation-report">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    <div style="margin-top: 20px;">
                        <h3>Release Readiness Checklist</h3>
                        <div class="validation-panel" id="review-checklist">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <div style="margin-top: 30px;">
                        <h3>Preview: basalt_config.h</h3>
                        <div class="code-preview">
                            <pre id="config-preview">/* Generated configuration will appear here */</pre>
                        </div>
                    </div>

                    <div id="generate-output" class="inline-output"></div>
                    <div class="validation-panel" id="final-step-actions" style="margin-top:14px;">
                        <div class="validation-item info">
                            <span class="validation-icon">🧭</span>
                            <div><strong>Next:</strong> Generate files, then build from repo root with ESP-IDF.</div>
                        </div>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
                            <button class="btn btn-secondary" id="btn-copy-idf-build" type="button" style="padding:8px 12px; font-size:13px;">Copy ESP-IDF Build Commands</button>
                            <button class="btn btn-secondary" id="btn-open-first-success" type="button" style="padding:8px 12px; font-size:13px;">Open 10-Min First Success Guide</button>
                        </div>
                    </div>

                    <div id="web-flasher-panel" class="web-flasher-panel" style="display:none;">
                        <h3>ESP32 Web Flasher</h3>
                        <div class="web-flasher-subtitle">Flash directly from this page via Web Serial (Chrome/Edge on <code>http://localhost</code> or HTTPS).</div>
                        <div class="web-flasher-badges">
                            <span id="badge-firmware" class="web-flasher-badge">Firmware: unknown</span>
                            <span id="badge-serial-port" class="web-flasher-badge">Serial port: unknown</span>
                        </div>
                        <ol class="web-flasher-steps">
                            <li>Click <strong>Check Firmware + Port</strong>.</li>
                            <li>Click <strong>Connect &amp; Flash</strong>, then choose the ESP32 USB serial device in the picker (<code>COMx</code> on Windows, <code>ttyUSB*</code>/<code>ttyACM*</code> on Linux).</li>
                            <li>If connect fails, click <strong>Release Browser Port Lock</strong> and retry.</li>
                        </ol>
                        <div class="web-flasher-controls">
                            <button class="btn btn-secondary" id="btn-refresh-flasher">Check Firmware + Port</button>
                            <button class="btn btn-secondary" id="btn-release-serial">Release Browser Port Lock</button>
                            <button class="btn btn-primary" id="btn-local-flash">Local Flash (idf.py)</button>
                            <esp-web-install-button id="esp-web-install" style="display:none;">
                                <button slot="activate" class="btn btn-primary">Connect &amp; Flash</button>
                            </esp-web-install-button>
                        </div>
                        <div class="flash-progress-wrap">
                            <div class="flash-progress-head">
                                <span id="esp-flash-phase">Flash phase: idle</span>
                                <span id="esp-flash-status-pill" class="flash-status-pill">Idle</span>
                            </div>
                            <div class="flash-progress-track">
                                <div id="esp-flash-progress" class="flash-progress-fill"></div>
                            </div>
                        </div>
                        <div id="web-flasher-hint" class="web-flasher-hint">Run a check before connecting.</div>
                        <details class="web-flasher-notes">
                            <summary><strong>Troubleshooting</strong></summary>
                            <div>1) In the picker, select the ESP32 USB serial device (<code>COMx</code> / <code>ttyUSB*</code> / <code>ttyACM*</code>), not unrelated system ports.</div>
                            <div>2) If “Serial port is not ready”, click <code>Release Browser Port Lock</code> and retry.</div>
                            <div>3) If still blocked, unplug/replug USB and run check again.</div>
                            <div>4) If needed, use <code>Local Flash (idf.py)</code> fallback.</div>
                        </details>
                        <div id="web-flasher-status" class="web-flasher-status"></div>
                    </div>

                    <div id="avr-flasher-panel" class="web-flasher-panel" style="display:none;">
                        <h3>AVR Build + Flash</h3>
                        <div class="web-flasher-subtitle">Generate first, then build/flash for bootloader, ISP, or UPDI from this page.</div>
                        <div class="web-flasher-badges">
                            <span id="badge-avr-project" class="web-flasher-badge">Project: unknown</span>
                            <span id="badge-avr-tools" class="web-flasher-badge">Tools: unknown</span>
                        </div>
                        <ol class="web-flasher-steps">
                            <li>Set AVR options in Step 3 (clock/fuses/upload method/programmer).</li>
                            <li>Click <strong>Generate Files</strong>, then <strong>Check AVR Status</strong>.</li>
                            <li>Click <strong>Build AVR</strong> and <strong>Flash AVR</strong>.</li>
                        </ol>
                        <div class="web-flasher-controls">
                            <button class="btn btn-secondary" id="btn-refresh-avr-flasher">Check AVR Status</button>
                            <button class="btn btn-secondary" id="btn-build-avr">Build AVR</button>
                            <button class="btn btn-primary" id="btn-local-flash-avr">Flash AVR</button>
                        </div>
                        <details class="web-flasher-notes">
                            <summary><strong>Notes</strong></summary>
                            <div>Bootloader mode uses <code>arduino-cli upload</code>.</div>
                            <div>ISP/UPDI mode compiles a HEX with <code>arduino-cli compile</code>, then flashes via <code>avrdude</code>.</div>
                        </details>
                        <div id="avr-flasher-status" class="web-flasher-status"></div>
                    </div>

                    <div id="serial-terminal-panel" class="serial-panel" style="display:none;">
                        <h3 style="margin-bottom:6px;">Serial Terminal</h3>
                        <div class="web-flasher-subtitle">Monitor boot logs and send shell/CLI commands directly over serial.</div>
                        <div class="serial-controls">
                            <label for="serial-baud" style="font-size:12px; color:#334155;">Baud</label>
                            <input id="serial-baud" type="number" value="115200" min="1200" class="search-box" style="width:130px; margin:0;">
                            <button class="btn btn-secondary" id="btn-serial-connect" type="button">Connect Serial</button>
                            <button class="btn btn-secondary" id="btn-serial-disconnect" type="button">Disconnect</button>
                            <button class="btn btn-secondary" id="btn-serial-clear" type="button">Clear Log</button>
                            <span id="serial-state-pill" class="flash-status-pill">Disconnected</span>
                        </div>
                        <div id="serial-log" class="serial-log"></div>
                        <div class="serial-send">
                            <input id="serial-command" type="text" class="search-box" placeholder="Type command, e.g. help" style="margin:0; flex:1;">
                            <button class="btn btn-primary" id="btn-serial-send" type="button">Send</button>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <div id="step-guidance" class="step-guidance" role="status" aria-live="polite">
                        <strong>Step 1:</strong>&nbsp;Select a board to begin.
                    </div>
                    <div class="action-controls">
                        <button class="btn btn-secondary" id="btn-prev" style="display: none;">← Previous</button>
                        <button class="btn btn-primary" id="btn-next">Next →</button>
                        <button class="btn btn-primary" id="btn-generate-build" style="display: none;">Generate + Build ESP32</button>
                        <button class="btn btn-success" id="btn-generate" style="display: none;">Generate Files</button>
                    </div>
        </div>
        </div>
        </div>
    </div>
    </div>

    <div class="template-modal" id="diy-board-modal">
        <div class="template-modal-content">
            <div class="template-modal-header">
                <div>
                    <h3 style="margin:0;">DIY Board Creator</h3>
                    <div style="font-size:13px; color:#64748b; margin-top:4px;">Create/update a custom board profile JSON under <code>boards/&lt;platform&gt;/&lt;id&gt;/board.json</code>.</div>
                </div>
                <span class="template-modal-close" id="btn-close-diy-board">×</span>
            </div>
            <div class="module-grid" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:10px;">
                <div><label>Platform</label><select id="diy-platform" class="search-box" style="margin-top:6px;"></select></div>
                <div><label>Board ID</label><input id="diy-id" class="search-box" placeholder="my_custom_board"></div>
                <div><label>Name</label><input id="diy-name" class="search-box" placeholder="My Custom Board"></div>
                <div><label>Target Profile</label><input id="diy-target-profile" class="search-box" placeholder="optional (e.g. mega2560)"></div>
                <div><label>MCU</label><input id="diy-mcu" class="search-box" placeholder="ATmega3208"></div>
                <div><label>Flash</label><input id="diy-flash" class="search-box" placeholder="32KB"></div>
                <div><label>RAM</label><input id="diy-ram" class="search-box" placeholder="2KB"></div>
                <div><label>Display</label><input id="diy-display" class="search-box" placeholder="None / SSD1306 / ..."></div>
            </div>
            <div style="margin-top:8px;">
                <label>Description</label>
                <input id="diy-description" class="search-box" placeholder="Custom board for project X">
            </div>
            <div style="margin-top:8px;">
                <label>Capabilities (comma-separated)</label>
                <input id="diy-capabilities" class="search-box" placeholder="gpio,uart,spi,i2c,adc,sd_card,tft">
            </div>
            <div style="margin-top:8px;">
                <label>Pins (one per line: <code>signal=pin</code>)</label>
                <textarea id="diy-pins" class="search-box" style="height:120px; font-family:monospace;" placeholder="uart_tx=1&#10;uart_rx=3&#10;i2c_sda=21&#10;i2c_scl=22"></textarea>
            </div>
            <div class="action-buttons" style="margin-top:10px;">
                <button class="btn btn-secondary" id="btn-cancel-diy-board" type="button">Cancel</button>
                <button class="btn btn-success" id="btn-save-diy-board" type="button">Save Custom Board</button>
            </div>
        </div>
    </div>

    <script type="module" src="https://unpkg.com/esp-web-tools@10/dist/web/install-button.js?module"></script>
    <script>
        function notify(message, type = 'info', timeoutMs = 3600) {
            const container = document.getElementById('toast-container');
            if (!container) return;
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            window.setTimeout(() => toast.remove(), timeoutMs);
        }

        function showInlineOutput(text, type = 'info') {
            const output = document.getElementById('generate-output');
            if (!output) return;
            output.style.display = 'block';
            output.style.borderColor = type === 'error' ? '#feb2b2' : '#cbd5e0';
            output.style.background = type === 'error' ? '#fff5f5' : '#f7fafc';
            output.textContent = text;
            if (type === 'error') {
                try { output.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (_e) {}
            }
        }

        function clearInlineOutput() {
            const output = document.getElementById('generate-output');
            if (!output) return;
            output.style.display = 'none';
            output.textContent = '';
        }

        function renderWebFlasherStatus(status) {
            const statusEl = document.getElementById('web-flasher-status');
            if (!statusEl) return;
            if (!status) {
                statusEl.textContent = 'No status available.';
                return;
            }

            const lines = [];
            lines.push(`Ready: ${status.ready ? 'yes' : 'no'}`);
            if (status.build_version) {
                lines.push(`Build version: ${status.build_version}`);
            }
            if (Array.isArray(status.missing_required) && status.missing_required.length > 0) {
                lines.push(`Missing required: ${status.missing_required.join(', ')}`);
                lines.push('Build command: SDKCONFIG_DEFAULTS=config/generated/sdkconfig.defaults idf.py -B build build');
            }
            if (Array.isArray(status.files)) {
                lines.push('');
                status.files.forEach(f => {
                    const sz = Number(f.size || 0);
                    const stamp = f.mtime_ns ? `, v=${f.mtime_ns}` : '';
                    lines.push(`${f.exists ? 'OK ' : 'MISS'} 0x${Number(f.offset).toString(16).toUpperCase().padStart(6, '0')}  ${f.name}  (${sz} bytes${stamp})`);
                });
            }
            statusEl.textContent = lines.join('\n');
        }

        function setFlasherBadges({ firmwareReady = null, portBusy = null, secureContext = true } = {}) {
            const fw = document.getElementById('badge-firmware');
            const sp = document.getElementById('badge-serial-port');
            if (fw) {
                fw.className = 'web-flasher-badge';
                if (firmwareReady === true) {
                    fw.classList.add('ok');
                    fw.textContent = 'Firmware: ready';
                } else if (firmwareReady === false) {
                    fw.classList.add('err');
                    fw.textContent = 'Firmware: missing artifacts';
                } else {
                    fw.textContent = 'Firmware: unknown';
                }
            }
            if (sp) {
                sp.className = 'web-flasher-badge';
                if (!secureContext) {
                    sp.classList.add('warn');
                    sp.textContent = 'Serial: blocked (context)';
                } else if (portBusy === true) {
                    sp.classList.add('err');
                    sp.textContent = 'Serial: busy';
                } else if (portBusy === false) {
                    sp.classList.add('ok');
                    sp.textContent = 'Serial: free';
                } else {
                    sp.textContent = 'Serial: unknown';
                }
            }
        }

        function setEspFlashProgress({ phase = 'idle', status = 'idle', percent = 0 } = {}) {
            const phaseEl = document.getElementById('esp-flash-phase');
            const pill = document.getElementById('esp-flash-status-pill');
            const fill = document.getElementById('esp-flash-progress');
            const pct = Math.max(0, Math.min(100, Number(percent || 0)));

            if (phaseEl) phaseEl.textContent = `Flash phase: ${phase}`;
            if (fill) fill.style.width = `${pct}%`;
            if (pill) {
                pill.className = 'flash-status-pill';
                if (status === 'ok') pill.classList.add('ok');
                else if (status === 'warn') pill.classList.add('warn');
                else if (status === 'err') pill.classList.add('err');
                const labels = {
                    idle: 'Idle',
                    active: 'Flashing',
                    ok: 'Success',
                    warn: 'Pending',
                    err: 'Failed'
                };
                pill.textContent = labels[status] || String(status || 'Idle');
            }
        }

        function phaseFromEspWebState(state) {
            const s = String(state || '').toLowerCase();
            if (!s) return { phase: 'waiting', status: 'warn', percent: 8 };
            if (s.includes('prepare') || s.includes('connect')) return { phase: s, status: 'active', percent: 12 };
            if (s.includes('erase')) return { phase: s, status: 'active', percent: 28 };
            if (s.includes('write') || s.includes('flash')) return { phase: s, status: 'active', percent: 70 };
            if (s.includes('verify')) return { phase: s, status: 'active', percent: 88 };
            if (s.includes('done') || s.includes('finished') || s.includes('complete')) return { phase: s, status: 'ok', percent: 100 };
            if (s.includes('fail') || s.includes('error')) return { phase: s, status: 'err', percent: 100 };
            return { phase: s, status: 'active', percent: 50 };
        }

        function initEspWebInstallEvents() {
            const install = document.getElementById('esp-web-install');
            if (!install || install.dataset.eventsBound === '1') return;
            install.dataset.eventsBound = '1';
            let waitTimer = null;
            const clearWaitTimer = () => {
                if (waitTimer) {
                    window.clearTimeout(waitTimer);
                    waitTimer = null;
                }
            };

            setEspFlashProgress({ phase: 'idle', status: 'idle', percent: 0 });

            const bind = (eventName, handler) => {
                install.addEventListener(eventName, handler);
            };

            bind('click', () => {
                clearWaitTimer();
                setEspFlashProgress({ phase: 'picker_open', status: 'warn', percent: 6 });
                const hintEl = document.getElementById('web-flasher-hint');
                if (hintEl) hintEl.textContent = 'Select your board serial port in the browser picker.';
                waitTimer = window.setTimeout(() => {
                    const pill = document.getElementById('esp-flash-status-pill');
                    if (pill && !pill.classList.contains('ok') && !pill.classList.contains('err')) {
                        setEspFlashProgress({ phase: 'waiting_for_flasher_events', status: 'warn', percent: 12 });
                        if (hintEl) hintEl.textContent = 'Waiting for flasher events. If nothing changes, retry or use Local Flash.';
                    }
                }, 14000);
            });

            bind('state-changed', (ev) => {
                clearWaitTimer();
                const state = ev?.detail?.state || ev?.detail || 'in_progress';
                const next = phaseFromEspWebState(state);
                setEspFlashProgress(next);
                const hintEl = document.getElementById('web-flasher-hint');
                if (hintEl) hintEl.textContent = `Web flasher state: ${String(state)}`;
            });

            bind('error', (ev) => {
                clearWaitTimer();
                const msg = ev?.detail?.message || ev?.message || 'Unknown flash error';
                setEspFlashProgress({ phase: 'error', status: 'err', percent: 100 });
                const hintEl = document.getElementById('web-flasher-hint');
                if (hintEl) hintEl.textContent = `Flash error: ${msg}`;
            });

            bind('manifest-mismatch', () => {
                clearWaitTimer();
                setEspFlashProgress({ phase: 'manifest_mismatch', status: 'err', percent: 100 });
            });
        }

        async function refreshWebFlasher({ silent = false } = {}) {
            const panel = document.getElementById('web-flasher-panel');
            const install = document.getElementById('esp-web-install');
            const statusEl = document.getElementById('web-flasher-status');
            const hintEl = document.getElementById('web-flasher-hint');
            if (!panel || !install || !statusEl) return;

            const isEsp32 = selectedPlatform === 'esp32';
            const canShow = currentStep === FINAL_STEP && isEsp32;
            panel.style.display = canShow ? 'block' : 'none';
            if (!canShow) return;
            initEspWebInstallEvents();

            if (!window.isSecureContext) {
                install.style.display = 'none';
                statusEl.textContent = 'Web Serial requires secure context (use localhost or HTTPS).';
                setFlasherBadges({ secureContext: false });
                setEspFlashProgress({ phase: 'blocked_context', status: 'err', percent: 0 });
                if (hintEl) hintEl.textContent = 'Open from localhost/HTTPS to enable browser flashing.';
                return;
            }

            try {
                const status = await apiFetchJson('/api/flash/esp32/status');
                renderWebFlasherStatus(status);
                let anyBusy = null;
                try {
                    const ports = await apiFetchJson('/api/flash/esp32/ports');
                    if (Array.isArray(ports.ports) && ports.ports.length > 0) {
                        const statusEl = document.getElementById('web-flasher-status');
                        const lines = [statusEl.textContent || '', '', 'Serial ports:'];
                        ports.ports.forEach(p => {
                            lines.push(`- ${p.path}: ${p.busy ? 'BUSY' : 'free'}`);
                            if (p.busy && Array.isArray(p.holders)) {
                                p.holders.forEach(h => lines.push(`    ${h}`));
                            }
                        });
                        statusEl.textContent = lines.join('\n').trim();
                        anyBusy = !!ports.any_busy;
                    }
                } catch (_portErr) {
                    // Keep flasher usable even if host serial probe is unavailable.
                }
                if (status.ready) {
                    const boardRef = selectedBoard?.id ? `?board_id=${encodeURIComponent(selectedBoard.id)}&t=${Date.now()}` : `?t=${Date.now()}`;
                    install.setAttribute('manifest', `/api/flash/esp32/manifest${boardRef}`);
                    install.style.display = 'inline-block';
                    setFlasherBadges({ firmwareReady: true, portBusy: anyBusy, secureContext: true });
                    if (hintEl) {
                        hintEl.textContent = serialPort
                            ? 'Serial Terminal is connected. Disconnect it before flashing.'
                            : anyBusy
                            ? 'Serial appears busy. Release browser port lock, then Connect & Flash.'
                            : 'Ready. Click Connect & Flash and select the ESP32 USB serial device (COMx/ttyUSB*/ttyACM*).';
                    }
                    const pill = document.getElementById('esp-flash-status-pill');
                    if (pill && !pill.classList.contains('ok') && !pill.classList.contains('err') && (document.getElementById('esp-flash-progress')?.style.width || '0%') === '0%') {
                        setEspFlashProgress({ phase: 'ready', status: 'warn', percent: 2 });
                    }
                } else {
                    install.style.display = 'none';
                    setFlasherBadges({ firmwareReady: false, portBusy: anyBusy, secureContext: true });
                    setEspFlashProgress({ phase: 'artifacts_missing', status: 'err', percent: 0 });
                    if (hintEl) hintEl.textContent = 'Generate/build firmware artifacts first, then run check again.';
                }
            } catch (err) {
                install.style.display = 'none';
                statusEl.textContent = `Failed to load flash status: ${err.message || err}`;
                setFlasherBadges({ firmwareReady: null, portBusy: null, secureContext: true });
                setEspFlashProgress({ phase: 'status_error', status: 'err', percent: 0 });
                if (hintEl) hintEl.textContent = 'Status check failed. Verify backend server and retry.';
                if (!silent) notify(statusEl.textContent, 'error');
            }
        }

        async function releaseBrowserSerialPorts() {
            if (!('serial' in navigator) || !navigator.serial?.getPorts) {
                notify('Web Serial API unavailable in this browser.', 'warning');
                return;
            }
            try {
                const ports = await navigator.serial.getPorts();
                let closed = 0;
                for (const p of ports) {
                    try {
                        await p.close();
                        closed++;
                    } catch (_e) {
                        // Ignore; port may already be closed.
                    }
                }
                notify(`Released ${closed} browser serial port(s).`, 'success');
                const hintEl = document.getElementById('web-flasher-hint');
                if (hintEl) hintEl.textContent = 'Browser port handles released. Run check, then connect again.';
                await refreshWebFlasher({ silent: true });
            } catch (err) {
                notify(`Failed to release serial ports: ${err.message || err}`, 'error');
            }
        }

        async function localFlashEsp32() {
            if (serialPort) {
                notify('Disconnect Serial Terminal before flashing to avoid port conflicts.', 'warning');
                return;
            }
            const btn = document.getElementById('btn-local-flash');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Flashing...';
            }
            setEspFlashProgress({ phase: 'local_flash_start', status: 'active', percent: 10 });
            try {
                const resp = await fetch('/api/flash/esp32/local', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const raw = await resp.text();
                let data = null;
                try {
                    data = raw ? JSON.parse(raw) : null;
                } catch (_e) {
                    data = null;
                }

                if (!resp.ok || !data?.success) {
                    const msg = data?.error || data?.message || raw || `HTTP ${resp.status}`;
                    const details = data?.output || raw || '';
                    showInlineOutput(`Local flash failed: ${msg}\n\n${details}`.trim(), 'error');
                    notify(`Local flash failed: ${msg}`, 'error');
                    setEspFlashProgress({ phase: 'local_flash_failed', status: 'err', percent: 100 });
                    return;
                }

                const output = data?.output ? String(data.output) : '(no output)';
                showInlineOutput(`Local flash succeeded on ${data.port || '(unknown)'}:\n\n${output}`, 'success');
                notify('Local flash completed successfully.', 'success');
                setEspFlashProgress({ phase: 'local_flash_done', status: 'ok', percent: 100 });
            } catch (err) {
                const msg = `Local flash failed: ${err.message || err}`;
                showInlineOutput(msg, 'error');
                notify(msg, 'error');
                setEspFlashProgress({ phase: 'local_flash_error', status: 'err', percent: 100 });
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Local Flash (idf.py)';
                }
                refreshWebFlasher({ silent: true });
            }
        }

        function appendSerialLog(text) {
            const log = document.getElementById('serial-log');
            if (!log) return;
            log.textContent += String(text || '');
            log.scrollTop = log.scrollHeight;
        }

        function setSerialState(connected) {
            const pill = document.getElementById('serial-state-pill');
            if (!pill) return;
            pill.className = 'flash-status-pill';
            if (connected) {
                pill.classList.add('ok');
                pill.textContent = 'Connected';
            } else {
                pill.textContent = 'Disconnected';
            }
        }

        async function serialDisconnect() {
            serialReadAbort = true;
            try {
                if (serialReader) {
                    await serialReader.cancel();
                }
            } catch (_e) {}
            try {
                if (serialReader) serialReader.releaseLock();
            } catch (_e) {}
            serialReader = null;
            try {
                if (serialWriter) serialWriter.releaseLock();
            } catch (_e) {}
            serialWriter = null;
            try {
                if (serialPort) await serialPort.close();
            } catch (_e) {}
            serialPort = null;
            setSerialState(false);
        }

        async function serialReadLoop() {
            if (!serialPort?.readable) return;
            const decoder = new TextDecoder();
            serialReadAbort = false;
            try {
                while (!serialReadAbort) {
                    serialReader = serialPort.readable.getReader();
                    try {
                        while (!serialReadAbort) {
                            const { value, done } = await serialReader.read();
                            if (done) break;
                            if (value) appendSerialLog(decoder.decode(value, { stream: true }));
                        }
                    } finally {
                        try { serialReader.releaseLock(); } catch (_e) {}
                        serialReader = null;
                    }
                    if (serialReadAbort) break;
                    await new Promise(r => setTimeout(r, 20));
                }
            } catch (err) {
                appendSerialLog(`\n[serial] read error: ${err?.message || err}\n`);
            }
        }

        async function serialConnect() {
            if (!('serial' in navigator) || !navigator.serial?.requestPort) {
                notify('Web Serial API unavailable in this browser.', 'warning');
                return;
            }
            try {
                await serialDisconnect();
                const baud = parseInt(String(document.getElementById('serial-baud')?.value || '115200'), 10) || 115200;
                serialPort = await navigator.serial.requestPort({});
                await serialPort.open({ baudRate: baud });
                if (serialPort.writable) serialWriter = serialPort.writable.getWriter();
                setSerialState(true);
                appendSerialLog(`[serial] connected @ ${baud}\n`);
                serialReadLoop();
            } catch (err) {
                setSerialState(false);
                notify(`Serial connect failed: ${err.message || err}`, 'error');
            }
        }

        async function serialSendCommand() {
            if (!serialWriter) {
                notify('Serial is not connected.', 'warning');
                return;
            }
            const input = document.getElementById('serial-command');
            const cmd = String(input?.value || '');
            if (!cmd.trim()) return;
            try {
                const enc = new TextEncoder();
                await serialWriter.write(enc.encode(cmd + '\r\n'));
                appendSerialLog(`> ${cmd}\n`);
                if (input) input.value = '';
            } catch (err) {
                notify(`Serial send failed: ${err.message || err}`, 'error');
            }
        }

        function refreshSerialTerminalVisibility() {
            const panel = document.getElementById('serial-terminal-panel');
            if (!panel) return;
            const canShow = currentStep === FINAL_STEP && (selectedPlatform === 'esp32' || selectedPlatform === 'avr');
            panel.style.display = canShow ? 'block' : 'none';
        }

        function avrTargetSelected() {
            const targetId = selectedBoard?.target_profile || '';
            return selectedPlatform === 'avr' || targetId === 'mega2560' || targetId === 'atmega328p';
        }

        function defaultAvrSettingsFromBoard(board) {
            const defs = (board && board.defaults) ? board.defaults : {};
            const clock = defs.clock || {};
            const fuses = defs.fuses || {};
            const upload = defs.upload || {};
            return {
                clock: {
                    freq_hz: Number(clock.freq_hz || 16000000)
                },
                fuses: {
                    lfuse: String(fuses.lfuse || ''),
                    hfuse: String(fuses.hfuse || ''),
                    efuse: String(fuses.efuse || ''),
                    lock: String(fuses.lock || '')
                },
                upload: {
                    method: String(upload.method || 'bootloader'),
                    fqbn: String(upload.fqbn || 'arduino:avr:mega'),
                    mcu: String(upload.mcu || 'atmega2560'),
                    programmer: String(upload.programmer || 'wiring'),
                    baud: Number(upload.baud || 115200),
                    port: String(upload.port || '')
                }
            };
        }

        function setAvrAdvancedEditing(enabled) {
            const ids = ['avr-clock-hz', 'avr-fuse-l', 'avr-fuse-h', 'avr-fuse-e', 'avr-fuse-lock'];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.disabled = !enabled;
            });
            const warn = document.getElementById('avr-advanced-warning');
            if (warn) warn.style.display = enabled ? 'block' : 'none';
            const toggle = document.getElementById('avr-advanced-toggle');
            if (toggle && toggle.checked !== enabled) toggle.checked = enabled;
        }

        function isAvrAdvancedEditingEnabled() {
            const toggle = document.getElementById('avr-advanced-toggle');
            return !!toggle?.checked;
        }

        function restoreAvrDefaults() {
            if (!selectedBoard) return;
            avrSettings = defaultAvrSettingsFromBoard(selectedBoard);
            applyAvrSettingsToUi();
            setAvrAdvancedEditing(false);
            notify('AVR clock/fuse values restored to board defaults.', 'success');
        }

        function applyAvrSettingsToUi() {
            const panel = document.getElementById('avr-config-panel');
            if (panel) panel.style.display = avrTargetSelected() ? 'block' : 'none';
            if (!avrTargetSelected()) return;

            const setVal = (id, val) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.value = val ?? '';
            };
            setVal('avr-clock-hz', avrSettings.clock?.freq_hz ?? 16000000);
            setVal('avr-upload-method', avrSettings.upload?.method ?? 'bootloader');
            setVal('avr-fqbn', avrSettings.upload?.fqbn ?? 'arduino:avr:mega');
            setVal('avr-mcu', avrSettings.upload?.mcu ?? 'atmega2560');
            setVal('avr-programmer', avrSettings.upload?.programmer ?? 'wiring');
            setVal('avr-baud', avrSettings.upload?.baud ?? 115200);
            setVal('avr-port', avrSettings.upload?.port ?? '');
            setVal('avr-fuse-l', avrSettings.fuses?.lfuse ?? '');
            setVal('avr-fuse-h', avrSettings.fuses?.hfuse ?? '');
            setVal('avr-fuse-e', avrSettings.fuses?.efuse ?? '');
            setVal('avr-fuse-lock', avrSettings.fuses?.lock ?? '');
            // Keep terminal default baud aligned with AVR upload/runtime baud.
            const serialBaud = document.getElementById('serial-baud');
            if (serialBaud && !serialPort) {
                serialBaud.value = String(avrSettings.upload?.baud ?? 115200);
            }
            setAvrAdvancedEditing(isAvrAdvancedEditingEnabled());
        }

        function readAvrSettingsFromUi() {
            const readInt = (id, fallback) => {
                const el = document.getElementById(id);
                if (!el) return fallback;
                const n = parseInt(String(el.value || '').trim(), 10);
                return Number.isFinite(n) ? n : fallback;
            };
            const readStr = (id, fallback = '') => {
                const el = document.getElementById(id);
                if (!el) return fallback;
                const v = String(el.value || '').trim();
                return v || fallback;
            };

            const next = {
                clock: {
                    freq_hz: readInt('avr-clock-hz', 16000000),
                },
                fuses: {
                    lfuse: readStr('avr-fuse-l'),
                    hfuse: readStr('avr-fuse-h'),
                    efuse: readStr('avr-fuse-e'),
                    lock: readStr('avr-fuse-lock'),
                },
                upload: {
                    method: readStr('avr-upload-method', 'bootloader'),
                    fqbn: readStr('avr-fqbn', 'arduino:avr:mega'),
                    mcu: readStr('avr-mcu', 'atmega2560'),
                    programmer: readStr('avr-programmer', 'wiring'),
                    baud: readInt('avr-baud', 115200),
                    port: readStr('avr-port', ''),
                }
            };
            if (!isAvrAdvancedEditingEnabled() && selectedBoard) {
                const defs = defaultAvrSettingsFromBoard(selectedBoard);
                next.clock = defs.clock;
                next.fuses = defs.fuses;
                const setVal = (id, val) => {
                    const el = document.getElementById(id);
                    if (el) el.value = val ?? '';
                };
                setVal('avr-clock-hz', next.clock?.freq_hz ?? 16000000);
                setVal('avr-fuse-l', next.fuses?.lfuse ?? '');
                setVal('avr-fuse-h', next.fuses?.hfuse ?? '');
                setVal('avr-fuse-e', next.fuses?.efuse ?? '');
                setVal('avr-fuse-lock', next.fuses?.lock ?? '');
            }
            avrSettings = next;
            return next;
        }

        function renderAvrFlasherStatus(status) {
            const statusEl = document.getElementById('avr-flasher-status');
            if (!statusEl) return;
            if (!status) {
                statusEl.textContent = 'No AVR status available.';
                return;
            }
            const lines = [];
            if (status.error) lines.push(`Error: ${status.error}`);
            lines.push(`Ready: ${status.ready ? 'yes' : 'no'}`);
            if (status.board_id) lines.push(`Board: ${status.board_id}`);
            if (status.project_dir) lines.push(`Project: ${status.project_dir}`);
            if (status.meta?.board) lines.push(`FQBN: ${status.meta.board}`);
            if (status.meta?.upload_method) lines.push(`Method: ${status.meta.upload_method}`);
            statusEl.textContent = lines.join('\n');
        }

        function diagnoseAvrFailure(text, phase = 'build') {
            const src = String(text || '');
            const low = src.toLowerCase();
            const hints = [];
            const add = (msg) => { if (msg && !hints.includes(msg)) hints.push(msg); };

            if (low.includes('arduino-cli not found')) add('Install arduino-cli and ensure it is in PATH.');
            if (low.includes('avrdude not found')) add('Install avrdude and ensure it is in PATH.');
            if (low.includes('no serial port found') || low.includes('serial port not found')) {
                add('Select the correct COM/tty port, reconnect board, then retry.');
            }
            if (low.includes('permission denied') && (low.includes('/dev/tty') || low.includes('com'))) {
                add('Serial access denied: close other serial tools and check user permissions/groups.');
            }
            if (low.includes('programmer is not responding') || low.includes('stk500') || low.includes('not in sync')) {
                add('Bootloader/programmer mismatch: verify upload method and programmer settings for this board.');
            }
            if (low.includes('expected unqualified-id before') || low.includes('was not declared in this scope')) {
                add('C/C++ compile error in generated or custom source. Rebuild after fixing symbol/declaration scope issues.');
            }
            if (low.includes('no such file or directory')) {
                add('Missing include/source file. Verify generated project files and custom source paths.');
            }
            if (low.includes('error during build: exit status 1') || low.includes('compilation error')) {
                add('Compilation failed. Check the first compiler error line above for exact file:line cause.');
            }
            if (phase === 'flash' && hints.length === 0) {
                add('Flash failed. Verify port, upload method, baud/programmer, and board boot mode.');
            }
            if (phase === 'build' && hints.length === 0) {
                add('Build failed. Check full compiler output above for the first error line.');
            }
            return hints;
        }

        function renderAvrFailureReport({ phase = 'build', message = '', details = '' } = {}) {
            const full = `${message}\n${details}`.trim();
            const hints = diagnoseAvrFailure(full, phase);
            const statusEl = document.getElementById('avr-flasher-status');
            if (statusEl) {
                const lines = [`${phase === 'flash' ? 'Flash' : 'Build'} error: ${message || 'Unknown error'}`];
                if (hints.length > 0) {
                    lines.push('', 'Likely causes:');
                    hints.forEach((h, i) => lines.push(`  ${i + 1}. ${h}`));
                }
                lines.push('', 'Tip: open inline output above for full tool logs.');
                statusEl.textContent = lines.join('\n');
            }
            return hints;
        }

        function setAvrFlasherBadges(status) {
            const proj = document.getElementById('badge-avr-project');
            const tools = document.getElementById('badge-avr-tools');
            if (proj) {
                proj.className = 'web-flasher-badge';
                if (status?.ready) {
                    proj.classList.add('ok');
                    proj.textContent = `Project: ready (${status.board_id || 'avr'})`;
                } else {
                    proj.classList.add('warn');
                    proj.textContent = 'Project: generate required';
                }
            }
            if (tools) {
                tools.className = 'web-flasher-badge';
                const hasCli = !!status?.tools?.arduino_cli;
                const hasAvrdude = !!status?.tools?.avrdude;
                if (hasCli && hasAvrdude) {
                    tools.classList.add('ok');
                    tools.textContent = 'Tools: arduino-cli + avrdude';
                } else if (hasCli) {
                    tools.classList.add('warn');
                    tools.textContent = 'Tools: arduino-cli (avrdude missing)';
                } else {
                    tools.classList.add('err');
                    tools.textContent = 'Tools: missing';
                }
            }
        }

        async function refreshAvrFlasher({ silent = false } = {}) {
            const panel = document.getElementById('avr-flasher-panel');
            if (!panel) return;
            const canShow = currentStep === FINAL_STEP && avrTargetSelected();
            panel.style.display = canShow ? 'block' : 'none';
            if (!canShow) return;

            try {
                const bid = selectedBoard?.id ? `?board_id=${encodeURIComponent(selectedBoard.id)}` : '';
                const status = await apiFetchJson(`/api/flash/avr/status${bid}`);
                renderAvrFlasherStatus(status);
                setAvrFlasherBadges(status);
            } catch (err) {
                const statusEl = document.getElementById('avr-flasher-status');
                if (statusEl) statusEl.textContent = `Failed to load AVR status: ${err.message || err}`;
                setAvrFlasherBadges(null);
                if (!silent) notify(`AVR status failed: ${err.message || err}`, 'error');
            }
        }

        async function buildAvrFirmware() {
            const btn = document.getElementById('btn-build-avr');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Building...';
            }
            try {
                readAvrSettingsFromUi();
                const resp = await fetch('/api/build/avr', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        board_id: selectedBoard?.id || null,
                        upload: avrSettings.upload
                    })
                });
                const raw = await resp.text();
                let data = null;
                try { data = raw ? JSON.parse(raw) : null; } catch (_e) { data = null; }
                if (!resp.ok || !data?.success) {
                    const generic = data?.error || raw || `HTTP ${resp.status}`;
                    const detail = data?.error_detail ? ` ${data.error_detail}` : '';
                    const msg = `${generic}${detail}`.trim();
                    const details = data?.output || raw || '';
                    const hints = renderAvrFailureReport({ phase: 'build', message: msg, details });
                    const hintsBlock = hints.length ? `\n\nLikely causes:\n- ${hints.join('\n- ')}` : '';
                    showInlineOutput(`AVR build failed: ${msg}${hintsBlock}\n\n${details}`.trim(), 'error');
                    notify(`AVR build failed: ${msg}`, 'error', 6200);
                    return;
                }
                showInlineOutput(`AVR build succeeded (${data.fqbn || ''}).\n\n${data.output || ''}`.trim(), 'success');
                notify('AVR build completed.', 'success');
            } catch (err) {
                const msg = `AVR build failed: ${err.message || err}`;
                renderAvrFailureReport({ phase: 'build', message: msg, details: '' });
                showInlineOutput(msg, 'error');
                notify(msg, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Build AVR';
                }
                refreshAvrFlasher({ silent: true });
            }
        }

        async function localFlashAvr() {
            if (serialPort) {
                notify('Disconnect Serial Terminal before flashing to avoid port conflicts.', 'warning');
                return;
            }
            const btn = document.getElementById('btn-local-flash-avr');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Flashing...';
            }
            try {
                readAvrSettingsFromUi();
                const resp = await fetch('/api/flash/avr/local', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        board_id: selectedBoard?.id || null,
                        upload: {
                            ...avrSettings.upload,
                            fuses: avrSettings.fuses
                        },
                        port: avrSettings.upload?.port || ''
                    })
                });
                const raw = await resp.text();
                let data = null;
                try { data = raw ? JSON.parse(raw) : null; } catch (_e) { data = null; }
                if (!resp.ok || !data?.success) {
                    const msg = data?.error || raw || `HTTP ${resp.status}`;
                    const details = data?.flash_output || data?.compile_output || data?.output || raw || '';
                    const hints = renderAvrFailureReport({ phase: 'flash', message: msg, details });
                    const hintsBlock = hints.length ? `\n\nLikely causes:\n- ${hints.join('\n- ')}` : '';
                    showInlineOutput(`AVR flash failed: ${msg}${hintsBlock}\n\n${details}`.trim(), 'error');
                    notify(`AVR flash failed: ${msg}`, 'error');
                    return;
                }
                const details = [data.output, data.compile_output, data.flash_output].filter(Boolean).join('\n\n');
                showInlineOutput(`AVR flash succeeded (${data.method || 'avr'} ${data.port || ''}).\n\n${details}`.trim(), 'success');
                notify('AVR flash completed.', 'success');
                appendSerialLog(`[avr] flash complete. Connect Serial Terminal and run 'help' to validate shell/runtime.\n`);
            } catch (err) {
                const msg = `AVR flash failed: ${err.message || err}`;
                renderAvrFailureReport({ phase: 'flash', message: msg, details: '' });
                showInlineOutput(msg, 'error');
                notify(msg, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Flash AVR';
                }
                refreshAvrFlasher({ silent: true });
            }
        }

        async function apiFetchJson(url, options = {}) {
            const fetchOptions = {
                cache: 'no-store',
                ...options,
            };
            const resp = await fetch(url, fetchOptions);
            const raw = await resp.text();
            let payload = null;
            try {
                payload = raw ? JSON.parse(raw) : null;
            } catch (_e) {
                payload = null;
            }
            if (!resp.ok) {
                const msg = payload?.error || payload?.message || raw || `HTTP ${resp.status}`;
                throw new Error(msg);
            }
            return payload;
        }

        function showPlatformError(msg) {
            const errorEl = document.getElementById('platform-load-error');
            if (!errorEl) return;
            errorEl.style.display = 'block';
            errorEl.textContent = msg;
            notify(msg, 'error', 5200);
        }

        function refreshDIYPlatformOptions() {
            const sel = document.getElementById('diy-platform');
            if (!sel) return;
            sel.innerHTML = '';
            (platforms || []).forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = p.name || p.id;
                sel.appendChild(opt);
            });
            if (selectedPlatform) sel.value = selectedPlatform;
        }

        function openDIYBoardModal() {
            refreshDIYPlatformOptions();
            const modal = document.getElementById('diy-board-modal');
            if (modal) modal.classList.add('active');
            const defaultCaps = ['gpio', 'uart', 'spi', 'i2c'];
            const capsEl = document.getElementById('diy-capabilities');
            if (capsEl && !capsEl.value.trim()) capsEl.value = defaultCaps.join(',');
        }

        function closeDIYBoardModal() {
            const modal = document.getElementById('diy-board-modal');
            if (modal) modal.classList.remove('active');
        }

        function parseDIYBoardPins(text) {
            const out = {};
            String(text || '')
                .split('\n')
                .map(x => x.trim())
                .filter(Boolean)
                .forEach(line => {
                    const ix = line.indexOf('=');
                    if (ix <= 0) return;
                    const key = line.slice(0, ix).trim();
                    const raw = line.slice(ix + 1).trim();
                    if (!key || !raw) return;
                    const n = Number(raw);
                    out[key] = Number.isFinite(n) && String(n) === raw ? n : raw;
                });
            return out;
        }

        async function saveDIYBoard() {
            const payload = {
                platform: String(document.getElementById('diy-platform')?.value || '').trim(),
                id: String(document.getElementById('diy-id')?.value || '').trim(),
                name: String(document.getElementById('diy-name')?.value || '').trim(),
                description: String(document.getElementById('diy-description')?.value || '').trim(),
                mcu: String(document.getElementById('diy-mcu')?.value || '').trim(),
                flash: String(document.getElementById('diy-flash')?.value || '').trim(),
                ram: String(document.getElementById('diy-ram')?.value || '').trim(),
                display: String(document.getElementById('diy-display')?.value || '').trim(),
                target_profile: String(document.getElementById('diy-target-profile')?.value || '').trim(),
                capabilities: String(document.getElementById('diy-capabilities')?.value || '')
                    .split(',')
                    .map(x => x.trim().toLowerCase())
                    .filter(Boolean),
                pins: parseDIYBoardPins(document.getElementById('diy-pins')?.value || ''),
            };

            const btn = document.getElementById('btn-save-diy-board');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Saving...';
            }
            try {
                const data = await apiFetchJson('/api/boards/custom', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                if (!data?.success) throw new Error(data?.error || 'Failed to save board');

                const platform = payload.platform || selectedPlatform;
                boardsAll[platform] = cloneBoardRows(await apiFetchJson(`/api/boards/${platform}`));
                boardApiFilterCache = {};
                boards[platform] = cloneBoardRows(boardsAll[platform]);
                if (selectedPlatform !== platform) {
                    selectedPlatform = platform;
                    const platformSelect = document.getElementById('platform-select');
                    if (platformSelect) platformSelect.value = platform;
                    await refreshModulesForPlatform(selectedPlatform);
                    await refreshMarketCatalogForPlatform(selectedPlatform);
                }
                await refreshTaxonomyOptionsFromApi().catch(err => {
                    console.warn('Failed to refresh taxonomy options:', err);
                    taxonomyOptions = null;
                });
                await refreshBoardsForCurrentFilters({ force: true });
                populateBoardList();
                const created = (boards[platform] || []).find(b => String(b.id) === String(payload.id));
                if (created) await selectBoard(created);
                closeDIYBoardModal();
                notify(`Custom board saved: ${payload.id}`, 'success');
            } catch (err) {
                notify(`DIY board save failed: ${err.message || err}`, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Save Custom Board';
                }
            }
        }

        window.addEventListener('error', (e) => {
            showPlatformError(`UI error: ${e.message}`);
        });

        // Data structures
        let platforms = [];
        let boards = {};
        let boardsAll = {};
        let boardApiFilterCache = {};
        let boardApiRequestSeq = 0;
        let modules = [];
        let applets = [];
        let appletStates = {};
        let marketApps = [];
        let marketAppStates = {};
        let marketCatalog = [];
        let targets = {};
        let boardDetails = {};
        let moduleConfigs = {};
        let projectTemplates = [];
        let activeTemplateId = null;
        let configuratorVisible = false;
        let driverView = 'essential';
        let issuesPopoverHideTimer = null;
        let boardSearchDebounceTimer = null;
        const BOARD_VIRTUAL_ROW_THRESHOLD = 180;
        const BOARD_VIRTUAL_OVERSCAN_PX = 360;
        const BOARD_VIRTUAL_GROUP_ROW_H = 34;
        const BOARD_VIRTUAL_ITEM_ROW_H = 58;
        let boardVirtualEnabled = false;
        let boardVirtualRows = [];
        let boardVirtualOffsets = [];
        let boardVirtualTotalHeight = 0;
        let boardVirtualItemCount = 0;
        let boardVirtualRafId = 0;
        let boardPerfEnabled = false;
        let boardLastRenderMs = 0;
        let boardKeyboardFlatItems = [];
        let boardKeyboardIndex = -1;

        const MODULE_ICONS = {
            uart: '📡',
            spi: '🔄',
            i2c: '↔️',
            tft: '🖥️',
            display_ssd1306: '🟦',
            fs_spiffs: '💾',
            fs_sd: '💿',
            wifi: '📶',
            bluetooth: '📘',
            twai: '🛞',
            rtc: '⏰',
            imu: '🧭',
            dht22: '🌡️',
            mic: '🎙️',
            ads1115: '📈',
            mcp23017: '🧩',
            mcp2544fd: '🚘',
            uln2003: '🌀',
            l298n: '⚙️',
            hp4067: '🎚️',
            tp4056: '🔋',
            shell_full: '⌨️',
            shell_min: '⌨️',
            shell_tiny: '⌨️',
            psram: '🧠'
        };

        const APPLET_META = {
            blink: { name: 'Blink', description: 'Toggle a pin/LED repeatedly.', icon: '💡' },
            uart_echo: { name: 'UART Echo', description: 'Echo bytes over UART.', icon: '🛰️' },
            remote_node: { name: 'Remote Node', description: 'Simple UART remote node protocol.', icon: '📡' },
            system_info: { name: 'System Info', description: 'Print board, memory, and runtime status at startup.', icon: '📋' },
            tft_hello: { name: 'TFT Hello', description: 'Render a basic hello/status screen on TFT.', icon: '🖥️', requires_capabilities: ['tft'] },
            sd_probe: { name: 'SD Probe', description: 'Check SD mount and list top-level files.', icon: '💿', requires_capabilities: ['sd_card'] },
            fs_smoke: { name: 'FS Smoke', description: 'Create/read/remove test file in storage.', icon: '🧪' },
            i2c_scan: { name: 'I2C Scan', description: 'Scan I2C bus for attached devices.', icon: '🔎', requires_capabilities: ['i2c'] },
            wifi_status: { name: 'WiFi Status', description: 'Show Wi-Fi status and station metadata.', icon: '📶', requires_capabilities: ['wifi'] }
        };

        const PLATFORM_APPLETS = {
            esp32: ['blink', 'system_info', 'tft_hello', 'fs_smoke', 'sd_probe', 'i2c_scan', 'wifi_status']
        };

        let moduleSectionState = {};

        function getModuleIcon(moduleId) {
            return MODULE_ICONS[moduleId] || '📦';
        }

        function getAppletMeta(appletId) {
            return APPLET_META[appletId] || { name: appletId, description: '', icon: '🧩' };
        }

        function appletAllowedByBoard(appletId, board) {
            const meta = getAppletMeta(appletId);
            const req = Array.isArray(meta.requires_capabilities) ? meta.requires_capabilities : [];
            if (req.length === 0) return true;
            const caps = new Set((board?.capabilities || []).map(x => String(x)));
            return req.every(c => caps.has(c));
        }

        function availableAppletsForBoard(board) {
            const targetId = board?.target_profile;
            const target = targetId ? targets[targetId] : null;
            const fromTarget = Array.isArray(target?.applets) ? target.applets : [];
            if (fromTarget.length > 0) {
                return fromTarget.filter(a => appletAllowedByBoard(a, board));
            }
            const platformId = board?.platform || selectedPlatform;
            const fromPlatform = Array.isArray(PLATFORM_APPLETS[platformId]) ? PLATFORM_APPLETS[platformId] : [];
            return fromPlatform.filter(a => appletAllowedByBoard(a, board));
        }

        function availableMarketAppsForBoard(board) {
            const platformId = board?.platform || selectedPlatform;
            const caps = new Set((board?.capabilities || []).map(x => String(x)));
            return marketCatalog.filter(item => {
                const plats = Array.isArray(item.platforms) ? item.platforms : [];
                if (!(plats.length === 0 || plats.includes(platformId))) return false;
                const req = Array.isArray(item.requires_capabilities) ? item.requires_capabilities.map(x => String(x)) : [];
                if (req.length > 0 && req.some(cap => !caps.has(cap))) return false;
                return true;
            });
        }

        function normalizeDriverId(raw) {
            const value = String(raw || '').trim().toLowerCase().replace(/-/g, '_');
            const aliases = {
                shell_mini: 'shell_tiny',
                fs: 'fs_spiffs'
            };
            return aliases[value] || value;
        }

        function boardDefaultDriverIds(board) {
            if (!board) return [];
            const fromBoard = Array.isArray(board?.defaults?.modules) ? board.defaults.modules : [];
            const normalizedBoard = fromBoard.map(normalizeDriverId).filter(Boolean);
            if (normalizedBoard.length > 0) {
                return Array.from(new Set(normalizedBoard));
            }

            const defaults = new Set();
            const caps = new Set(Array.isArray(board.capabilities) ? board.capabilities.map(x => String(x)) : []);
            const targetId = String(board?.target_profile || '').toLowerCase();
            const plat = String(board?.platform || selectedPlatform || '').toLowerCase();
            const isAvrLike = plat === 'avr' || plat === 'atmega' || ['mega2560', 'atmega328p', 'atmega32u4'].includes(targetId);

            if (caps.has('spi')) defaults.add('spi');
            if (caps.has('uart')) defaults.add('uart');
            if (caps.has('tft')) defaults.add('tft');
            defaults.add('fs_spiffs');
            if (caps.has('psram')) defaults.add('psram');
            if (caps.has('uart')) defaults.add(isAvrLike ? 'shell_tiny' : 'shell_full');
            return Array.from(defaults);
        }

        function applyBoardAndTemplateDefaults(board, template = null) {
            const selected = new Set(boardDefaultDriverIds(board));
            if (template && typeof template === 'object') {
                templateEnabledDrivers(template).forEach(id => {
                    const norm = normalizeDriverId(id);
                    if (norm) selected.add(norm);
                });
            }

            modules.forEach(module => {
                const enabled = selected.has(module.id);
                module.enabled = enabled;
                moduleStates[module.id] = enabled;
            });
        }

        const MEMORY_BASE_COST = {
            esp32: { prog: 420 * 1024, ram: 64 * 1024, data: 64 * 1024 },
            avr: { prog: 5 * 1024, ram: 384, data: 0 },
            atmega: { prog: 5 * 1024, ram: 384, data: 0 },
            pic16: { prog: 3 * 1024, ram: 256, data: 0 },
            rp2040: { prog: 28 * 1024, ram: 6 * 1024, data: 0 },
            stm32: { prog: 40 * 1024, ram: 8 * 1024, data: 0 },
            atsam: { prog: 44 * 1024, ram: 8 * 1024, data: 0 },
            renesas_ra: { prog: 56 * 1024, ram: 10 * 1024, data: 0 },
            renesas_rx: { prog: 72 * 1024, ram: 12 * 1024, data: 0 },
            "linux-sbc": { prog: 8 * 1024 * 1024, ram: 4 * 1024 * 1024, data: 16 * 1024 * 1024 }
        };

        const BOARD_MEMORY_BASE_OVERRIDES = {
            cyd: { prog: 460 * 1024, ram: 72 * 1024, data: 64 * 1024 },
            m5stickc_plus2: { prog: 430 * 1024, ram: 70 * 1024, data: 64 * 1024 },
            esp32_devkitc_v4: { prog: 410 * 1024, ram: 58 * 1024, data: 48 * 1024 },
            mega2560: { prog: 6 * 1024, ram: 512, data: 0 },
            arduino_pro_micro_5v_usbc: { prog: 5 * 1024, ram: 420, data: 0 },
            arduino_uno_r3: { prog: 4 * 1024, ram: 320, data: 0 },
            arduino_nano_v3: { prog: 4 * 1024, ram: 320, data: 0 },
            raspberry_pi_pico: { prog: 24 * 1024, ram: 5 * 1024, data: 0 },
            raspberry_pi_pico_w: { prog: 28 * 1024, ram: 6 * 1024, data: 0 },
            adafruit_feather_rp2040: { prog: 30 * 1024, ram: 6 * 1024, data: 0 },
            nucleo_f401re: { prog: 38 * 1024, ram: 8 * 1024, data: 0 },
            nucleo_f446re: { prog: 40 * 1024, ram: 8 * 1024, data: 0 },
            blackpill_f411ce: { prog: 36 * 1024, ram: 8 * 1024, data: 0 }
        };

        const DRIVER_MEMORY_COST = {
            gpio: { prog: 2 * 1024, ram: 256 },
            uart: { prog: 8 * 1024, ram: 1024 },
            spi: { prog: 6 * 1024, ram: 640 },
            i2c: { prog: 6 * 1024, ram: 640 },
            adc: { prog: 4 * 1024, ram: 384 },
            pwm: { prog: 3 * 1024, ram: 256 },
            timer: { prog: 3 * 1024, ram: 256 },
            eeprom: { prog: 2 * 1024, ram: 128 },
            fs_spiffs: { prog: 24 * 1024, ram: 2 * 1024, data: 24 * 1024 },
            fs_sd: { prog: 26 * 1024, ram: 2 * 1024 },
            tft: { prog: 90 * 1024, ram: 20 * 1024 },
            display_ssd1306: { prog: 14 * 1024, ram: 2 * 1024 },
            shell_full: { prog: 44 * 1024, ram: 6 * 1024 },
            shell_min: { prog: 20 * 1024, ram: 3 * 1024 },
            shell_tiny: { prog: 10 * 1024, ram: 1536 },
            remote_node: { prog: 9 * 1024, ram: 1 * 1024 },
            wifi: { prog: 140 * 1024, ram: 36 * 1024 },
            bluetooth: { prog: 170 * 1024, ram: 40 * 1024 },
            twai: { prog: 18 * 1024, ram: 3 * 1024 },
            rtc: { prog: 6 * 1024, ram: 1024 },
            imu: { prog: 8 * 1024, ram: 1024 },
            dht22: { prog: 4 * 1024, ram: 512 },
            mic: { prog: 10 * 1024, ram: 4 * 1024 },
            ads1115: { prog: 8 * 1024, ram: 1024 },
            mcp23017: { prog: 7 * 1024, ram: 768 },
            mcp2544fd: { prog: 5 * 1024, ram: 512 },
            uln2003: { prog: 6 * 1024, ram: 640 },
            l298n: { prog: 6 * 1024, ram: 640 },
            hp4067: { prog: 5 * 1024, ram: 512 },
            tp4056: { prog: 4 * 1024, ram: 384 },
            psram: { prog: 2 * 1024, ram: 128 }
        };

        // AVR/ATmega cost model tuned from observed arduino-cli outputs.
        const DRIVER_MEMORY_COST_AVR = {
            gpio: { prog: 128, ram: 24 },
            uart: { prog: 1024, ram: 180 },
            spi: { prog: 420, ram: 64 },
            i2c: { prog: 480, ram: 72 },
            adc: { prog: 220, ram: 24 },
            pwm: { prog: 180, ram: 20 },
            timer: { prog: 220, ram: 32 },
            eeprom: { prog: 260, ram: 28 },
            display_ssd1306: { prog: 1400, ram: 220 },
            shell_full: { prog: 3600, ram: 720 },
            shell_min: { prog: 2200, ram: 460 },
            shell_tiny: { prog: 1200, ram: 260 },
            remote_node: { prog: 520, ram: 96 },
            rtc: { prog: 680, ram: 84 },
            imu: { prog: 820, ram: 96 },
            dht22: { prog: 900, ram: 84 },
            ads1115: { prog: 760, ram: 92 },
            mcp23017: { prog: 720, ram: 78 },
            mcp2544fd: { prog: 0, ram: 0 },
            uln2003: { prog: 320, ram: 40 },
            l298n: { prog: 320, ram: 40 },
            hp4067: { prog: 360, ram: 40 },
            tp4056: { prog: 320, ram: 36 },
            wifi: { prog: 0, ram: 0 },
            bluetooth: { prog: 0, ram: 0 },
            twai: { prog: 0, ram: 0 },
            fs_spiffs: { prog: 0, ram: 0, data: 0 },
            fs_sd: { prog: 0, ram: 0, data: 0 },
            tft: { prog: 0, ram: 0, data: 0 },
            mic: { prog: 0, ram: 0 },
            psram: { prog: 0, ram: 0 }
        };

        const APPLET_MEMORY_COST = {
            default: { prog: 3 * 1024, ram: 512, data: 2 * 1024 },
            paint: { prog: 8 * 1024, ram: 2 * 1024, data: 10 * 1024 },
            flappy_bird: { prog: 12 * 1024, ram: 3 * 1024, data: 12 * 1024 }
        };
        const APPLET_MEMORY_COST_AVR = {
            default: { prog: 700, ram: 96, data: 64 },
            paint: { prog: 0, ram: 0, data: 0 }
        };

        function parseSizeToBytes(text, fallback = 0) {
            const raw = String(text || '').toLowerCase().replace(/,/g, '');
            const m = raw.match(/(\d+(?:\.\d+)?)\s*(gb|gib|mb|mib|kb|kib|b)\b/);
            if (!m) return fallback;
            const value = Number(m[1]);
            const unit = m[2];
            if (!Number.isFinite(value)) return fallback;
            const scale = unit.startsWith('g') ? 1024 ** 3 : unit.startsWith('m') ? 1024 ** 2 : unit.startsWith('k') ? 1024 : 1;
            return Math.round(value * scale);
        }

        function formatBytes(bytes) {
            const b = Number(bytes || 0);
            if (!Number.isFinite(b) || b <= 0) return '0 B';
            if (b >= 1024 ** 2) return `${(b / (1024 ** 2)).toFixed(2)} MB`;
            if (b >= 1024) return `${(b / 1024).toFixed(1)} KB`;
            return `${Math.round(b)} B`;
        }

        function capacityModelForBoard(board) {
            const platformId = String(board?.platform || selectedPlatform || '').toLowerCase();
            const boardId = String(board?.id || '').toLowerCase();
            const targetId = String(board?.target_profile || '').toLowerCase();
            const target = targetId ? targets[targetId] : null;
            const base = {
                ...(MEMORY_BASE_COST[platformId] || { prog: 96 * 1024, ram: 16 * 1024, data: 0 }),
                ...(BOARD_MEMORY_BASE_OVERRIDES[boardId] || {})
            };

            const flashCap = parseSizeToBytes(board?.flash, 0);
            const ramCap = parseSizeToBytes(board?.ram, 0);
            const targetCaps = target?.capabilities || {};
            let progCap = Number(targetCaps.max_flash_bytes || 0) || (flashCap > 0 ? flashCap : 0);
            let ramCapFinal = Number(targetCaps.max_ram_bytes || 0) || ramCap;
            let dataCap = 0;
            if (platformId === 'esp32') {
                // Typical BasaltOS partitioning: ~1.94MB app + ~1.94MB storage on 4MB flash.
                progCap = progCap || (0x1F0000);
                dataCap = 0x1F0000;
            } else if (platformId === 'avr' || platformId === 'atmega' || platformId === 'pic16') {
                // 8-bit targets generally treat data flash separately (EEPROM/etc.), keep data partition at zero.
                dataCap = 0;
            } else if (platformId === 'linux-sbc') {
                // Planning model only.
                progCap = progCap || (256 * 1024 * 1024);
                ramCapFinal = ramCapFinal || (512 * 1024 * 1024);
                dataCap = Math.max(dataCap, 128 * 1024 * 1024);
            } else if (progCap > 0) {
                const totalFlash = progCap;
                progCap = Math.round(totalFlash * 0.9);
                dataCap = Math.round(totalFlash * 0.1);
            }
            return {
                platformId,
                base,
                caps: { prog: progCap, ram: ramCapFinal, data: dataCap }
            };
        }

        function estimateMemoryUsage() {
            const board = selectedBoard || {};
            const model = capacityModelForBoard(board);
            const usage = { prog: model.base.prog, ram: model.base.ram, data: model.base.data };
            const base = { ...model.base };
            const isAvr = model.platformId === 'avr' || model.platformId === 'atmega';
            const driverCost = isAvr ? DRIVER_MEMORY_COST_AVR : DRIVER_MEMORY_COST;
            const appletCost = isAvr ? APPLET_MEMORY_COST_AVR : APPLET_MEMORY_COST;

            modules.filter(m => m.enabled).forEach(m => {
                const c = driverCost[m.id] || {};
                usage.prog += Number(c.prog || 0);
                usage.ram += Number(c.ram || 0);
                usage.data += Number(c.data || 0);
            });

            applets.filter(a => appletStates[a]).forEach(a => {
                const c = appletCost[a] || appletCost.default;
                usage.prog += Number(c.prog || 0);
                usage.ram += Number(c.ram || 0);
                usage.data += Number(c.data || 0);
            });

            marketCatalog
                .filter(item => marketAppStates[item.id])
                .forEach(item => {
                    const srcSize = Number(item.source_size_bytes || 0);
                    const c = appletCost[item.id] || appletCost.default;
                    usage.prog += Math.round(Number(c.prog || 0) * 0.4);
                    usage.ram += Math.round(Number(c.ram || 0) * 0.5);
                    usage.data += srcSize > 0 ? srcSize : Number(c.data || 0);
                });

            return { usage, base, caps: model.caps, platformId: model.platformId };
        }

        function memoryRowHtml(label, used, cap, kind = 'prog') {
            const pct = cap > 0 ? Math.min(100, Math.round((used / cap) * 100)) : 0;
            const cls = pct >= 90 ? 'err' : pct >= 75 ? 'warn' : '';
            const suffix = cap > 0 ? `${formatBytes(used)} / ${formatBytes(cap)} (${pct}%)` : `${formatBytes(used)} / n/a`;
            return `
                <div class="memory-row">
                    <div class="memory-head">
                        <span>${label}</span>
                        <span>${suffix}</span>
                    </div>
                    <div class="memory-track">
                        <div class="memory-fill ${cls}" style="width:${cap > 0 ? pct : 8}%"></div>
                    </div>
                </div>
            `;
        }

        function updateMemoryEstimatePanels() {
            const panel = document.getElementById('memory-estimate-panel');
            const summaryPanel = document.getElementById('memory-summary-panel');
            const step1Panel = document.getElementById('memory-step1-panel');
            const step3Panel = document.getElementById('memory-step3-panel');
            const allPanels = [panel, summaryPanel, step1Panel, step3Panel].filter(Boolean);
            if (allPanels.length === 0) return;
            if (!selectedBoard) {
                const html = '<div class="memory-note">Select a board to view memory estimates.</div>';
                allPanels.forEach(p => { p.innerHTML = html; });
                updateStepGuidance();
                return;
            }

            const { usage, base, caps } = estimateMemoryUsage();
            const added = {
                prog: Math.max(0, usage.prog - (base.prog || 0)),
                ram: Math.max(0, usage.ram - (base.ram || 0)),
                data: Math.max(0, usage.data - (base.data || 0))
            };
            const html = `
                <div class="memory-note">Estimated usage while configuring (pre-build). Target/board-aware caps are applied when available. Exact values come from compiler output.</div>
                <div class="memory-note">
                    Baseline firmware overhead: Prog ${formatBytes(base.prog)}, RAM ${formatBytes(base.ram)}, Data ${formatBytes(base.data)}.
                    Added by selected drivers/apps: Prog ${formatBytes(added.prog)}, RAM ${formatBytes(added.ram)}, Data ${formatBytes(added.data)}.
                </div>
                ${memoryRowHtml('Program Flash', usage.prog, caps.prog, 'prog')}
                ${memoryRowHtml('Data Flash (apps/storage)', usage.data, caps.data, 'data')}
                ${memoryRowHtml('RAM', usage.ram, caps.ram, 'ram')}
            `;
            allPanels.forEach(p => { p.innerHTML = html; });
            updateStepGuidance();
        }

        function updateTopProfileChip() {
            // Profile chip UI was removed for local-scope mode.
        }

        function updateLandingStats() {
            const platformCount = document.getElementById('stat-platforms');
            const boardCount = document.getElementById('stat-boards');
            const platformTotal = Array.isArray(platforms) ? platforms.length : 0;
            const boardTotal = Object.values(boards || {}).reduce((sum, list) => {
                return sum + (Array.isArray(list) ? list.length : 0);
            }, 0);
            if (platformCount) platformCount.textContent = String(platformTotal);
            if (boardCount) boardCount.textContent = String(boardTotal);
        }

        function applyLocalScopeMode() {
            // Intentionally empty: platform-scope UI is removed from local configurator markup.
        }

        function showLanding() {
            configuratorVisible = false;
            const landing = document.getElementById('landing-home');
            const shell = document.getElementById('configurator-shell');
            if (landing) landing.style.display = 'block';
            if (shell) shell.style.display = 'none';
            updateResumeCta();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function enterConfigurator(step = null) {
            configuratorVisible = true;
            const landing = document.getElementById('landing-home');
            const shell = document.getElementById('configurator-shell');
            if (landing) landing.style.display = 'none';
            if (shell) shell.style.display = 'block';
            if (typeof step === 'number' && step >= 1 && step <= FINAL_STEP) {
                currentStep = step;
            }
            updateWizardSteps();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function starterCatalogForMarket() {
            const fromPlatform = Array.isArray(PLATFORM_APPLETS[selectedPlatform]) ? PLATFORM_APPLETS[selectedPlatform] : [];
            return fromPlatform.filter(Boolean);
        }

        function starterAllowedForCurrentBuild(appId) {
            if (!selectedBoard) return false;
            const allowed = new Set(availableAppletsForBoard(selectedBoard));
            return allowed.has(String(appId));
        }

        function marketAllowedForCurrentBuild(appId) {
            if (!selectedBoard) return false;
            const allowed = new Set(availableMarketAppsForBoard(selectedBoard).map(x => x.id));
            return allowed.has(String(appId));
        }

        function renderSelectedAppsVisibility() {
            const wrap = document.getElementById('selected-apps-visibility');
            if (!wrap) return;
            const selectedStarter = applets.filter(a => appletStates[a]);
            const selectedMarket = marketApps.filter(a => marketAppStates[a]);
            wrap.innerHTML = `
                <div class="validation-item info">
                    <span class="validation-icon">📦</span>
                    <div><strong>Starter Apps:</strong> ${selectedStarter.length ? selectedStarter.join(', ') : '(none)'}</div>
                </div>
                <div class="validation-item info">
                    <span class="validation-icon">🛒</span>
                    <div><strong>Catalog Apps:</strong> ${selectedMarket.length ? selectedMarket.join(', ') : '(none)'}</div>
                </div>
            `;
            updateMemoryEstimatePanels();
        }

        function renderRuntimeOptionsPanel() {
            const appletWrap = document.getElementById('runtime-applets-list');
            const marketWrap = document.getElementById('runtime-market-apps-list');
            if (!appletWrap || !marketWrap) return;
            if (!selectedBoard) {
                appletWrap.innerHTML = '<div class="validation-item info"><span class="validation-icon">ℹ️</span><div>Select a board to configure runtime options.</div></div>';
                marketWrap.innerHTML = '<div class="validation-item info"><span class="validation-icon">ℹ️</span><div>Select a board to configure runtime options.</div></div>';
                return;
            }

            const starter = availableAppletsForBoard(selectedBoard);
            if (starter.length === 0) {
                appletWrap.innerHTML = '<div class="validation-item info"><span class="validation-icon">ℹ️</span><div>No starter applets available for this board.</div></div>';
            } else {
                appletWrap.innerHTML = starter.map((id) => {
                    const meta = getAppletMeta(id);
                    const checked = !!appletStates[id];
                    return `
                        <label style="display:flex; gap:8px; align-items:flex-start; padding:8px 0; border-bottom:1px solid #e2e8f0;">
                            <input type="checkbox" data-runtime-applet="${id}" ${checked ? 'checked' : ''}>
                            <span><strong>${meta.icon || '🧩'} ${meta.name}</strong><br><span style="font-size:12px; color:#64748b;">${meta.description || ''}</span></span>
                        </label>
                    `;
                }).join('');
            }

            const market = availableMarketAppsForBoard(selectedBoard);
            if (market.length === 0) {
                marketWrap.innerHTML = '<div class="validation-item info"><span class="validation-icon">ℹ️</span><div>No market apps available for this board/platform in local mode.</div></div>';
            } else {
                marketWrap.innerHTML = market.map((item) => {
                    const checked = !!marketAppStates[item.id];
                    const desc = String(item.description || item.summary || '').trim();
                    return `
                        <label style="display:flex; gap:8px; align-items:flex-start; padding:8px 0; border-bottom:1px solid #e2e8f0;">
                            <input type="checkbox" data-runtime-market="${item.id}" ${checked ? 'checked' : ''}>
                            <span><strong>🛒 ${item.id}</strong><br><span style="font-size:12px; color:#64748b;">${desc || 'Catalog app'}</span></span>
                        </label>
                    `;
                }).join('');
            }

            appletWrap.querySelectorAll('input[data-runtime-applet]').forEach((input) => {
                input.addEventListener('change', () => {
                    const id = input.getAttribute('data-runtime-applet');
                    if (!id) return;
                    appletStates[id] = !!input.checked;
                    renderSelectedAppsVisibility();
                    updateValidation();
                });
            });
            marketWrap.querySelectorAll('input[data-runtime-market]').forEach((input) => {
                input.addEventListener('change', () => {
                    const id = input.getAttribute('data-runtime-market');
                    if (!id) return;
                    marketAppStates[id] = !!input.checked;
                    renderSelectedAppsVisibility();
                    updateValidation();
                });
            });
        }

        function isAdvancedPinConfigOpen() {
            const advanced = document.getElementById('advanced-pin-config');
            return !!(advanced && advanced.open);
        }

        const PLATFORM_MANUFACTURER = {
            esp32: 'Espressif',
            avr: 'Microchip',
            atmega: 'Microchip',
            pic16: 'Microchip',
            rp2040: 'Raspberry Pi',
            stm32: 'STMicroelectronics',
            atsam: 'Microchip',
            renesas_ra: 'Renesas',
            renesas_rx: 'Renesas',
            'linux-sbc': 'Linux SBC'
        };

        const PREFERRED_MANUFACTURERS = [
            'Adafruit',
            'DF Robot',
            'Elecrow',
            'Seeed Studio',
            'SparkFun'
        ];

        const PLATFORM_ARCHITECTURE = {
            avr: 'AVR 8-bit',
            atmega: 'AVR 8-bit',
            pic16: 'PIC 8-bit',
            stm32: 'ARM Cortex-M',
            atsam: 'ARM Cortex-M',
            rp2040: 'ARM Cortex-M0+',
            renesas_ra: 'ARM Cortex-M',
            renesas_rx: 'Renesas RX 32-bit',
            'linux-sbc': 'Linux Host'
        };

        function mcuFamilyLabel(mcu, platform) {
            const text = String(mcu || '').toUpperCase();
            const plat = String(platform || '').toLowerCase();
            if (plat === 'esp32') {
                if (text.includes('C6')) return 'ESP32-C6';
                if (text.includes('C3')) return 'ESP32-C3';
                if (text.includes('S3')) return 'ESP32-S3';
                if (text.includes('S2')) return 'ESP32-S2';
                return 'ESP32';
            }
            if (plat === 'stm32') {
                const m = text.match(/STM32([A-Z]\d)/);
                if (m) return `STM32${m[1]}`;
                if (text.includes('STM32')) return 'STM32';
            }
            if (plat === 'rp2040') return 'RP2040';
            if (plat === 'atsam') {
                if (text.includes('SAMD21')) return 'SAMD21';
                if (text.includes('SAMD51')) return 'SAMD51';
                return 'SAM';
            }
            if (plat === 'renesas_ra') {
                if (text.includes('RA4')) return 'RA4';
                if (text.includes('RA6')) return 'RA6';
                return 'Renesas RA';
            }
            if (plat === 'renesas_rx') {
                if (text.includes('RX72')) return 'RX72';
                if (text.includes('RX65')) return 'RX65';
                return 'Renesas RX';
            }
            if (plat === 'avr' || plat === 'atmega') {
                if (text.includes('ATMEGA32U4')) return 'ATmega32U4';
                if (text.includes('ATMEGA2560')) return 'ATmega2560';
                if (text.includes('ATMEGA328')) return 'ATmega328';
                return 'ATmega';
            }
            if (plat === 'pic16') return 'PIC16';
            return plat ? plat.toUpperCase() : 'General';
        }

        function boardTaxonomy(board) {
            const platform = String(board?.platform || '').toLowerCase();
            const mcu = String(board?.mcu || board?.soc || board?.target_profile || '');
            const mcuUp = mcu.toUpperCase();
            let manufacturer = String(board?.manufacturer || PLATFORM_MANUFACTURER[platform] || 'Generic');
            let architecture = String(board?.architecture || PLATFORM_ARCHITECTURE[platform] || 'Embedded');
            if (platform === 'esp32') {
                architecture = (mcuUp.includes('C3') || mcuUp.includes('C6')) ? 'RISC-V' : 'Xtensa';
            } else if (platform === 'linux-sbc' && mcuUp.includes('BCM')) {
                architecture = 'ARM Cortex-A';
                manufacturer = 'Raspberry Pi';
            }
            return {
                manufacturer,
                architecture,
                family: String(board?.family || mcuFamilyLabel(mcu, platform)),
                silicon: mcu || String(board?.target_profile || board?.id || 'Unknown')
            };
        }

        function allBoardsFlat() {
            const out = [];
            Object.entries(boards || {}).forEach(([platformId, list]) => {
                (Array.isArray(list) ? list : []).forEach(board => {
                    out.push({ ...board, platform: board?.platform || platformId });
                });
            });
            return out;
        }

        function cloneBoardRows(rows) {
            return (Array.isArray(rows) ? rows : []).map(row => ({ ...row }));
        }

        function resetBoardsFromAll() {
            boards = {};
            Object.entries(boardsAll || {}).forEach(([platformId, rows]) => {
                boards[platformId] = cloneBoardRows(rows);
            });
        }

        function boardsApiUrl(platform, filters = {}) {
            const params = new URLSearchParams();
            Object.entries(filters || {}).forEach(([k, v]) => {
                const raw = String(v || '').trim();
                if (raw) params.set(k, raw);
            });
            const qs = params.toString();
            return qs ? `/api/boards/${platform}?${qs}` : `/api/boards/${platform}`;
        }

        async function refreshBoardsForCurrentFilters({ force = false } = {}) {
            if (!selectedPlatform) {
                resetBoardsFromAll();
                return;
            }

            const filters = {
                manufacturer: selectedManufacturer,
                architecture: selectedArchitecture,
                family: selectedFamily,
                silicon: selectedSilicon,
                q: String(document.getElementById('board-search')?.value || '').trim()
            };
            const key = `${selectedPlatform}|${JSON.stringify(filters)}`;
            if (!force && Array.isArray(boardApiFilterCache[key])) {
                boards[selectedPlatform] = cloneBoardRows(boardApiFilterCache[key]);
                return;
            }

            const reqId = ++boardApiRequestSeq;
            try {
                const rows = await apiFetchJson(boardsApiUrl(selectedPlatform, filters));
                if (reqId !== boardApiRequestSeq) return;
                const safeRows = cloneBoardRows(rows);
                boardApiFilterCache[key] = safeRows;
                boards[selectedPlatform] = cloneBoardRows(safeRows);
            } catch (err) {
                if (reqId !== boardApiRequestSeq) return;
                console.warn('Failed to refresh filtered boards from API:', err);
                boards[selectedPlatform] = cloneBoardRows(boardsAll[selectedPlatform]);
            }
        }

        function setSelectOptions(selectEl, values, placeholder, counts = null) {
            if (!selectEl) return;
            const prev = selectEl.value;
            selectEl.innerHTML = '';
            const ph = document.createElement('option');
            ph.value = '';
            ph.textContent = placeholder;
            selectEl.appendChild(ph);
            values.forEach(v => {
                const opt = document.createElement('option');
                opt.value = v;
                const n = Number((counts || {})[v]);
                opt.textContent = Number.isFinite(n) && n > 0 ? `${v} (${n})` : v;
                selectEl.appendChild(opt);
            });
            if (values.includes(prev)) selectEl.value = prev;
            else selectEl.value = '';
        }

        function buildBoardEmptyHint() {
            const parts = [];
            if (selectedManufacturer) parts.push(`manufacturer=${selectedManufacturer}`);
            if (selectedArchitecture) parts.push(`architecture=${selectedArchitecture}`);
            if (selectedFamily) parts.push(`family=${selectedFamily}`);
            if (selectedSilicon) parts.push(`processor=${selectedSilicon}`);
            const search = String(document.getElementById('board-search')?.value || '').trim();
            if (search) parts.push(`search="${search}"`);
            if (!parts.length) return 'Try changing any filter above.';
            return `Active filters: ${parts.join(' • ')}`;
        }

        function renderHardwarePath() {
            const pathEl = document.getElementById('hardware-path');
            if (!pathEl) return;
            const chips = [];
            if (selectedManufacturer) chips.push(selectedManufacturer);
            if (selectedArchitecture) chips.push(selectedArchitecture);
            if (selectedFamily) chips.push(selectedFamily);
            if (selectedSilicon) chips.push(selectedSilicon);
            if (selectedBoard?.name) chips.push(selectedBoard.name);
            if (!chips.length) {
                pathEl.innerHTML = '<span class="hardware-chip">All Hardware</span>';
                return;
            }
            pathEl.innerHTML = chips.map(c => `<span class="hardware-chip">${c}</span>`).join('');
        }

        function loadFilterStateFromUrl() {
            const params = new URLSearchParams(window.location.search || '');
            selectedPlatform = String(params.get('platform') || '').trim();
            selectedManufacturer = String(params.get('manufacturer') || '').trim();
            selectedArchitecture = String(params.get('architecture') || '').trim();
            selectedFamily = String(params.get('family') || '').trim();
            selectedSilicon = String(params.get('silicon') || '').trim();
            pendingBoardIdFromUrl = String(params.get('board') || '').trim();
            pendingSearchFromUrl = String(params.get('q') || '').trim();
            pendingOpenFromUrl = String(params.get('open') || '').trim().toLowerCase();
            pendingStepFromUrl = Number(params.get('step') || '0') || 0;
            boardPerfEnabled = String(params.get('debug_perf') || '').trim() === '1';
        }

        function persistFilterStateToUrl() {
            const params = new URLSearchParams(window.location.search || '');
            const boardSearch = String(document.getElementById('board-search')?.value || '').trim();
            const selectedBoardId = String(selectedBoard?.id || '').trim();
            const state = {
                platform: selectedPlatform,
                manufacturer: selectedManufacturer,
                architecture: selectedArchitecture,
                family: selectedFamily,
                silicon: selectedSilicon,
                board: selectedBoardId,
                q: boardSearch
            };
            Object.entries(state).forEach(([k, v]) => {
                if (v) params.set(k, v);
                else params.delete(k);
            });
            const next = `${window.location.pathname}${params.toString() ? `?${params.toString()}` : ''}`;
            window.history.replaceState(null, '', next);
        }

        function initBoardPerfPanel() {
            const panel = document.getElementById('board-perf-panel');
            if (!panel) return;
            panel.style.display = boardPerfEnabled ? 'block' : 'none';
            if (boardPerfEnabled) {
                panel.textContent = 'Board Perf: waiting for first render...';
            }
        }

        function updateBoardPerfPanel({ mode = 'full', totalRows = 0, renderedRows = 0, totalBoards = 0, ms = boardLastRenderMs } = {}) {
            if (!boardPerfEnabled) return;
            const panel = document.getElementById('board-perf-panel');
            if (!panel) return;
            const m = Number(ms || 0);
            panel.textContent = `Board Perf: mode=${mode} rows=${renderedRows}/${totalRows} boards=${totalBoards} render=${m.toFixed(2)}ms`;
        }

        function taxonomyOptionsUrl(params = {}) {
            const q = new URLSearchParams();
            Object.entries(params).forEach(([k, v]) => {
                const raw = String(v || '').trim();
                if (raw) q.set(k, raw);
            });
            const qs = q.toString();
            return qs ? `/api/board-taxonomy/options?${qs}` : '/api/board-taxonomy/options';
        }

        function boardOptionsUrl(platform, params = {}) {
            const q = new URLSearchParams();
            Object.entries(params).forEach(([k, v]) => {
                const raw = String(v || '').trim();
                if (raw) q.set(k, raw);
            });
            const qs = q.toString();
            return qs ? `/api/boards/${platform}/options?${qs}` : `/api/boards/${platform}/options`;
        }

        async function refreshTaxonomyOptionsFromApi() {
            const search = String(document.getElementById('board-search')?.value || '').trim();
            if (selectedPlatform) {
                const resp = await apiFetchJson(boardOptionsUrl(selectedPlatform, {
                    manufacturer: selectedManufacturer,
                    architecture: selectedArchitecture,
                    family: selectedFamily,
                    silicon: selectedSilicon,
                    q: search
                }));
                const options = resp?.options || {};
                const filters = resp?.filters || {};
                taxonomyOptions = {
                    manufacturer: Array.from(new Set([...(options.manufacturer || []), ...PREFERRED_MANUFACTURERS])).sort((a, b) => a.localeCompare(b)),
                    architecture: Array.from(new Set(options.architecture || [])).sort((a, b) => a.localeCompare(b)),
                    family: Array.from(new Set(options.family || [])).sort((a, b) => a.localeCompare(b)),
                    silicon: Array.from(new Set(options.silicon || [])).sort((a, b) => a.localeCompare(b)),
                    counts: resp?.counts || {}
                };
                selectedManufacturer = String(filters.manufacturer || '').trim();
                selectedArchitecture = String(filters.architecture || '').trim();
                selectedFamily = String(filters.family || '').trim();
                selectedSilicon = String(filters.silicon || '').trim();
                return;
            }

            // Fallback for "all platforms" mode.
            const root = await apiFetchJson(taxonomyOptionsUrl({}));
            taxonomyOptions = {
                manufacturer: Array.from(new Set([...(root?.options?.manufacturer || []), ...PREFERRED_MANUFACTURERS])).sort((a, b) => a.localeCompare(b)),
                architecture: Array.from(new Set(root?.options?.architecture || [])).sort((a, b) => a.localeCompare(b)),
                family: Array.from(new Set(root?.options?.family || [])).sort((a, b) => a.localeCompare(b)),
                silicon: []
            };
            if (selectedManufacturer && !taxonomyOptions.manufacturer.includes(selectedManufacturer)) selectedManufacturer = '';
            if (selectedArchitecture && !taxonomyOptions.architecture.includes(selectedArchitecture)) selectedArchitecture = '';
            if (selectedFamily && !taxonomyOptions.family.includes(selectedFamily)) selectedFamily = '';
            selectedSilicon = '';
        }

        function applyHierarchyFilters() {
            const search = String(document.getElementById('board-search')?.value || '').trim().toLowerCase();
            return allBoardsFlat().filter(board => {
                const tx = boardTaxonomy(board);
                if (selectedPlatform && String(board?.platform || '').toLowerCase() !== String(selectedPlatform || '').toLowerCase()) return false;
                if (selectedManufacturer && tx.manufacturer !== selectedManufacturer) return false;
                if (selectedArchitecture && tx.architecture !== selectedArchitecture) return false;
                if (selectedFamily && tx.family !== selectedFamily) return false;
                if (selectedSilicon && tx.silicon !== selectedSilicon) return false;
                if (search) {
                    const hay = `${board.name || ''} ${board.id || ''} ${board.mcu || ''} ${board.description || ''}`.toLowerCase();
                    if (!hay.includes(search)) return false;
                }
                return true;
            });
        }

        async function runBoardSearchRefresh() {
            await refreshTaxonomyOptionsFromApi().catch(err => {
                console.warn('Failed to refresh taxonomy options:', err);
                taxonomyOptions = null;
            });
            await refreshBoardsForCurrentFilters({ force: true });
            populateBoardList();
            updateMemoryEstimatePanels();
            persistFilterStateToUrl();
        }

        function scheduleBoardSearchRefresh() {
            if (boardSearchDebounceTimer) clearTimeout(boardSearchDebounceTimer);
            boardSearchDebounceTimer = setTimeout(() => {
                runBoardSearchRefresh().catch(err => {
                    console.warn('Debounced board search refresh failed:', err);
                });
            }, 180);
        }

        function syncHierarchySelectors() {
            const manuSel = document.getElementById('manufacturer-select');
            const archSel = document.getElementById('architecture-select');
            const famSel = document.getElementById('family-select');
            const silSel = document.getElementById('silicon-select');

            const all = allBoardsFlat();
            const manufacturers = (taxonomyOptions?.manufacturer?.length
                ? taxonomyOptions.manufacturer
                : Array.from(new Set([
                    ...PREFERRED_MANUFACTURERS,
                    ...all.map(b => boardTaxonomy(b).manufacturer)
                ])).sort((a, b) => a.localeCompare(b)));
            if (selectedManufacturer && !manufacturers.includes(selectedManufacturer)) selectedManufacturer = '';
            setSelectOptions(
                manuSel,
                manufacturers,
                getBoardFilterDef('manufacturer').all_label || 'All manufacturers',
                taxonomyOptions?.counts?.manufacturer || null
            );
            if (!selectedManufacturer && manufacturers.length === 1) selectedManufacturer = manufacturers[0];
            if (selectedManufacturer) manuSel.value = selectedManufacturer;

            const byManu = all.filter(b => !selectedManufacturer || boardTaxonomy(b).manufacturer === selectedManufacturer);
            const architectures = (taxonomyOptions?.architecture?.length
                ? taxonomyOptions.architecture
                : Array.from(new Set(byManu.map(b => boardTaxonomy(b).architecture))).sort((a, b) => a.localeCompare(b)));
            if (selectedArchitecture && !architectures.includes(selectedArchitecture)) selectedArchitecture = '';
            setSelectOptions(
                archSel,
                architectures,
                getBoardFilterDef('architecture').all_label || 'All architectures',
                taxonomyOptions?.counts?.architecture || null
            );
            if (!selectedArchitecture && architectures.length === 1) selectedArchitecture = architectures[0];
            if (selectedArchitecture && architectures.includes(selectedArchitecture)) archSel.value = selectedArchitecture;
            else selectedArchitecture = '';

            const byArch = byManu.filter(b => !selectedArchitecture || boardTaxonomy(b).architecture === selectedArchitecture);
            const families = (taxonomyOptions?.family?.length
                ? taxonomyOptions.family
                : Array.from(new Set(byArch.map(b => boardTaxonomy(b).family))).sort((a, b) => a.localeCompare(b)));
            if (selectedFamily && !families.includes(selectedFamily)) selectedFamily = '';
            setSelectOptions(
                famSel,
                families,
                getBoardFilterDef('family').all_label || 'All families',
                taxonomyOptions?.counts?.family || null
            );
            if (!selectedFamily && families.length === 1) selectedFamily = families[0];
            if (selectedFamily && families.includes(selectedFamily)) famSel.value = selectedFamily;
            else selectedFamily = '';

            const byFam = byArch.filter(b => !selectedFamily || boardTaxonomy(b).family === selectedFamily);
            const silicons = (taxonomyOptions?.silicon?.length
                ? taxonomyOptions.silicon
                : Array.from(new Set(byFam.map(b => boardTaxonomy(b).silicon))).sort((a, b) => a.localeCompare(b)));
            if (selectedSilicon && !silicons.includes(selectedSilicon)) selectedSilicon = '';
            setSelectOptions(
                silSel,
                silicons,
                getBoardFilterDef('silicon').all_label || 'All processors',
                taxonomyOptions?.counts?.silicon || null
            );
            if (!selectedSilicon && silicons.length === 1) selectedSilicon = silicons[0];
            if (selectedSilicon && silicons.includes(selectedSilicon)) silSel.value = selectedSilicon;
            else selectedSilicon = '';
        }

        function moduleSectionFor(moduleId) {
            const id = String(moduleId || '');
            if (id.startsWith('fs_')) return 'storage';
            if (['uart', 'spi', 'i2c', 'remote_node'].includes(id)) return 'connectivity';
            if (['tft', 'display_ssd1306', 'shell_full', 'shell_min', 'shell_tiny'].includes(id)) return 'ui_shell';
            if (['psram', 'adc', 'pwm', 'eeprom', 'rtc', 'imu', 'dht22', 'mic', 'ads1115', 'mcp23017', 'hp4067', 'tp4056'].includes(id)) return 'advanced';
            return 'core';
        }

        function moduleSectionLabel(sectionId) {
            const map = {
                core: 'Core Runtime',
                connectivity: 'Connectivity & Buses',
                storage: 'Storage',
                ui_shell: 'UI & Shell',
                advanced: 'Advanced & Peripherals'
            };
            return map[sectionId] || sectionId;
        }
        
        async function loadFromApi() {
            const isHttp = window.location.protocol.startsWith('http');
            if (!isHttp) {
                showPlatformError('Running from file:// - start the server and open http://localhost:5000');
                return false;
            }

            try {
                platforms = await apiFetchJson('/api/platforms');

                boards = {};
                boardsAll = {};
                boardApiFilterCache = {};
                for (const p of platforms) {
                    boardsAll[p.id] = cloneBoardRows(await apiFetchJson(`/api/boards/${p.id}`));
                    boards[p.id] = cloneBoardRows(boardsAll[p.id]);
                }

                if (selectedPlatform) {
                    await refreshModulesForPlatform(selectedPlatform);
                    modules.forEach(m => { if (!Array.isArray(m.pins)) m.pins = []; });
                } else {
                    modules = [];
                    loadedPlatformForModules = '';
                }

                try {
                    const tList = await apiFetchJson('/api/targets');
                    targets = {};
                    tList.forEach(t => { if (t && t.id) targets[t.id] = t; });
                } catch (err) {
                    console.warn('Failed to load targets:', err);
                    notify(`Targets API unavailable: ${err.message || err}`, 'warning');
                }

                marketCatalog = [];
                loadedPlatformForMarket = '';

                return true;
            } catch (err) {
                console.error('Failed to load from API:', err);
                showPlatformError(`Failed to load /api/platforms: ${err.message || err}`);
                return false;
            }
        }

        async function populatePlatformSelect() {
            const sel = document.getElementById('platform-select');
            sel.innerHTML = '';
            const errorEl = document.getElementById('platform-load-error');

            if (!platforms || platforms.length === 0) {
                try {
                    platforms = await apiFetchJson('/api/platforms');
                } catch (err) {
                    console.error('Failed to load platforms:', err);
                    if (errorEl) {
                        errorEl.style.display = 'block';
                        errorEl.textContent = `Failed to load platforms: ${err.message || err}`;
                    }
                }
            }

            if (!platforms || platforms.length === 0) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'No platforms loaded (check /api/platforms)';
                sel.appendChild(opt);
                sel.disabled = true;
                return;
            }

            sel.disabled = false;
            if (errorEl) errorEl.style.display = 'none';
            const sortedPlatforms = [...platforms].sort((a, b) =>
                String(a?.name || a?.id || '').localeCompare(String(b?.name || b?.id || ''), undefined, { sensitivity: 'base' })
            );

            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Select Platform';
            sel.appendChild(placeholder);

            sortedPlatforms.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = p.name || p.id;
                sel.appendChild(opt);
            });
            sel.value = selectedPlatform || '';
        }

        async function refreshModulesForPlatform(platformId) {
            const url = platformId ? `/api/drivers?platform=${platformId}` : '/api/drivers';
            modules = await apiFetchJson(url);
            modules.forEach(m => { if (!Array.isArray(m.pins)) m.pins = []; });
            loadedPlatformForModules = String(platformId || '');
        }

        async function refreshMarketCatalogForPlatform(platformId) {
            marketCatalog = [];
            loadedPlatformForMarket = String(platformId || '');
        }

        async function loadTemplates() {
            try {
                const data = await apiFetchJson('/api/templates');
                projectTemplates = data.templates || data;
            } catch (error) {
                console.warn('Using embedded templates, API unavailable.');
                projectTemplates = [];
            }

            if (projectTemplates.length === 0) {
                projectTemplates = [
                    {
                        id: 'display_app',
                        name: 'Display Application',
                        description: 'Basic TFT display application with console output and file storage',
                        icon: '🖥️',
                        platforms: ['esp32'],
                        recommended_boards: ['cyd', 'm5stickc_plus2'],
                        enabled_drivers: ['uart', 'spi', 'tft', 'fs_spiffs', 'shell_full'],
                        driver_config: {},
                        tags: ['display', 'beginner', 'popular']
                    },
                    {
                        id: 'cyd_full_stack',
                        name: 'CYD Full Stack',
                        description: 'TFT console + SPIFFS + SD for the CYD display',
                        icon: '🟨',
                        platforms: ['esp32'],
                        recommended_boards: ['cyd'],
                        enabled_drivers: ['uart', 'spi', 'i2c', 'tft', 'fs_spiffs', 'fs_sd', 'shell_full'],
                        driver_config: {},
                        tags: ['display', 'storage', 'popular']
                    },
                    {
                        id: 'iot_sensor',
                        name: 'IoT Sensor Hub',
                        description: 'WiFi-enabled sensor hub with I2C sensors and SD card data logging',
                        icon: '🌡️',
                        platforms: ['esp32'],
                        recommended_boards: ['esp32-devkitc_v4', 'cyd'],
                        enabled_drivers: ['uart', 'i2c', 'wifi', 'fs_sd', 'shell_min'],
                        driver_config: {},
                        tags: ['iot', 'sensors', 'wifi']
                    },
                    {
                        id: 'minimal_embedded',
                        name: 'Minimal System',
                        description: 'Bare minimum configuration for resource-constrained applications (Shell Tiny)',
                        icon: '⚡',
                        platforms: ['esp32'],
                        recommended_boards: ['esp32-c3-supermini'],
                        enabled_drivers: ['uart', 'shell_tiny'],
                        driver_config: {},
                        tags: ['minimal', 'low-power', 'beginner']
                    },
                    {
                        id: 'mega2560_bringup',
                        name: 'Mega 2560 Bring-up',
                        description: 'GPIO + UART + Timer baseline for Arduino Mega 2560',
                        icon: '🧰',
                        platforms: ['avr'],
                        recommended_boards: ['mega2560'],
                        enabled_drivers: ['gpio', 'uart', 'timer'],
                        driver_config: { uart: { uart_num: 0, uart_baudrate: 115200 } },
                        tags: ['avr', 'baseline']
                    },
                    {
                        id: 'mega2560_lite',
                        name: 'Mega 2560 Tiny Shell',
                        description: 'Mega baseline with Shell (Tiny) for interactive bring-up on USB serial',
                        icon: '🧩',
                        platforms: ['avr'],
                        recommended_boards: ['mega2560'],
                        enabled_drivers: ['gpio', 'uart', 'timer', 'shell_min'],
                        driver_config: { uart: { uart_num: 0, uart_baudrate: 115200 } },
                        tags: ['avr', 'shell', 'lite', 'baseline']
                    },
                    {
                        id: 'mega2560_tiny',
                        name: 'Mega 2560 Tiny Shell',
                        description: 'Ultra-constrained Mega profile with Shell (Tiny) for lowest overhead',
                        icon: '🪶',
                        platforms: ['avr'],
                        recommended_boards: ['mega2560'],
                        enabled_drivers: ['gpio', 'uart', 'shell_tiny'],
                        driver_config: { uart: { uart_num: 0, uart_baudrate: 115200 } },
                        tags: ['avr', 'shell', 'tiny', 'low-power']
                    },
                    {
                        id: 'uno_minimal',
                        name: 'Uno Minimal',
                        description: 'ATmega328P minimal config (GPIO + UART)',
                        icon: '🧱',
                        platforms: ['atmega'],
                        recommended_boards: ['arduino_uno_r3'],
                        enabled_drivers: ['gpio', 'uart'],
                        driver_config: { uart: { uart_num: 0, uart_baudrate: 115200 } },
                        tags: ['avr', 'minimal']
                    },
                    {
                        id: 'pro_micro_oled_lite',
                        name: 'Pro Micro OLED Tiny',
                        description: 'ATmega32U4 Pro Micro baseline with I2C SSD1306 + Shell (Tiny)',
                        icon: '🖼️',
                        platforms: ['avr', 'atmega'],
                        recommended_boards: ['arduino_pro_micro_5v_usbc'],
                        enabled_drivers: ['gpio', 'uart', 'i2c', 'display_ssd1306', 'shell_tiny'],
                        driver_config: {
                            uart: { uart_num: 0, uart_baudrate: 57600 },
                            display_ssd1306: { address: '0x3C', width: 128, height: 64 }
                        },
                        tags: ['atmega32u4', 'oled', 'shell', 'starter']
                    },
                    {
                        id: 'pico_sensors',
                        name: 'Pico Sensor Core',
                        description: 'RP2040 sensor-ready baseline (I2C + UART)',
                        icon: '🧪',
                        platforms: ['rp2040'],
                        recommended_boards: ['raspberry_pi_pico'],
                        enabled_drivers: ['gpio', 'uart', 'i2c', 'timer'],
                        driver_config: {},
                        tags: ['rp2040', 'sensors']
                    },
                    {
                        id: 'nucleo_console',
                        name: 'Nucleo Console',
                        description: 'STM32 console + GPIO baseline',
                        icon: '🧭',
                        platforms: ['stm32'],
                        recommended_boards: ['nucleo_f401re'],
                        enabled_drivers: ['gpio', 'uart', 'timer'],
                        driver_config: {},
                        tags: ['stm32', 'baseline']
                    }
                ];
            }

        }

        function renderTemplateFilters() {
            const allTags = new Set(['all']);
            projectTemplates
                .filter(t => !selectedPlatform || (Array.isArray(t.platforms) && t.platforms.includes(selectedPlatform)))
                .forEach(t => (t.tags || []).forEach(tag => allTags.add(tag)));

            const filterContainer = document.getElementById('template-filters');
            if (!filterContainer) return;

            const priority = selectedPlatform ? [selectedPlatform, 'baseline', 'starter', 'popular', 'minimal', 'beginner'] : ['popular', 'starter', 'baseline'];
            const tagsSorted = Array.from(allTags).sort((a, b) => {
                const ia = priority.indexOf(a);
                const ib = priority.indexOf(b);
                if (ia >= 0 && ib >= 0) return ia - ib;
                if (ia >= 0) return -1;
                if (ib >= 0) return 1;
                return String(a).localeCompare(String(b));
            });

            filterContainer.innerHTML = tagsSorted.map(tag => `
                <span class="filter-tag ${tag === 'all' ? 'active' : ''}"
                      onclick="selectTemplateFilter('${tag}')">
                    ${tag.charAt(0).toUpperCase() + tag.slice(1)}
                </span>
            `).join('');
        }

        function boardFamilyTags(board) {
            const id = String(board?.id || '').toLowerCase();
            const tags = new Set();
            if (id.includes('nucleo')) tags.add('nucleo');
            if (id.includes('blackpill')) tags.add('blackpill');
            if (id.includes('pico')) tags.add('pico');
            if (id.includes('feather')) tags.add('feather');
            if (id.includes('mega')) tags.add('mega');
            if (id.includes('nano')) tags.add('nano');
            if (id.includes('xiao')) tags.add('xiao');
            if (id.includes('renesas') || id.includes('ra4') || id.includes('rx')) tags.add('renesas');
            if (id.includes('cyd')) tags.add('cyd');
            return tags;
        }

        function normalizeBoardId(value) {
            return String(value || '')
                .trim()
                .toLowerCase()
                .replace(/[\s-]+/g, '_');
        }

        function recommendedBoardSet(template) {
            return new Set((template?.recommended_boards || []).map(normalizeBoardId));
        }

        function boardDisplayNameById(boardIdRaw) {
            const boardId = normalizeBoardId(boardIdRaw);
            if (!boardId) return String(boardIdRaw || '');
            for (const list of Object.values(boards || {})) {
                const found = (Array.isArray(list) ? list : []).find(b => normalizeBoardId(b?.id) === boardId);
                if (found?.name) return found.name;
            }
            return String(boardIdRaw || '');
        }

        function templateRelevanceScore(template) {
            let score = 0;
            const tags = new Set((template.tags || []).map(x => String(x).toLowerCase()));
            const recBoards = recommendedBoardSet(template);
            const tplPlatforms = new Set((template.platforms || []).map(x => String(x).toLowerCase()));
            const platformId = String(selectedPlatform || '').toLowerCase();
            const boardId = normalizeBoardId(selectedBoard?.id || '');

            if (platformId && tplPlatforms.has(platformId)) score += 20;
            if (boardId && recBoards.has(boardId)) score += 35;
            if (tags.has('popular')) score += 6;
            if (tags.has('starter') || tags.has('baseline')) score += 8;
            if (tags.has('beginner') || tags.has('minimal')) score += 4;
            if (platformId && tags.has(platformId)) score += 10;

            if (selectedBoard) {
                const fam = boardFamilyTags(selectedBoard);
                fam.forEach(tag => {
                    if (tags.has(tag)) score += 6;
                });
            }
            if (!selectedBoard && tags.has('starter')) score += 3;
            return score;
        }

        function selectTemplateFilter(tag) {
            document.querySelectorAll('.filter-tag').forEach(el => {
                el.classList.toggle('active', el.textContent.toLowerCase() === tag);
            });
        }

        function renderTemplates(filterTag = 'all') {
            const container = document.getElementById('templates-grid');
            if (!container) return;

            let filtered = projectTemplates;
            if (filterTag !== 'all') {
                filtered = projectTemplates.filter(t => t.tags && t.tags.includes(filterTag));
            }
            if (selectedPlatform && selectedPlatform !== 'all') {
                filtered = filtered.filter(t => t.platforms && t.platforms.includes(selectedPlatform));
            }
            filtered = filtered
                .map(t => ({ template: t, score: templateRelevanceScore(t) }))
                .sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    return String(a.template.name || '').localeCompare(String(b.template.name || ''));
                })
                .map(x => x.template);

            container.innerHTML = filtered.map(template => `
                <div class="template-card ${template.tags?.includes('popular') ? 'popular' : ''}"
                     onclick="showTemplatePreview('${template.id}')">
                    <span class="template-icon">${template.icon || '📦'}</span>
                    <h4>${template.name}</h4>
                    ${selectedBoard && recommendedBoardSet(template).has(normalizeBoardId(selectedBoard.id))
                        ? `<div class="template-modules"><strong>Best Match:</strong> tuned for ${selectedBoard.name}</div>`
                        : ''}
                    <p>${template.description}</p>
                    <div class="template-modules">
                        <strong>Drivers:</strong>
                        ${templateEnabledDrivers(template).slice(0, 3).join(', ')}
                        ${templateEnabledDrivers(template).length > 3 ? ` +${templateEnabledDrivers(template).length - 3} more` : ''}
                    </div>
                    ${Array.isArray(template.applets) && template.applets.length > 0 ? `
                        <div class="template-modules">
                            <strong>Starter Apps:</strong> ${template.applets.length}
                        </div>
                    ` : ''}
                    <div class="template-tags">
                        ${(template.tags || []).map(tag =>
                            `<span class="template-tag">${tag}</span>`
                        ).join('')}
                    </div>
                    <div class="template-quick-actions" onclick="event.stopPropagation()">
                        <button class="btn-template btn-template-preview"
                                onclick="showTemplatePreview('${template.id}')">
                            Preview
                        </button>
                        <button class="btn-template btn-template-use"
                                onclick="applyTemplate('${template.id}')">
                            Use Template
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function showTemplatePreview(templateId) {
            const template = projectTemplates.find(t => t.id === templateId);
            if (!template) return;

            const modal = document.getElementById('template-modal');
            const content = document.getElementById('template-modal-body');

            content.innerHTML = `
                <div class="template-modal-header">
                    <div>
                        <h2>${template.icon || '📦'} ${template.name}</h2>
                        <p style="color: #718096; margin-top: 5px;">${template.description}</p>
                    </div>
                    <span class="template-modal-close" onclick="closeTemplateModal()">×</span>
                </div>

                <div style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">Enabled Drivers (${templateEnabledDrivers(template).length})</h3>
                    <div class="module-badges" style="margin-bottom: 20px;">
                        ${templateEnabledDrivers(template).map(m =>
                            `<span class="badge badge-provides">${m}</span>`
                        ).join('')}
                    </div>

                    <h3 style="margin-bottom: 10px;">Recommended Boards</h3>
                    <div class="module-badges" style="margin-bottom: 20px;">
                        ${(template.recommended_boards || []).map(b =>
                            `<span class="badge badge-platform">${boardDisplayNameById(b)}</span>`
                        ).join('')}
                    </div>

                    ${Array.isArray(template.applets) && template.applets.length > 0 ? `
                        <h3 style="margin-bottom: 10px;">Starter Apps (${template.applets.length})</h3>
                        <div class="module-badges" style="margin-bottom: 20px;">
                            ${template.applets.map(a =>
                                `<span class="badge badge-platform">${a}</span>`
                            ).join('')}
                        </div>
                    ` : ''}

                    ${Object.keys(templateDriverConfig(template) || {}).length > 0 ? `
                        <h3 style="margin-bottom: 10px;">Driver Configuration</h3>
                        <pre style="background: #f7fafc; padding: 15px; border-radius: 6px; overflow-x: auto;">
${JSON.stringify(templateDriverConfig(template), null, 2)}</pre>
                    ` : ''}

                    <div style="margin-top: 30px; display: flex; gap: 15px;">
                        <button class="btn btn-secondary" onclick="closeTemplateModal()">
                            Cancel
                        </button>
                        <button class="btn btn-success" onclick="applyTemplate('${template.id}'); closeTemplateModal();">
                            Apply Template
                        </button>
                    </div>
                </div>
            `;

            modal.classList.add('active');
        }

        function closeTemplateModal() {
            document.getElementById('template-modal').classList.remove('active');
        }

        function toggleOverflowMenu(show = null) {
            const menu = document.getElementById('overflow-menu');
            if (!menu) return;
            const shouldShow = show === null ? !menu.classList.contains('active') : !!show;
            menu.classList.toggle('active', shouldShow);
        }

        function templateEnabledDrivers(template) {
            if (!template || typeof template !== 'object') return [];
            if (Array.isArray(template.enabled_drivers)) return template.enabled_drivers;
            if (Array.isArray(template.enabled_modules)) return template.enabled_modules;
            return [];
        }

        function templateDriverConfig(template) {
            if (!template || typeof template !== 'object') return {};
            if (template.driver_config && typeof template.driver_config === 'object') return template.driver_config;
            if (template.module_config && typeof template.module_config === 'object') return template.module_config;
            return {};
        }

        function applyTemplate(templateId) {
            const template = projectTemplates.find(t => t.id === templateId);
            if (!template) return;
            activeTemplateId = templateId;
            const driverConfig = templateDriverConfig(template);

            applyBoardAndTemplateDefaults(selectedBoard, template);

            if (driverConfig && Object.keys(driverConfig).length > 0) {
                Object.entries(driverConfig).forEach(([moduleId, config]) => {
                    moduleConfigs[moduleId] = { ...(moduleConfigs[moduleId] || {}), ...config };
                });
            }

            if (Array.isArray(template.applets)) {
                const available = new Set(availableAppletsForBoard(selectedBoard));
                Object.keys(appletStates).forEach(k => { appletStates[k] = false; });
                template.applets.forEach(a => {
                    if (available.has(a)) appletStates[a] = true;
                });
            }

            if (Array.isArray(template.market_apps)) {
                const available = new Set(availableMarketAppsForBoard(selectedBoard).map(x => x.id));
                Object.keys(marketAppStates).forEach(k => { marketAppStates[k] = false; });
                template.market_apps.forEach(a => {
                    if (available.has(a)) marketAppStates[a] = true;
                });
            }

            populateModuleGrid();
            renderSelectedAppsVisibility();
            renderRuntimeOptionsPanel();
            updateValidation();
        }

        function renderModuleOptions(module) {
            if (!module.configuration_options) return '';

            return module.configuration_options.map(option => {
                const value = moduleConfigs[module.id]?.[option.id] ?? option.default;
                const reqOpt = option.requires_option?.id ? String(option.requires_option.id) : '';
                const reqVal = option.requires_option?.value != null ? String(option.requires_option.value) : '';
                const fieldAttrs = `${reqOpt ? ` data-requires-option="${reqOpt}"` : ''}${reqOpt ? ` data-requires-value="${reqVal}"` : ''}`;

                if (option.type === 'select') {
                    return `
                        <div class="option-field"${fieldAttrs}>
                            <label>${option.name}</label>
                            <select data-module="${module.id}" data-option="${option.id}">
                                ${option.options.map(opt =>
                                    `<option value="${opt}" ${String(opt) === String(value) ? 'selected' : ''}>${opt}</option>`
                                ).join('')}
                            </select>
                        </div>
                    `;
                }
                if (option.type === 'number') {
                    return `
                        <div class="option-field"${fieldAttrs}>
                            <label>${option.name}</label>
                            <input type="number"
                                   value="${value}"
                                   min="${option.min ?? ''}"
                                   max="${option.max ?? ''}"
                                   data-module="${module.id}"
                                   data-option="${option.id}">
                        </div>
                    `;
                }
                if (option.type === 'text') {
                    return `
                        <div class="option-field"${fieldAttrs}>
                            <label>${option.name}</label>
                            <input type="text"
                                   value="${value}"
                                   data-module="${module.id}"
                                   data-option="${option.id}">
                        </div>
                    `;
                }
                if (option.type === 'file') {
                    const accept = Array.isArray(option.accept) ? option.accept.join(',') : (option.accept || '');
                    const fileName = moduleConfigs[module.id]?.[`${option.id}_name`] || '';
                    return `
                        <div class="option-field"${fieldAttrs}>
                            <label>${option.name}</label>
                            <input type="file"
                                   accept="${accept}"
                                   data-module="${module.id}"
                                   data-option="${option.id}">
                            ${option.help ? `<small style="color:#64748b;">${option.help}</small>` : ''}
                            <small data-file-name-for="${module.id}:${option.id}" style="color:#64748b;">
                                ${fileName ? `Selected: ${fileName}` : 'No file selected'}
                            </small>
                        </div>
                    `;
                }
                return '';
            }).join('');
        }

        function encodeUtf8Base64(text) {
            try {
                return btoa(unescape(encodeURIComponent(text)));
            } catch (e) {
                console.warn('base64 encode failed', e);
                return '';
            }
        }

        function updateConditionalOptionVisibility(moduleId) {
            const panel = document.getElementById(`options-${moduleId}`);
            if (!panel) return;
            panel.querySelectorAll('.option-field[data-requires-option]').forEach(field => {
                const reqOpt = String(field.dataset.requiresOption || '').trim();
                const reqVal = String(field.dataset.requiresValue || '').trim();
                const current = moduleConfigs[moduleId]?.[reqOpt];
                const show = String(current ?? '') === reqVal;
                field.style.display = show ? '' : 'none';
            });
        }

        function getModuleOptionValue(moduleId, optionId) {
            const configured = moduleConfigs[moduleId]?.[optionId];
            if (configured !== undefined) return configured;
            const module = modules.find(m => m.id === moduleId);
            if (!module || !Array.isArray(module.configuration_options)) return undefined;
            const opt = module.configuration_options.find(o => String(o.id) === String(optionId));
            return opt ? opt.default : undefined;
        }

        function ensureMicSourceDependency() {
            const mic = modules.find(m => m.id === 'mic');
            if (!mic || !mic.enabled) return;
            const source = String(getModuleOptionValue('mic', 'source') ?? 'adc').toLowerCase();
            const depId = source === 'i2s' ? 'i2s' : 'adc';
            const depModule = modules.find(m => m.id === depId);
            if (!depModule || depModule.enabled) return;
            depModule.enabled = true;
            moduleStates[depId] = true;
            const depCard = document.getElementById(`module-card-${depId}`);
            const caps = new Set(selectedBoard?.capabilities || []);
            if (depCard) {
                depCard.classList.add('enabled');
                const checkbox = depCard.querySelector('input[type="checkbox"]');
                const depAllowed = moduleAllowed(depModule, caps);
                syncModuleCardAccessibility(depModule, depCard, checkbox, true, depAllowed);
            }
            notify(`Enabled "${depModule.name}" because mic source is set to "${source}".`, 'info');
        }

        function toggleModuleOptions(moduleId, buttonEl) {
            const optionsPanel = document.getElementById(`options-${moduleId}`);
            const btn = buttonEl;
            if (!optionsPanel || !btn) return;

            if (optionsPanel.classList.contains('active')) {
                optionsPanel.classList.remove('active');
                btn.classList.remove('active');
                btn.textContent = '⚙️ Configure';
            } else {
                optionsPanel.classList.add('active');
                btn.classList.add('active');
                btn.textContent = '⚙️ Hide Config';
            }
        }

        function wireModuleOptionInputs(container) {
            container.querySelectorAll('.module-options input, .module-options select').forEach(el => {
                el.addEventListener('change', async () => {
                    const moduleId = el.dataset.module;
                    const optionId = el.dataset.option;
                    if (!moduleId || !optionId) return;
                    if (!moduleConfigs[moduleId]) moduleConfigs[moduleId] = {};
                    if (el.type === 'file') {
                        const file = (el.files && el.files[0]) ? el.files[0] : null;
                        if (file) {
                            const lower = String(file.name || '').toLowerCase();
                            if (!lower.endsWith('.c')) {
                                notify('Only processed C source files are supported for splash right now (custom_image.c).', 'warning');
                                el.value = '';
                                delete moduleConfigs[moduleId][optionId];
                                delete moduleConfigs[moduleId][`${optionId}_name`];
                                delete moduleConfigs[moduleId][`${optionId}_content_b64`];
                                updateConditionalOptionVisibility(moduleId);
                                updateValidation();
                                return;
                            }
                            const text = await file.text();
                            const b64 = encodeUtf8Base64(text);
                            if (!b64) {
                                notify('Could not read selected file content.', 'error');
                                return;
                            }
                            moduleConfigs[moduleId][optionId] = `local:${file.name}`;
                            moduleConfigs[moduleId][`${optionId}_name`] = file.name;
                            moduleConfigs[moduleId][`${optionId}_content_b64`] = b64;
                        } else {
                            delete moduleConfigs[moduleId][optionId];
                            delete moduleConfigs[moduleId][`${optionId}_name`];
                            delete moduleConfigs[moduleId][`${optionId}_content_b64`];
                        }
                        const label = container.querySelector(`[data-file-name-for="${moduleId}:${optionId}"]`);
                        if (label) {
                            label.textContent = file ? `Selected: ${file.name}` : 'No file selected';
                        }
                        updateConditionalOptionVisibility(moduleId);
                        updateValidation();
                        return;
                    }
                    const raw = el.value;
                    const num = Number(raw);
                    moduleConfigs[moduleId][optionId] = Number.isFinite(num) && String(raw) === String(num) ? num : raw;
                    if (moduleId === 'mic' && optionId === 'source') {
                        ensureMicSourceDependency();
                    }
                    updateConditionalOptionVisibility(moduleId);
                    updateValidation();
                });
            });
        }

        function collectModuleConfigFromUI() {
            document.querySelectorAll('.module-options input, .module-options select').forEach(el => {
                const moduleId = el.dataset.module;
                const optionId = el.dataset.option;
                if (!moduleId || !optionId) return;
                if (el.type === 'file') return;
                if (!moduleConfigs[moduleId]) moduleConfigs[moduleId] = {};
                const raw = el.value;
                const num = Number(raw);
                moduleConfigs[moduleId][optionId] = Number.isFinite(num) && String(raw) === String(num) ? num : raw;
            });
            return moduleConfigs;
        }

        function moduleCardA11yLabel(module, enabled, allowed) {
            return `${module.name}: ${enabled ? 'enabled' : 'disabled'}${allowed ? '' : ' (not compatible with selected board)'}`;
        }

        function isInteractiveModuleTarget(target) {
            return !!target?.closest('input,button,select,textarea,label,a,.btn-config,.module-options');
        }

        function syncModuleCardAccessibility(module, card, toggle, enabled, allowed) {
            if (!module || !card) return;
            card.setAttribute('role', 'checkbox');
            card.setAttribute('aria-checked', enabled ? 'true' : 'false');
            card.setAttribute('aria-disabled', allowed ? 'false' : 'true');
            card.setAttribute('aria-label', moduleCardA11yLabel(module, enabled, allowed));
            card.tabIndex = allowed ? 0 : -1;
            if (toggle) {
                toggle.checked = !!enabled;
                toggle.setAttribute('aria-label', `Toggle ${module.name}`);
            }
        }

        function announceModuleGridStatus(actionText = '') {
            const status = document.getElementById('module-grid-status');
            if (!status) return;
            const total = modules.length;
            const enabled = modules.filter(m => !!m.enabled).length;
            const prefix = actionText ? `${actionText}. ` : '';
            status.textContent = `${prefix}${enabled} of ${total} drivers enabled.`;
        }

        function handleModuleToggle(moduleId, enabled) {
            const module = modules.find(m => m.id === moduleId);
            if (!module) return;
            activeTemplateId = null;
            const caps = new Set(selectedBoard?.capabilities || []);
            const allowed = moduleAllowed(module, caps);

            module.enabled = enabled;
            moduleStates[moduleId] = enabled;

            const card = document.getElementById(`module-card-${moduleId}`);
            if (card) card.classList.toggle('enabled', enabled);
            const toggle = card?.querySelector('input[type="checkbox"]');
            syncModuleCardAccessibility(module, card, toggle, enabled, allowed);

            if (enabled) {
                const depends = Array.isArray(module.depends) ? module.depends : [];
                depends.forEach(depId => {
                    const depModule = modules.find(m => m.id === depId);
                    if (depModule && !depModule.enabled) {
                        depModule.enabled = true;
                        moduleStates[depId] = true;

                        const depCard = document.getElementById(`module-card-${depId}`);
                        if (depCard) {
                            depCard.classList.add('enabled');
                            const checkbox = depCard.querySelector('input[type="checkbox"]');
                            const depAllowed = moduleAllowed(depModule, caps);
                            syncModuleCardAccessibility(depModule, depCard, checkbox, true, depAllowed);
                        }
                    }
                });

                const conflicts = Array.isArray(module.conflicts) ? module.conflicts : [];
                conflicts.forEach(conflictId => {
                    const conflictModule = modules.find(m => m.id === conflictId);
                    if (conflictModule && conflictModule.enabled) {
                        showWarning(`Driver "${module.name}" conflicts with "${conflictModule.name}".`);
                    }
                });
                if (module.id === 'mic') {
                    ensureMicSourceDependency();
                }
            }

            refreshModuleSectionCounts();
            announceModuleGridStatus(`${module.name} ${enabled ? 'enabled' : 'disabled'}`);
            updateValidation();
            updateMemoryEstimatePanels();
        }

        function syncModuleStatesFromUI() {
            document.querySelectorAll('#module-grid input[type="checkbox"][data-module]').forEach(input => {
                const moduleId = input.dataset.module;
                const module = modules.find(m => m.id === moduleId);
                if (module) module.enabled = input.checked;
            });
        }

        function signalIoType(signal) {
            const pinDef = selectedBoard?.pin_definitions?.[signal];
            if (pinDef && typeof pinDef === 'object') {
                const t = String(pinDef.type || '').toLowerCase();
                if (t === 'input' || t === 'output' || t === 'bidirectional') return t;
            }
            const s = String(signal || '').toLowerCase();
            const outputSuffixes = ['_tx', '_mosi', '_sclk', '_clk', '_sck', '_cs', '_dc', '_rst', '_bl', '_led', '_pwm'];
            const inputSuffixes = ['_rx', '_miso', '_irq', '_int', '_button'];
            if (outputSuffixes.some(x => s.endsWith(x))) return 'output';
            if (inputSuffixes.some(x => s.endsWith(x))) return 'input';
            return 'bidirectional';
        }

        function spiShareKind(signal) {
            const s = String(signal || '').toLowerCase();
            if (s.endsWith('_mosi')) return 'mosi';
            if (s.endsWith('_miso')) return 'miso';
            if (s.endsWith('_sclk') || s.endsWith('_clk') || s.endsWith('_sck')) return 'sclk';
            return null;
        }

        function checkPinConflicts() {
            const pinUsage = {};
            const errors = [];
            const warnings = [];
            const platform = String(selectedBoard?.platform || selectedPlatform || '').toLowerCase();

            document.querySelectorAll('.pin-input').forEach(input => {
                const raw = (input.value || '').trim();
                const signal = input.dataset.pin;

                input.classList.remove('conflict', 'valid');
                const oldStatus = input.nextElementSibling;
                if (oldStatus && oldStatus.classList.contains('pin-status')) {
                    oldStatus.remove();
                }

                if (!raw) return;

                let key;
                if (/^-?\d+$/.test(raw)) {
                    const pinNum = parseInt(raw, 10);
                    if (Number.isNaN(pinNum) || pinNum < 0) return;
                    key = pinNum;
                } else {
                    key = raw;
                }

                if (typeof key === 'number' && platform === 'esp32') {
                    if (key > 39) {
                        errors.push({ pin: key, signals: [signal], reason: `GPIO${key} is out of range for ESP32 (0-39)` });
                    } else if (key >= 6 && key <= 11) {
                        errors.push({ pin: key, signals: [signal], reason: `GPIO${key} is reserved for SPI flash` });
                    }
                    const ioType = signalIoType(signal);
                    if ((ioType === 'output' || ioType === 'bidirectional') && key >= 34 && key <= 39) {
                        errors.push({ pin: key, signals: [signal], reason: `GPIO${key} is input-only on ESP32` });
                    }
                    if ([0, 2, 4, 5, 12, 15].includes(key)) {
                        warnings.push({ pin: key, signals: [signal], reason: `GPIO${key} is a strapping pin; use with caution` });
                    }
                }

                if (!pinUsage[key]) pinUsage[key] = [];
                if (!pinUsage[key].includes(signal)) pinUsage[key].push(signal);
            });

            Object.entries(pinUsage).forEach(([pin, signals]) => {
                if (signals.length <= 1) return;
                const kinds = signals.map(spiShareKind);
                const shareableSpi = kinds.every(k => k !== null) && (new Set(kinds)).size === 1;
                if (!shareableSpi) {
                    errors.push({
                        pin,
                        signals,
                        reason: `Pin ${pin} is assigned to ${signals.join(' and ')}`
                    });
                }
            });

            const conflictSignals = new Set();
            errors.forEach(e => {
                (e.signals || []).forEach(s => conflictSignals.add(s));
            });
            document.querySelectorAll('.pin-input').forEach(input => {
                const signal = input.dataset.pin;
                const status = document.createElement('span');
                if (conflictSignals.has(signal)) {
                    input.classList.add('conflict');
                    status.className = 'pin-status error';
                    status.textContent = '❌';
                    status.title = 'Pin assignment issue';
                } else {
                    input.classList.add('valid');
                    status.className = 'pin-status ok';
                    status.textContent = '✓';
                    status.title = 'Pin assignment looks valid';
                }
                input.after(status);
            });

            const pinPanel = document.getElementById('pin-validation');
            if (pinPanel) {
                if (errors.length === 0 && warnings.length === 0) {
                    pinPanel.innerHTML = `
                        <div class="validation-item info">
                            <span class="validation-icon">✅</span>
                            <div>No pin conflicts detected.</div>
                        </div>
                    `;
                } else {
                    const errorHtml = errors.map(conflict => `
                        <div class="validation-item error">
                            <span class="validation-icon">❌</span>
                            <div>${conflict.reason}</div>
                        </div>
                    `).join('');
                    const warnHtml = warnings.map(warn => `
                        <div class="validation-item warning">
                            <span class="validation-icon">⚠️</span>
                            <div>${warn.reason}</div>
                        </div>
                    `).join('');
                    pinPanel.innerHTML = `${errorHtml}${warnHtml}`;
                }
            }

            return { errors, warnings };
        }

        function updateValidation() {
            const validationPanel = document.getElementById('validation-warnings');
            if (!validationPanel) return;

            const issues = buildValidationIssues({ includePins: true });

            if (issues.length === 0) {
                validationPanel.innerHTML = `
                    <div class="validation-item info">
                        <span class="validation-icon">✅</span>
                        <div>Configuration is valid!</div>
                    </div>
                `;
            } else {
                validationPanel.innerHTML = issues.map(issue => `
                    <div class="validation-item ${issue.type}">
                        <span class="validation-icon">
                            ${issue.type === 'error' ? '❌' : issue.type === 'warning' ? '⚠️' : 'ℹ️'}
                        </span>
                        <div>${issue.message}</div>
                    </div>
                `).join('');
            }
            updateMemoryEstimatePanels();
            renderStatusChips();
            renderBuildHealthBar();
            if (currentStep === FINAL_STEP) {
                renderReviewChecklist();
            }
            updateFinalActionState();
            updateStepGuidance();
        }

        function showWarning(message) {
            console.warn(message);
            notify(message, 'warning');
        }

        function initModuleFilters() {
            const searchInput = document.getElementById('module-search');
            const showEnabledOnly = document.getElementById('show-enabled-only');

            function filterModules() {
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
                const enabledOnly = showEnabledOnly ? showEnabledOnly.checked : false;

                document.querySelectorAll('.module-card').forEach(card => {
                    const moduleId = card.id.replace('module-card-', '');
                    const module = modules.find(m => m.id === moduleId);
                    if (!module) return;

                    let show = true;

                    if (searchTerm) {
                        const matchesSearch =
                            (module.name || '').toLowerCase().includes(searchTerm) ||
                            (module.description || '').toLowerCase().includes(searchTerm) ||
                            module.id.toLowerCase().includes(searchTerm);
                        if (!matchesSearch) show = false;
                    }

                    if (enabledOnly && !module.enabled) {
                        show = false;
                    }

                    card.style.display = show ? 'block' : 'none';
                });

                document.querySelectorAll('.module-section').forEach(section => {
                    const visible = Array.from(section.querySelectorAll('.module-card'))
                        .some(card => card.style.display !== 'none');
                    section.style.display = visible ? 'block' : 'none';
                });
            }

            if (searchInput) searchInput.oninput = filterModules;
            if (showEnabledOnly) showEnabledOnly.onchange = filterModules;
            filterModules();
        }

        function setAllModuleSections(open) {
            document.querySelectorAll('.module-section').forEach(section => {
                section.open = open;
                const key = section.dataset.group;
                if (key) moduleSectionState[key] = open;
            });
        }

        function refreshModuleSectionCounts() {
            document.querySelectorAll('.module-section').forEach(section => {
                const cards = Array.from(section.querySelectorAll('.module-card'));
                const enabled = cards.filter(card => card.classList.contains('enabled')).length;
                const badge = section.querySelector('.module-section-count');
                if (badge) badge.textContent = `${enabled}/${cards.length} enabled`;
            });
        }
        

        const DEFAULT_WIZARD_STEPS = [
            { id: 'platform_board', title: 'Platform & Board' },
            { id: 'drivers', title: 'Drivers' },
            { id: 'runtime_options', title: 'Runtime Options' },
            { id: 'generate', title: 'Generate' }
        ];
        const DEFAULT_BOARD_FILTER_SCHEMA = [
            { id: 'manufacturer', title: 'Manufacturer', all_label: 'All manufacturers' },
            { id: 'architecture', title: 'Architecture', all_label: 'All architectures' },
            { id: 'family', title: 'Family', all_label: 'All families' },
            { id: 'silicon', title: 'Processor / Silicon', all_label: 'All processors' }
        ];
        let wizardSteps = [...DEFAULT_WIZARD_STEPS];
        let boardFilterSchema = [...DEFAULT_BOARD_FILTER_SCHEMA];
        let FINAL_STEP = wizardSteps.length;

        function getBoardFilterDef(id) {
            return boardFilterSchema.find((item) => item.id === id)
                || DEFAULT_BOARD_FILTER_SCHEMA.find((item) => item.id === id)
                || { id, title: id, all_label: 'All' };
        }

        function getWizardSections() {
            const sections = [];
            for (let idx = 1; idx <= 12; idx++) {
                const section = document.getElementById(`step-${idx}`);
                if (!section) break;
                sections.push(section);
            }
            return sections;
        }

        function renderWizardStepContainer() {
            const wrap = document.querySelector('.wizard-steps');
            if (!wrap) return;
            const sectionCount = getWizardSections().length;
            const visibleCount = Math.max(1, Math.min(wizardSteps.length, sectionCount || wizardSteps.length));
            FINAL_STEP = visibleCount;
            if (currentStep > FINAL_STEP) currentStep = FINAL_STEP;

            const html = [];
            for (let i = 0; i < visibleCount; i++) {
                const step = wizardSteps[i] || {};
                const title = String(step.title || `Step ${i + 1}`);
                html.push(
                    `<div class="step" data-step="${i + 1}">` +
                    `<div class="step-number">${i + 1}</div>` +
                    `<div class="step-title">${title}</div>` +
                    `</div>`
                );
            }
            wrap.innerHTML = html.join('');
            wrap.querySelectorAll('.step').forEach((stepEl) => {
                stepEl.addEventListener('click', () => {
                    const target = Number(stepEl.dataset.step || '1');
                    if (target >= 1 && target <= FINAL_STEP) {
                        if (target > currentStep) {
                            for (let s = currentStep; s < target; s++) {
                                const readiness = getCurrentStepReadiness(s);
                                if (!readiness.ready) {
                                    notify(readiness.reason, 'warning');
                                    updateStepGuidance();
                                    return;
                                }
                            }
                        }
                        currentStep = target;
                        updateWizardSteps();
                    }
                });
            });
        }

        function applyBoardFilterSchema(filters) {
            if (!Array.isArray(filters) || filters.length === 0) return;
            const normalized = filters
                .filter(Boolean)
                .map((f, idx) => ({
                    id: String(f.id || `filter_${idx + 1}`),
                    title: String(f.title || `Filter ${idx + 1}`),
                    all_label: String(f.all_label || 'All')
                }))
                .filter((f) => ['manufacturer', 'architecture', 'family', 'silicon'].includes(f.id));
            if (!normalized.length) return;
            boardFilterSchema = normalized;

            const labelMap = {
                manufacturer: 'manufacturer-select',
                architecture: 'architecture-select',
                family: 'family-select',
                silicon: 'silicon-select'
            };
            Object.entries(labelMap).forEach(([id, selectId]) => {
                const labelEl = document.querySelector(`label[for="${selectId}"]`);
                if (labelEl) labelEl.textContent = getBoardFilterDef(id).title;
            });
        }

        function applyWizardSchema(steps) {
            if (!Array.isArray(steps) || steps.length === 0) return;
            const normalized = steps
                .filter(Boolean)
                .map((step, idx) => ({
                    id: String(step.id || `step_${idx + 1}`),
                    title: String(step.title || `Step ${idx + 1}`)
                }));
            if (!normalized.length) return;

            wizardSteps = normalized;
            renderWizardStepContainer();
        }

        async function loadWizardSchema() {
            try {
                const payload = await apiFetchJson('/api/wizard/steps');
                if (payload?.success && Array.isArray(payload.steps)) {
                    applyWizardSchema(payload.steps);
                } else {
                    applyWizardSchema(DEFAULT_WIZARD_STEPS);
                }
            } catch (err) {
                console.warn('Failed to load wizard schema:', err);
                applyWizardSchema(DEFAULT_WIZARD_STEPS);
            }
        }

        async function loadBoardFilterSchema() {
            try {
                const payload = await apiFetchJson('/api/wizard/board-filters');
                if (payload?.success && Array.isArray(payload.filters)) {
                    applyBoardFilterSchema(payload.filters);
                } else {
                    applyBoardFilterSchema(DEFAULT_BOARD_FILTER_SCHEMA);
                }
            } catch (err) {
                console.warn('Failed to load board filter schema:', err);
                applyBoardFilterSchema(DEFAULT_BOARD_FILTER_SCHEMA);
            }
        }

        // State
        let currentStep = 1;
        let selectedPlatform = '';
        let selectedBoard = null;
        let selectedManufacturer = '';
        let selectedArchitecture = '';
        let selectedFamily = '';
        let selectedSilicon = '';
        let taxonomyOptions = null;
        let pendingBoardIdFromUrl = '';
        let pendingSearchFromUrl = '';
        let pendingOpenFromUrl = '';
        let pendingStepFromUrl = 0;
        let loadedPlatformForModules = '';
        let loadedPlatformForMarket = '';
        let moduleStates = {};
        let serialPort = null;
        let serialReader = null;
        let serialWriter = null;
        let serialReadAbort = false;
        const CONFIG_DRAFT_KEY = 'basalt.configurator.draft.v1';
        let lastDraftSavedAt = 0;
        let avrSettings = {
            clock: { freq_hz: 16000000 },
            fuses: { lfuse: '', hfuse: '', efuse: '', lock: '' },
            upload: { method: 'bootloader', fqbn: 'arduino:avr:mega', mcu: 'atmega2560', programmer: 'wiring', baud: 115200, port: '' }
        };

        function loadConfigDraft() {
            try {
                const raw = window.localStorage.getItem(CONFIG_DRAFT_KEY);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : null;
            } catch (_err) {
                return null;
            }
        }

        function saveConfigDraft() {
            try {
                const enabledDrivers = modules.filter(m => m.enabled).map(m => m.id);
                const enabledApplets = Object.keys(appletStates || {}).filter(k => !!appletStates[k]);
                const enabledMarketApps = Object.keys(marketAppStates || {}).filter(k => !!marketAppStates[k]);
                const draft = {
                    ts: Date.now(),
                    step: currentStep,
                    platform: selectedPlatform || '',
                    board_id: selectedBoard?.id || '',
                    manufacturer: selectedManufacturer || '',
                    architecture: selectedArchitecture || '',
                    family: selectedFamily || '',
                    silicon: selectedSilicon || '',
                    q: String(document.getElementById('board-search')?.value || ''),
                    enabled_drivers: enabledDrivers,
                    applets: enabledApplets,
                    market_apps: enabledMarketApps
                };
                window.localStorage.setItem(CONFIG_DRAFT_KEY, JSON.stringify(draft));
                lastDraftSavedAt = Date.now();
            } catch (_err) {}
        }

        function updateResumeCta() {
            const btn = document.getElementById('btn-resume-last');
            const meta = document.getElementById('resume-last-meta');
            if (!btn || !meta) return;
            const draft = loadConfigDraft();
            if (!draft || !draft.board_id) {
                btn.style.display = 'none';
                meta.style.display = 'none';
                meta.textContent = '';
                return;
            }
            const when = draft.ts ? new Date(draft.ts).toLocaleString() : 'earlier';
            btn.style.display = 'inline-block';
            meta.style.display = 'block';
            meta.textContent = `Resume saved session: ${draft.board_id} (${when})`;
        }

        async function resumeLastSession() {
            const draft = loadConfigDraft();
            if (!draft) {
                notify('No saved session found yet.', 'warning');
                updateResumeCta();
                return;
            }
            selectedPlatform = String(draft.platform || '');
            selectedManufacturer = String(draft.manufacturer || '');
            selectedArchitecture = String(draft.architecture || '');
            selectedFamily = String(draft.family || '');
            selectedSilicon = String(draft.silicon || '');
            pendingBoardIdFromUrl = String(draft.board_id || '');
            pendingSearchFromUrl = String(draft.q || '');

            const platformSel = document.getElementById('platform-select');
            if (platformSel) platformSel.value = selectedPlatform;
            const searchInput = document.getElementById('board-search');
            if (searchInput) searchInput.value = pendingSearchFromUrl;

            await refreshTaxonomyOptionsFromApi().catch(err => {
                console.warn('Failed to refresh taxonomy options:', err);
            });
            await refreshBoardsForCurrentFilters({ force: true });
            populateBoardList();

            if (pendingBoardIdFromUrl) {
                const target = allBoardsFlat().find(b => String(b?.id || '') === pendingBoardIdFromUrl);
                if (target) {
                    await selectBoard(target, null);
                    populateBoardList();
                }
            }

            const enabledDriverSet = new Set(Array.isArray(draft.enabled_drivers) ? draft.enabled_drivers.map(String) : []);
            if (enabledDriverSet.size > 0 && selectedBoard) {
                const caps = boardCapabilitiesSet(selectedBoard);
                modules.forEach(m => {
                    m.enabled = enabledDriverSet.has(String(m.id)) && moduleAllowed(m, caps);
                });
            }
            if (Array.isArray(draft.applets) && selectedBoard) {
                const allowed = new Set(availableAppletsForBoard(selectedBoard));
                appletStates = {};
                draft.applets.forEach(id => {
                    const key = String(id);
                    if (allowed.has(key)) appletStates[key] = true;
                });
            }
            if (Array.isArray(draft.market_apps) && selectedBoard) {
                const allowed = new Set(availableMarketAppsForBoard(selectedBoard).map(x => x.id));
                marketAppStates = {};
                draft.market_apps.forEach(id => {
                    const key = String(id);
                    if (allowed.has(key)) marketAppStates[key] = true;
                });
            }

            populateModuleGrid();
            renderSelectedAppsVisibility();
            renderRuntimeOptionsPanel();
            updateMemoryEstimatePanels();
            currentStep = Math.max(1, Math.min(FINAL_STEP, Number(draft.step) || 1));
            enterConfigurator(currentStep);
            notify('Resumed previous session.', 'success');
            saveConfigDraft();
            updateResumeCta();
        }

        // Initialize
        async function init() {
            loadFilterStateFromUrl();
            await loadWizardSchema();
            await loadBoardFilterSchema();
            initBoardPerfPanel();
            const ok = await loadFromApi();
            await populatePlatformSelect();
            const searchInput = document.getElementById('board-search');
            if (searchInput && pendingSearchFromUrl) searchInput.value = pendingSearchFromUrl;
            try {
                await refreshTaxonomyOptionsFromApi();
            } catch (err) {
                console.warn('Failed to load taxonomy options:', err);
            }
            await refreshBoardsForCurrentFilters({ force: true });
            if (!ok || !platforms || platforms.length === 0) {
                showPlatformError('No platforms loaded. Check http://localhost:5000/api/platforms');
            }
            populateBoardList();
            if (pendingBoardIdFromUrl) {
                const target = allBoardsFlat().find(b => String(b?.id || '') === pendingBoardIdFromUrl);
                if (target) {
                    await selectBoard(target, null);
                    populateBoardList();
                }
                pendingBoardIdFromUrl = '';
            }
            persistFilterStateToUrl();
            populateModuleGrid();
            updateLandingStats();
            applyLocalScopeMode();
            showLanding();
            renderSelectedAppsVisibility();
            renderRuntimeOptionsPanel();
            bindAdvancedPinConfigToggle();
            attachEventListeners();
            updateResumeCta();
            if (pendingOpenFromUrl === 'config') {
                const startStep = Math.max(1, Math.min(FINAL_STEP, pendingStepFromUrl || 1));
                enterConfigurator(startStep);
            }
            const flasherBtn = document.getElementById('btn-refresh-flasher');
            if (flasherBtn) {
                flasherBtn.addEventListener('click', () => refreshWebFlasher());
            }
            const releaseBtn = document.getElementById('btn-release-serial');
            if (releaseBtn) {
                releaseBtn.addEventListener('click', () => releaseBrowserSerialPorts());
            }
            const localFlashBtn = document.getElementById('btn-local-flash');
            if (localFlashBtn) {
                localFlashBtn.addEventListener('click', () => localFlashEsp32());
            }
            const avrRefreshBtn = document.getElementById('btn-refresh-avr-flasher');
            if (avrRefreshBtn) avrRefreshBtn.addEventListener('click', () => refreshAvrFlasher());
            const avrBuildBtn = document.getElementById('btn-build-avr');
            if (avrBuildBtn) avrBuildBtn.addEventListener('click', () => buildAvrFirmware());
            const avrFlashBtn = document.getElementById('btn-local-flash-avr');
            if (avrFlashBtn) avrFlashBtn.addEventListener('click', () => localFlashAvr());
            const avrAdvancedToggle = document.getElementById('avr-advanced-toggle');
            if (avrAdvancedToggle) {
                avrAdvancedToggle.addEventListener('change', () => {
                    const enabled = !!avrAdvancedToggle.checked;
                    setAvrAdvancedEditing(enabled);
                    if (enabled) {
                        notify('Advanced AVR clock/fuse editing enabled.', 'warning');
                    }
                });
            }
            const avrRestoreDefaultsBtn = document.getElementById('btn-avr-restore-defaults');
            if (avrRestoreDefaultsBtn) {
                avrRestoreDefaultsBtn.addEventListener('click', () => restoreAvrDefaults());
            }
            const serialConnectBtn = document.getElementById('btn-serial-connect');
            if (serialConnectBtn) serialConnectBtn.addEventListener('click', () => serialConnect());
            const serialDisconnectBtn = document.getElementById('btn-serial-disconnect');
            if (serialDisconnectBtn) serialDisconnectBtn.addEventListener('click', () => serialDisconnect());
            const serialClearBtn = document.getElementById('btn-serial-clear');
            if (serialClearBtn) {
                serialClearBtn.addEventListener('click', () => {
                    const log = document.getElementById('serial-log');
                    if (log) log.textContent = '';
                });
            }
            const serialSendBtn = document.getElementById('btn-serial-send');
            if (serialSendBtn) serialSendBtn.addEventListener('click', () => serialSendCommand());
            const serialCmdInput = document.getElementById('serial-command');
            if (serialCmdInput) {
                serialCmdInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        serialSendCommand();
                    }
                });
            }
            const avrMethod = document.getElementById('avr-upload-method');
            if (avrMethod) {
                avrMethod.addEventListener('change', () => {
                    const method = String(avrMethod.value || '').trim().toLowerCase();
                    const prog = document.getElementById('avr-programmer');
                    if (!prog) return;
                    if (method === 'updi' && !String(prog.value || '').trim()) prog.value = 'serialupdi';
                    if (method === 'bootloader' && !String(prog.value || '').trim()) prog.value = 'wiring';
                });
            }
            updateMemoryEstimatePanels();
            refreshSerialTerminalVisibility();
            notify('Welcome to BasaltOS Configurator.', 'success', 1800);
            saveConfigDraft();
        }

        function buildBoardGroups(filteredBoards) {
            const groups = {};
            filteredBoards.forEach(board => {
                const tx = boardTaxonomy(board);
                const group = `${tx.manufacturer} • ${tx.architecture} • ${tx.family}`;
                if (!groups[group]) groups[group] = [];
                groups[group].push(board);
            });
            return Object.keys(groups)
                .sort()
                .map(groupName => ({
                    groupName,
                    boards: groups[groupName].sort((a, b) => String(a.name).localeCompare(String(b.name)))
                }));
        }

        function boardItemElementId(boardId) {
            const raw = String(boardId || '').trim();
            const safe = raw.replace(/[^A-Za-z0-9_-]/g, '-');
            return `board-opt-${safe || 'unknown'}`;
        }

        function boardFlatIndexById(boardId) {
            const id = String(boardId || '');
            return boardKeyboardFlatItems.findIndex(b => String(b?.id || '') === id);
        }

        function flattenBoardsFromGroups(groupEntries) {
            return (groupEntries || []).flatMap(g => (Array.isArray(g?.boards) ? g.boards : []));
        }

        function syncRenderedBoardSelection(selectedId, selectedEl = null) {
            document.querySelectorAll('.board-item').forEach(item => {
                const isSel = String(item.dataset.boardId || '') === String(selectedId || '');
                item.classList.toggle('selected', isSel);
                item.setAttribute('aria-selected', isSel ? 'true' : 'false');
                item.tabIndex = -1;
            });
            const boardList = document.getElementById('board-list');
            let targetEl = selectedEl || null;
            if (!targetEl && selectedId) {
                targetEl = Array.from(document.querySelectorAll('.board-item')).find(item => String(item.dataset.boardId || '') === String(selectedId)) || null;
            }
            if (targetEl) {
                targetEl.tabIndex = 0;
                if (boardList) boardList.setAttribute('aria-activedescendant', targetEl.id);
            } else if (boardList) {
                boardList.removeAttribute('aria-activedescendant');
            }
        }

        function announceBoardListStatus(totalBoards, totalGroups) {
            const status = document.getElementById('board-list-status');
            if (!status) return;
            if (!totalBoards) {
                status.textContent = 'No boards match your current filters.';
                return;
            }
            const groupCount = Number.isFinite(totalGroups) ? totalGroups : 0;
            status.textContent = `${totalBoards} board${totalBoards === 1 ? '' : 's'} available across ${groupCount} group${groupCount === 1 ? '' : 's'}.`;
        }

        function ensureBoardVisibleForKeyboard(index) {
            if (!boardVirtualEnabled) return;
            const boardList = document.getElementById('board-list');
            if (!boardList) return;
            const rowIndex = boardVirtualRows.findIndex(r => r.type === 'item' && String(r.board?.id || '') === String(boardKeyboardFlatItems[index]?.id || ''));
            if (rowIndex < 0) return;
            const y = boardVirtualOffsets[rowIndex] || 0;
            const rowH = boardVirtualRowHeight(boardVirtualRows[rowIndex]);
            const top = boardList.scrollTop || 0;
            const bottom = top + Math.max(boardList.clientHeight || 1, 1);
            if (y < top) boardList.scrollTop = y;
            else if ((y + rowH) > bottom) boardList.scrollTop = Math.max(0, y - Math.floor((boardList.clientHeight || 1) / 2));
            renderBoardVirtualWindow();
        }

        async function focusBoardKeyboardIndex(nextIndex, { select = false } = {}) {
            if (!boardKeyboardFlatItems.length) return;
            const bounded = Math.max(0, Math.min(nextIndex, boardKeyboardFlatItems.length - 1));
            boardKeyboardIndex = bounded;
            ensureBoardVisibleForKeyboard(boardKeyboardIndex);
            const board = boardKeyboardFlatItems[boardKeyboardIndex];
            const el = document.getElementById(boardItemElementId(board?.id));
            const boardList = document.getElementById('board-list');
            if (el) {
                document.querySelectorAll('.board-item').forEach(item => { item.tabIndex = -1; });
                el.tabIndex = 0;
                if (boardList) boardList.setAttribute('aria-activedescendant', el.id);
                try { el.focus({ preventScroll: true }); } catch (_e) { el.focus(); }
                if (select) await selectBoard(board, el);
            }
        }

        async function handleBoardListKeydown(event) {
            if (!boardKeyboardFlatItems.length) return;
            const key = String(event.key || '');
            const selecting = key === 'Enter' || key === ' ';
            const moving = key === 'ArrowDown' || key === 'ArrowUp' || key === 'Home' || key === 'End';
            if (!selecting && !moving) return;
            event.preventDefault();

            if (boardKeyboardIndex < 0) {
                const selectedIdx = selectedBoard ? boardFlatIndexById(selectedBoard.id) : -1;
                boardKeyboardIndex = selectedIdx >= 0 ? selectedIdx : 0;
            }

            if (key === 'ArrowDown') boardKeyboardIndex += 1;
            else if (key === 'ArrowUp') boardKeyboardIndex -= 1;
            else if (key === 'Home') boardKeyboardIndex = 0;
            else if (key === 'End') boardKeyboardIndex = boardKeyboardFlatItems.length - 1;

            await focusBoardKeyboardIndex(boardKeyboardIndex, { select: selecting });
        }

        function createBoardGroupTitleNode(groupName, count) {
            const title = document.createElement('li');
            title.className = 'board-group-title board-group-title-row';
            title.textContent = `${groupName} (${count})`;
            title.setAttribute('role', 'presentation');
            title.setAttribute('aria-hidden', 'true');
            return title;
        }

        function createBoardItemNode(board) {
            const li = document.createElement('li');
            li.className = 'board-item';
            const tx = boardTaxonomy(board);
            li.textContent = board.name;
            li.title = `${tx.silicon} • ${String(board.platform || '').toUpperCase()}`;
            li.dataset.boardId = board.id;
            li.id = boardItemElementId(board.id);
            li.setAttribute('role', 'option');
            li.tabIndex = -1;
            if (selectedBoard && String(selectedBoard.id) === String(board.id)) {
                li.classList.add('selected');
            }
            li.setAttribute('aria-selected', li.classList.contains('selected') ? 'true' : 'false');
            li.onclick = async () => {
                const idx = boardFlatIndexById(board.id);
                if (idx >= 0) boardKeyboardIndex = idx;
                await selectBoard(board, li);
            };
            li.onkeydown = async (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    const idx = boardFlatIndexById(board.id);
                    if (idx >= 0) boardKeyboardIndex = idx;
                    await selectBoard(board, li);
                }
            };
            return li;
        }

        function boardVirtualRowHeight(row) {
            return row.type === 'group' ? BOARD_VIRTUAL_GROUP_ROW_H : BOARD_VIRTUAL_ITEM_ROW_H;
        }

        function prepareBoardVirtualRows(groupEntries) {
            const rows = [];
            groupEntries.forEach(g => {
                rows.push({ type: 'group', groupName: g.groupName, count: g.boards.length });
                g.boards.forEach(board => rows.push({ type: 'item', board }));
            });
            const offsets = new Array(rows.length);
            let y = 0;
            for (let i = 0; i < rows.length; i++) {
                offsets[i] = y;
                y += boardVirtualRowHeight(rows[i]);
            }
            boardVirtualRows = rows;
            boardVirtualOffsets = offsets;
            boardVirtualTotalHeight = y;
            boardVirtualItemCount = rows.filter(r => r.type === 'item').length;
        }

        function findBoardVirtualRowIndex(y) {
            if (!boardVirtualOffsets.length) return 0;
            let lo = 0;
            let hi = boardVirtualOffsets.length - 1;
            while (lo < hi) {
                const mid = Math.floor((lo + hi + 1) / 2);
                if (boardVirtualOffsets[mid] <= y) lo = mid;
                else hi = mid - 1;
            }
            return lo;
        }

        function renderBoardVirtualWindow() {
            if (!boardVirtualEnabled) return;
            const boardList = document.getElementById('board-list');
            if (!boardList) return;
            const t0 = performance.now();
            const viewportH = Math.max(boardList.clientHeight || 0, 1);
            const scrollTop = Math.max(boardList.scrollTop || 0, 0);
            const startY = Math.max(0, scrollTop - BOARD_VIRTUAL_OVERSCAN_PX);
            const endY = Math.max(startY, scrollTop + viewportH + BOARD_VIRTUAL_OVERSCAN_PX);
            const startIdx = findBoardVirtualRowIndex(startY);
            const endIdx = Math.min(boardVirtualRows.length - 1, findBoardVirtualRowIndex(endY));
            const topPad = boardVirtualOffsets[startIdx] || 0;
            const endBottom = (boardVirtualOffsets[endIdx] || 0) + boardVirtualRowHeight(boardVirtualRows[endIdx]);
            const bottomPad = Math.max(0, boardVirtualTotalHeight - endBottom);

            boardList.innerHTML = '';
            const frag = document.createDocumentFragment();
            if (topPad > 0) {
                const spacerTop = document.createElement('li');
                spacerTop.className = 'board-virtual-spacer';
                spacerTop.style.height = `${topPad}px`;
                frag.appendChild(spacerTop);
            }
            for (let i = startIdx; i <= endIdx; i++) {
                const row = boardVirtualRows[i];
                if (row.type === 'group') frag.appendChild(createBoardGroupTitleNode(row.groupName, row.count));
                else frag.appendChild(createBoardItemNode(row.board));
            }
            if (bottomPad > 0) {
                const spacerBottom = document.createElement('li');
                spacerBottom.className = 'board-virtual-spacer';
                spacerBottom.style.height = `${bottomPad}px`;
                frag.appendChild(spacerBottom);
            }
            boardList.appendChild(frag);
            boardLastRenderMs = performance.now() - t0;
            updateBoardPerfPanel({
                mode: 'virtual',
                totalRows: boardVirtualRows.length,
                renderedRows: Math.max(0, endIdx - startIdx + 1),
                totalBoards: boardVirtualItemCount,
                ms: boardLastRenderMs,
            });
        }

        function scheduleBoardVirtualRender() {
            if (!boardVirtualEnabled) return;
            if (boardVirtualRafId) return;
            boardVirtualRafId = window.requestAnimationFrame(() => {
                boardVirtualRafId = 0;
                renderBoardVirtualWindow();
            });
        }

        function renderBoardListFull(groupEntries) {
            const boardList = document.getElementById('board-list');
            if (!boardList) return;
            const t0 = performance.now();
            boardList.innerHTML = '';
            const frag = document.createDocumentFragment();
            groupEntries.forEach(g => {
                const groupWrap = document.createElement('li');
                groupWrap.className = 'board-group';
                groupWrap.setAttribute('role', 'presentation');
                groupWrap.appendChild(createBoardGroupTitleNode(g.groupName, g.boards.length));
                g.boards.forEach(board => groupWrap.appendChild(createBoardItemNode(board)));
                frag.appendChild(groupWrap);
            });
            boardList.appendChild(frag);
            boardLastRenderMs = performance.now() - t0;
            const totalRows = groupEntries.reduce((n, g) => n + g.boards.length + 1, 0);
            const totalBoards = groupEntries.reduce((n, g) => n + g.boards.length, 0);
            updateBoardPerfPanel({
                mode: 'full',
                totalRows,
                renderedRows: totalRows,
                totalBoards,
                ms: boardLastRenderMs,
            });
        }

        function populateBoardList() {
            const boardList = document.getElementById('board-list');
            if (!boardList) return;
            boardList.innerHTML = '';
            boardList.classList.remove('virtualized');
            boardList.removeAttribute('aria-activedescendant');
            boardVirtualEnabled = false;
            boardVirtualRows = [];
            boardVirtualOffsets = [];
            boardVirtualTotalHeight = 0;
            boardVirtualItemCount = 0;
            boardKeyboardFlatItems = [];
            boardKeyboardIndex = -1;
            if (boardVirtualRafId) {
                window.cancelAnimationFrame(boardVirtualRafId);
                boardVirtualRafId = 0;
            }
            boardList.onscroll = null;

            syncHierarchySelectors();
            const filteredBoards = applyHierarchyFilters();
            const platformSet = new Set(filteredBoards.map(b => String(b.platform || '')).filter(Boolean));
            if (platformSet.size === 1) {
                selectedPlatform = Array.from(platformSet)[0];
            } else if (!selectedBoard) {
                selectedPlatform = '';
            }
            const platformSelect = document.getElementById('platform-select');
            if (platformSelect) platformSelect.value = selectedPlatform || '';
            if (!filteredBoards.length) {
                boardList.innerHTML = `<li class="board-empty">No boards match your current filter.<br>${buildBoardEmptyHint()}</li>`;
                boardLastRenderMs = 0;
                updateBoardPerfPanel({ mode: 'empty', totalRows: 0, renderedRows: 0, totalBoards: 0, ms: 0 });
                announceBoardListStatus(0, 0);
                renderHardwarePath();
                persistFilterStateToUrl();
                return;
            }

            const groupEntries = buildBoardGroups(filteredBoards);
            boardKeyboardFlatItems = flattenBoardsFromGroups(groupEntries);
            const totalRows = groupEntries.reduce((n, g) => n + g.boards.length + 1, 0);
            if (totalRows > BOARD_VIRTUAL_ROW_THRESHOLD) {
                prepareBoardVirtualRows(groupEntries);
                boardVirtualEnabled = true;
                boardList.classList.add('virtualized');
                boardList.onscroll = () => scheduleBoardVirtualRender();
                renderBoardVirtualWindow();
            } else {
                renderBoardListFull(groupEntries);
            }
            announceBoardListStatus(boardKeyboardFlatItems.length, groupEntries.length);
            const selectedIdx = selectedBoard ? boardFlatIndexById(selectedBoard.id) : -1;
            if (selectedIdx >= 0) {
                boardKeyboardIndex = selectedIdx;
                ensureBoardVisibleForKeyboard(boardKeyboardIndex);
                const selectedEl = document.getElementById(boardItemElementId(selectedBoard.id));
                syncRenderedBoardSelection(selectedBoard.id, selectedEl || null);
            } else if (boardKeyboardFlatItems.length === 1) {
                const onlyBoard = boardKeyboardFlatItems[0];
                queueMicrotask(async () => {
                    if (selectedBoard && String(selectedBoard.id) === String(onlyBoard.id)) return;
                    try {
                        await selectBoard(onlyBoard, null);
                        populateBoardList();
                        notify(`Auto-selected board: ${onlyBoard.name}`, 'success', 1400);
                    } catch (err) {
                        console.warn('Auto-select single board failed:', err);
                    }
                });
            }
            renderHardwarePath();
            persistFilterStateToUrl();
        }

        async function selectBoard(board, sourceEl) {
            const boardPlatform = String(board?.platform || '').trim();
            const platformChanged = !!boardPlatform && boardPlatform !== selectedPlatform;
            if (platformChanged) {
                selectedPlatform = boardPlatform;
                const platformSelect = document.getElementById('platform-select');
                if (platformSelect) platformSelect.value = selectedPlatform;
            }
            if (boardPlatform && loadedPlatformForModules !== boardPlatform) {
                await refreshModulesForPlatform(boardPlatform);
            }
            if (boardPlatform && loadedPlatformForMarket !== boardPlatform) {
                await refreshMarketCatalogForPlatform(boardPlatform);
            }
            selectedBoard = board;
            const tx = boardTaxonomy(board);
            selectedManufacturer = tx.manufacturer;
            selectedArchitecture = tx.architecture;
            selectedFamily = tx.family;
            selectedSilicon = tx.silicon;
            try {
                await refreshTaxonomyOptionsFromApi();
            } catch (err) {
                console.warn('Failed to refresh taxonomy options after board select:', err);
            }
            await refreshBoardsForCurrentFilters({ force: true });
            
            // Update UI
            document.querySelectorAll('.board-item').forEach(item => {
                item.classList.remove('selected');
            });
            if (sourceEl) sourceEl.classList.add('selected');
            syncRenderedBoardSelection(board.id, sourceEl || null);
            const selectedIdx = boardFlatIndexById(board.id);
            if (selectedIdx >= 0) boardKeyboardIndex = selectedIdx;
            const boardStatus = document.getElementById('board-list-status');
            if (boardStatus) boardStatus.textContent = `${board.name} selected.`;
            
            // Show board details
            document.getElementById('board-details').style.display = 'block';
            document.getElementById('board-name').textContent = board.name;
            document.getElementById('board-description').textContent = board.description;
            document.getElementById('spec-mcu').textContent = board.mcu;
            document.getElementById('spec-flash').textContent = board.flash;
            document.getElementById('spec-ram').textContent = board.ram;
            document.getElementById('spec-display').textContent = board.display;
            const targetId = board.target_profile;
            const targetName = targetId && targets[targetId] ? targets[targetId].name : (targetId || '—');
            document.getElementById('spec-target').textContent = targetName;
            
            const activeTemplate = activeTemplateId ? projectTemplates.find(x => x.id === activeTemplateId) : null;
            applyBoardAndTemplateDefaults(board, activeTemplate || null);
            
            const availableApplets = availableAppletsForBoard(board);
            appletStates = {};
            if (board.defaults && Array.isArray(board.defaults.applets)) {
                board.defaults.applets.forEach(id => { appletStates[id] = true; });
            } else {
                availableApplets.forEach(id => { appletStates[id] = false; });
            }

            const availableMarket = availableMarketAppsForBoard(board);
            marketAppStates = {};
            if (board.defaults && Array.isArray(board.defaults.market_apps)) {
                board.defaults.market_apps.forEach(id => { marketAppStates[id] = true; });
            } else {
                availableMarket.forEach(item => { marketAppStates[item.id] = false; });
            }
            if (avrTargetSelected()) {
                avrSettings = defaultAvrSettingsFromBoard(board);
            }
            applyAvrSettingsToUi();
            setAvrAdvancedEditing(false);

            populateModuleGrid();
            renderSelectedAppsVisibility();
            renderRuntimeOptionsPanel();
            const advancedPin = document.getElementById('advanced-pin-config');
            if (advancedPin && advancedPin.open) {
                populatePinTable();
            }
            clearInlineOutput();
            refreshWebFlasher({ silent: true });
            refreshAvrFlasher({ silent: true });
            updateLandingStats();
            updateMemoryEstimatePanels();
            renderHardwarePath();
            persistFilterStateToUrl();
            updateStepGuidance();
        }

        async function quickPickBoardByName(patterns = []) {
            const wantsEsp32 = selectedPlatform !== 'esp32';
            if (wantsEsp32) {
                selectedManufacturer = '';
                selectedArchitecture = '';
                selectedFamily = '';
                selectedSilicon = '';
                selectedPlatform = 'esp32';
                const platformSel = document.getElementById('platform-select');
                if (platformSel) platformSel.value = 'esp32';
                await refreshModulesForPlatform('esp32');
                await refreshMarketCatalogForPlatform('esp32');
            }
            await refreshTaxonomyOptionsFromApi().catch(err => {
                console.warn('Failed to refresh taxonomy options:', err);
            });
            await refreshBoardsForCurrentFilters({ force: true });
            populateBoardList();
            const regs = patterns.map(p => new RegExp(String(p), 'i'));
            const target = allBoardsFlat().find(b => regs.some(r => r.test(String(b?.name || '')) || r.test(String(b?.id || ''))));
            if (!target) {
                notify('Quick pick board not found in current catalog.', 'warning');
                return;
            }
            await selectBoard(target, null);
            populateBoardList();
            notify(`Quick-picked board: ${target.name}`, 'success');
        }

        async function applyQuickStartEsp32() {
            selectedManufacturer = 'Espressif';
            selectedArchitecture = '';
            selectedFamily = '';
            selectedSilicon = '';
            selectedPlatform = 'esp32';
            const platformSel = document.getElementById('platform-select');
            if (platformSel) platformSel.value = 'esp32';
            await refreshModulesForPlatform('esp32');
            await refreshMarketCatalogForPlatform('esp32');
            selectedBoard = null;
            const boardDetails = document.getElementById('board-details');
            if (boardDetails) boardDetails.style.display = 'none';
            await refreshTaxonomyOptionsFromApi().catch(err => {
                console.warn('Failed to refresh taxonomy options:', err);
                taxonomyOptions = null;
            });
            await refreshBoardsForCurrentFilters({ force: true });
            populateBoardList();
            populateModuleGrid();
            renderSelectedAppsVisibility();
            updateLandingStats();
            enterConfigurator(1);
        }

        function moduleAllowed(module, caps) {
            if (module.platforms && !module.platforms.includes(selectedPlatform)) return false;
            const targetId = selectedBoard?.target_profile;
            const target = targetId ? targets[targetId] : null;
            const policy = target?.module_policy;
            if (policy && policy.mode === 'allowlist' && Array.isArray(policy.allowed)) {
                if (!policy.allowed.includes(module.id)) return false;
            }
            if (policy && policy.mode === 'denylist' && Array.isArray(policy.denied)) {
                if (policy.denied.includes(module.id)) return false;
            }
            if (caps.size === 0) return true;
            if (caps.has(module.id)) return true;

            // Explicit capability requirements from metadata.
            const reqCaps = Array.isArray(module.requires_capabilities) ? module.requires_capabilities : [];
            if (reqCaps.length > 0) {
                return reqCaps.every(c => caps.has(String(c)));
            }

            if (module.id.startsWith('shell_')) return caps.has('uart');
            if (module.id === 'fs_spiffs') return true; // internal storage
            if (module.id === 'fs_sd') return caps.has('sd_card');
            if (module.id === 'psram') return caps.has('psram');
            if (module.id === 'mic') return caps.has('adc') || caps.has('i2s');
            // Generic transport-backed driver allowance.
            const depends = Array.isArray(module.depends) ? module.depends : [];
            if (depends.includes('i2c')) return caps.has('i2c');
            if (depends.includes('spi')) return caps.has('spi');
            if (depends.includes('adc')) return caps.has('adc');
            if (depends.includes('gpio')) return caps.has('gpio');
            return caps.has(module.id.replace('fs_', ''));
        }

        function driverBucket(module) {
            const id = String(module?.id || '');
            const essential = new Set([
                'gpio', 'uart', 'shell_tiny', 'shell_min', 'shell_full', 'timer', 'spi', 'i2c', 'adc'
            ]);
            const experimental = new Set([
                'imu', 'dht22', 'mic', 'ads1115', 'mcp23017', 'hp4067', 'tp4056', 'display_ssd1306', 'rtc'
            ]);
            if (module?.experimental || experimental.has(id)) return 'experimental';
            if (essential.has(id)) return 'essential';
            return 'advanced';
        }

        function moduleCompatibilityInfo(module, caps, allowed) {
            if (!selectedBoard) {
                return { level: 'warn', text: 'Pick a board to check compatibility' };
            }
            if (allowed) {
                return { level: 'ok', text: 'Works on selected board' };
            }
            const reqCaps = Array.isArray(module.requires_capabilities) ? module.requires_capabilities : [];
            if (reqCaps.length > 0) {
                const missing = reqCaps.filter(c => !caps.has(String(c)));
                if (missing.length > 0) {
                    return { level: 'err', text: `Missing capabilities: ${missing.join(', ')}` };
                }
            }
            const deps = Array.isArray(module.depends) ? module.depends : [];
            if (deps.length > 0) {
                return { level: 'warn', text: `Needs: ${deps.join(', ')}` };
            }
            return { level: 'err', text: 'Not available for this board/target' };
        }

        function getBuildHealthState() {
            const issues = buildValidationIssues({ includePins: isAdvancedPinConfigOpen() });
            const errors = issues.filter(i => i.type === 'error').length;
            const warnings = issues.filter(i => i.type === 'warning').length;
            const enabledCount = modules.filter(m => m.enabled).length;
            const mem = estimateMemoryUsage();
            const progPct = mem.caps.prog > 0 ? Math.round((mem.usage.prog / mem.caps.prog) * 100) : 0;
            const ramPct = mem.caps.ram > 0 ? Math.round((mem.usage.ram / mem.caps.ram) * 100) : 0;
            const worstPct = Math.max(progPct, ramPct);
            let level = 'ok';
            let score = 100 - (errors * 35) - (warnings * 10) - (worstPct > 85 ? 20 : 0);
            if (!selectedBoard) {
                level = 'warn';
                score = 35;
            } else if (errors > 0) {
                level = 'err';
            } else if (warnings > 0 || worstPct >= 85) {
                level = 'warn';
            }
            score = Math.max(5, Math.min(100, score));
            return { level, score, errors, warnings, enabledCount, progPct, ramPct, issues };
        }

        function renderStatusChips() {
            const wrap = document.getElementById('status-chips');
            if (!wrap) return;
            const health = getBuildHealthState();
            let pinErrors = 0;
            if (isAdvancedPinConfigOpen()) {
                const pin = checkPinConflicts();
                pinErrors = Array.isArray(pin?.errors) ? pin.errors.length : 0;
            }
            const chips = [];
            if (!selectedBoard) {
                chips.push({ cls: 'warn', text: 'Needs board selection' });
            } else {
                chips.push({ cls: 'ok', text: `${selectedBoard.name}` });
            }
            chips.push({ cls: health.progPct >= 90 ? 'err' : health.progPct >= 80 ? 'warn' : 'ok', text: `Flash ${Math.max(0, health.progPct)}%` });
            chips.push({ cls: health.ramPct >= 90 ? 'err' : health.ramPct >= 80 ? 'warn' : 'ok', text: `RAM ${Math.max(0, health.ramPct)}%` });
            if (pinErrors > 0) {
                chips.push({ cls: 'err', text: `Pin conflicts ${pinErrors}` });
            } else {
                chips.push({ cls: 'ok', text: 'Pins clean' });
            }
            if (health.errors > 0) {
                chips.push({ cls: 'err', text: `${health.errors} errors` });
            } else if (health.warnings > 0) {
                chips.push({ cls: 'warn', text: `${health.warnings} warnings` });
            } else {
                chips.push({ cls: 'ok', text: 'Ready to build' });
            }
            wrap.innerHTML = chips.map(chip => `<span class="status-chip ${chip.cls}">${chip.text}</span>`).join('');
        }

        function renderBuildHealthBar() {
            const meta = document.getElementById('build-health-meta');
            const progress = document.getElementById('build-health-progress');
            const popover = document.getElementById('build-health-issues-popover');
            if (!meta || !progress || !popover) return;
            const h = getBuildHealthState();
            const boardName = selectedBoard?.name || 'No board';
            const issuePillText = h.errors > 0 ? `${h.errors} error(s)` : h.warnings > 0 ? `${h.warnings} warning(s)` : 'Looks good';
            meta.innerHTML = `
                <span class="health-pill ${h.level === 'ok' ? 'ok' : h.level === 'warn' ? 'warn' : 'err'}">Build Health</span>
                <span class="health-pill">${selectedPlatform ? selectedPlatform.toUpperCase() : 'No platform'}</span>
                <span class="health-pill">${boardName}</span>
                <span class="health-pill">Drivers ${h.enabledCount}</span>
                <span class="health-pill ${h.progPct >= 90 ? 'err' : h.progPct >= 80 ? 'warn' : 'ok'}">Flash ${Math.max(0, h.progPct)}%</span>
                <span class="health-pill ${h.ramPct >= 90 ? 'err' : h.ramPct >= 80 ? 'warn' : 'ok'}">RAM ${Math.max(0, h.ramPct)}%</span>
                <span id="build-health-issues-pill" class="health-pill ${h.errors > 0 ? 'err' : h.warnings > 0 ? 'warn' : 'ok'} ${h.issues.length ? 'issues-hover' : ''}">${issuePillText}</span>
            `;
            progress.style.width = `${h.score}%`;
            progress.style.background = h.level === 'err' ? '#ef4444' : h.level === 'warn' ? '#f59e0b' : '#22c55e';
            if (h.issues.length > 0) {
                popover.innerHTML = h.issues.map(issue => `
                    <div class="issues-popover-item">
                        <strong>${issue.type === 'error' ? 'Error' : issue.type === 'warning' ? 'Warning' : 'Info'}:</strong> ${issue.message}
                    </div>
                `).join('');
            } else {
                popover.innerHTML = '<div class="issues-popover-item">No active issues.</div>';
            }
            const issuesPill = document.getElementById('build-health-issues-pill');
            const showPopover = () => {
                if (!h.issues.length) return;
                if (issuesPopoverHideTimer) {
                    clearTimeout(issuesPopoverHideTimer);
                    issuesPopoverHideTimer = null;
                }
                popover.classList.add('active');
            };
            const hidePopover = () => {
                if (issuesPopoverHideTimer) clearTimeout(issuesPopoverHideTimer);
                issuesPopoverHideTimer = setTimeout(() => popover.classList.remove('active'), 120);
            };
            if (issuesPill) {
                issuesPill.onmouseenter = showPopover;
                issuesPill.onmouseleave = hidePopover;
            }
            popover.onmouseenter = () => {
                if (issuesPopoverHideTimer) {
                    clearTimeout(issuesPopoverHideTimer);
                    issuesPopoverHideTimer = null;
                }
            };
            popover.onmouseleave = hidePopover;
        }

        function applyQuickFixes() {
            if (!selectedBoard) {
                notify('Select a platform and board first.', 'warning');
                currentStep = 1;
                updateWizardSteps();
                return;
            }
            const caps = new Set(selectedBoard?.capabilities || []);
            modules.forEach(module => {
                const allowed = moduleAllowed(module, caps);
                if (!allowed && module.enabled) {
                    module.enabled = false;
                }
            });
            optimizeForSize();
            notify('Applied common compatibility + size fixes.', 'success');
        }

        function populateModuleGrid() {
            const grid = document.getElementById('module-grid');
            grid.innerHTML = '';

            const caps = new Set(selectedBoard?.capabilities || []);
            const sectionOrder = ['core', 'connectivity', 'storage', 'ui_shell', 'advanced'];
            const groupedCards = {};
            sectionOrder.forEach(s => { groupedCards[s] = []; });

            modules.forEach(module => {
                const enabled = !!module.enabled;
                moduleStates[module.id] = enabled;
                const bucket = driverBucket(module);
                if (driverView !== 'all' && bucket !== driverView) {
                    return;
                }

                const allowed = moduleAllowed(module, caps);
                const compat = moduleCompatibilityInfo(module, caps, allowed);

                const card = document.createElement('div');
                card.className = `module-card ${enabled ? 'enabled' : ''}`;
                card.id = `module-card-${module.id}`;
                if (!allowed) card.classList.add('disabled');
                const hasOptions = module.configuration_options && module.configuration_options.length > 0;
                const depends = Array.isArray(module.depends) ? module.depends : [];
                const provides = Array.isArray(module.provides) ? module.provides : [];
                const conflicts = Array.isArray(module.conflicts) ? module.conflicts : [];
                const riskyHint = module.id === 'shell_full'
                    ? 'Full shell uses the most RAM/flash. Great for debugging, heavier for small boards.'
                    : module.id === 'shell_min'
                        ? 'Lite shell reduces memory usage but removes some filesystem and utility commands.'
                        : module.id === 'shell_tiny'
                            ? 'Tiny shell is best for constrained boards. Minimal command set.'
                            : module.id === 'fs_sd'
                                ? 'SD requires correct wiring and can add startup delay if card init fails.'
                                : module.id === 'wifi' || module.id === 'bluetooth'
                                    ? 'Wireless drivers add significant memory usage. Keep disabled unless needed.'
                                    : module.id === 'twai'
                                        ? 'Requires an external CAN transceiver and valid TX/RX pin mapping.'
                                        : module.id === 'mcp2544fd'
                                            ? 'Transceiver control only; still requires TWAI and proper CAN bus/transceiver wiring.'
                                            : module.id === 'uln2003'
                                                ? 'Stepper drivers can draw significant current. Use external motor power and common ground.'
                                                : module.id === 'l298n'
                                                    ? 'L298N is power-hungry and can get hot. Use proper motor supply and grounding.'
                                    : '';
                card.innerHTML = `
                    <div class="module-header">
                        <div style="display:flex; align-items:center;">
                            <span class="module-icon">${getModuleIcon(module.id)}</span>
                        <div class="module-name">${module.name}</div>
                        </div>
                        <label class="toggle">
                            <input type="checkbox" ${enabled ? 'checked' : ''} data-module="${module.id}" ${allowed ? '' : 'disabled'}>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="module-description">${module.description || ""}</div>
                    <div class="compat-badge ${compat.level}">${compat.text}</div>
                    <div class="module-badges">
                        ${depends.length ? `<span class="badge badge-dep">Requires: ${depends.join(', ')}</span>` : ''}
                        ${provides.length ? `<span class="badge badge-provides">Provides: ${provides.join(', ')}</span>` : ''}
                        ${conflicts.length ? `<span class="badge badge-conflict">Conflicts: ${conflicts.join(', ')}</span>` : ''}
                        <span class="badge badge-platform">Group: ${bucket}</span>
                    </div>
                    ${(module.pins && module.pins.length > 0) ? `<div class="module-pins">📌 ${module.pins.length} pins required</div>` : ''}
                    ${riskyHint ? `<details class="plain-help"><summary>Why this can be risky</summary><div style="margin-top:6px;">${riskyHint}</div></details>` : ''}
                    ${hasOptions ? `
                        <button class="btn-config" data-module="${module.id}">⚙️ Configure</button>
                        <div class="module-options" id="options-${module.id}">
                            ${renderModuleOptions(module)}
                        </div>
                    ` : ''}
                `;

                const toggle = card.querySelector('input[type="checkbox"]');
                if (allowed) {
                    toggle.onchange = () => handleModuleToggle(module.id, toggle.checked);
                }
                syncModuleCardAccessibility(module, card, toggle, enabled, allowed);
                card.onclick = (event) => {
                    if (!allowed || isInteractiveModuleTarget(event.target)) return;
                    handleModuleToggle(module.id, !module.enabled);
                };
                card.onkeydown = (event) => {
                    if (!allowed) return;
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        handleModuleToggle(module.id, !module.enabled);
                    }
                };

                const configBtn = card.querySelector('.btn-config');
                if (configBtn) {
                    configBtn.onclick = () => toggleModuleOptions(module.id, configBtn);
                }

                wireModuleOptionInputs(card);
                updateConditionalOptionVisibility(module.id);
                const section = moduleSectionFor(module.id);
                if (!groupedCards[section]) groupedCards[section] = [];
                groupedCards[section].push({ card, enabled });
            });

            sectionOrder.forEach(sectionId => {
                const cards = groupedCards[sectionId] || [];
                if (cards.length === 0) return;
                const enabledCount = cards.filter(c => c.enabled).length;
                const details = document.createElement('details');
                details.className = 'module-section';
                details.dataset.group = sectionId;
                details.open = moduleSectionState[sectionId] === true;
                details.innerHTML = `
                    <summary>
                        <span>${moduleSectionLabel(sectionId)}</span>
                        <span class="module-section-count">${enabledCount}/${cards.length} enabled</span>
                    </summary>
                `;
                details.addEventListener('toggle', () => {
                    moduleSectionState[sectionId] = details.open;
                });

                const sub = document.createElement('div');
                sub.className = 'module-grid module-subgrid';
                cards.forEach(c => sub.appendChild(c.card));
                details.appendChild(sub);
                grid.appendChild(details);
            });

            initModuleFilters();
            refreshModuleSectionCounts();
            announceModuleGridStatus();
            updateValidation();
            renderStatusChips();
        }

        function optimizeForSize() {
            if (!selectedBoard) {
                notify('Select a board first, then run Optimize For Size.', 'warning');
                return;
            }
            activeTemplateId = null;
            const targetId = String(selectedBoard?.target_profile || '').toLowerCase();
            const isAvrLike = selectedPlatform === 'avr' || selectedPlatform === 'atmega' || ['mega2560', 'atmega328p', 'atmega32u4'].includes(targetId);
            const setEnabled = (id, on) => {
                const mod = modules.find(m => m.id === id);
                if (mod) {
                    mod.enabled = !!on;
                    moduleStates[id] = !!on;
                }
            };

            if (isAvrLike) {
                setEnabled('shell_full', false);
                setEnabled('shell_min', false);
                setEnabled('shell_tiny', true);
                ['wifi', 'bluetooth', 'tft', 'fs_sd', 'fs_spiffs', 'mic', 'psram'].forEach(id => setEnabled(id, false));
                if (modules.find(m => m.id === 'uart')) setEnabled('uart', true);
            } else {
                setEnabled('shell_full', false);
                if (modules.find(m => m.id === 'shell_min')) setEnabled('shell_min', true);
                ['wifi', 'bluetooth'].forEach(id => setEnabled(id, false));
            }

            populateModuleGrid();
            notify(isAvrLike ? 'Size optimization applied: Shell (Tiny) + low-overhead profile.' : 'Size optimization applied.', 'success');
        }

        function populatePinTable() {
            const tbody = document.getElementById('pin-table-body');
            tbody.innerHTML = '';

            const boardPins = selectedBoard ? (selectedBoard.pins || {}) : {};
            const getModulePinSignals = (module) => {
                const signals = new Set();
                if (Array.isArray(module.pins) && module.pins.length > 0) {
                    module.pins.forEach(p => signals.add(p));
                }
                if (module.pin_requirements && typeof module.pin_requirements === 'object') {
                    Object.keys(module.pin_requirements).forEach(p => signals.add(p));
                }
                const prefixes = new Set();
                if (module.id) prefixes.add(`${module.id}_`);
                if (module.id && module.id.startsWith('fs_')) {
                    prefixes.add(`${module.id.replace('fs_', '')}_`);
                }
                if (module.id === 'fs_sd') prefixes.add('sd_');
                if (module.id === 'i2c') prefixes.add('i2c_');
                if (module.id === 'spi') prefixes.add('spi_');
                if (module.id === 'uart') prefixes.add('uart_');
                if (module.id === 'uart') {
                    prefixes.add('uart0_');
                    prefixes.add('uart1_');
                    prefixes.add('uart2_');
                    prefixes.add('uart3_');
                }
                if (module.id === 'tft') prefixes.add('tft_');
                if (module.id === 'touch') prefixes.add('touch_');
                if (Array.isArray(module.provides)) {
                    module.provides.forEach(p => prefixes.add(`${p}_`));
                }
                if (Array.isArray(module.depends)) {
                    module.depends.forEach(p => prefixes.add(`${p}_`));
                }
                Object.keys(boardPins).forEach(key => {
                    prefixes.forEach(prefix => {
                        if (key.startsWith(prefix)) signals.add(key);
                    });
                });
                return Array.from(signals);
            };

            const enabledModules = modules.filter(m => m.enabled);
            const enabledWithPins = enabledModules.filter(m => Array.isArray(m.pins) && m.pins.length > 0);
            const enabledDerived = enabledModules
                .filter(m => !Array.isArray(m.pins) || m.pins.length === 0)
                .map(m => ({ module: m, pins: getModulePinSignals(m) }))
                .filter(x => x.pins.length > 0);

            if (enabledWithPins.length === 0 && enabledDerived.length === 0 && selectedBoard) {
                const pinDefs = selectedBoard.pin_definitions || {};
                const pins = selectedBoard.pins || {};
                const entries = Object.keys(pinDefs).length > 0
                    ? Object.entries(pinDefs)
                    : Object.entries(pins).map(([k]) => [k, {}]);

                entries.forEach(([pin, def]) => {
                    const tr = document.createElement('tr');
                    const defaultPin = selectedBoard.pins && selectedBoard.pins[pin] !== undefined
                        ? selectedBoard.pins[pin]
                        : -1;
                    const alternatives = def.alternatives ? def.alternatives.join(', ') : '';
                    const isNumeric = typeof defaultPin === 'number' && Number.isFinite(defaultPin);
                    tr.innerHTML = `
                        <td>board</td>
                        <td>${pin.toUpperCase()}</td>
                        <td><input type="${isNumeric ? 'number' : 'text'}" class="pin-input" value="${defaultPin}" data-pin="${pin}" data-pin-type="${isNumeric ? 'number' : 'text'}" ${isNumeric ? 'min="-1" max="40"' : ''}></td>
                        <td>${alternatives}</td>
                    `;
                    tbody.appendChild(tr);
                });
                checkPinConflicts();
                return;
            }

            enabledWithPins.forEach(module => {
                module.pins.forEach(pin => {
                    const tr = document.createElement('tr');
                    const defaultPin = selectedBoard && selectedBoard.pins[pin] !== undefined 
                        ? selectedBoard.pins[pin] 
                        : -1;
                    const pinDef = selectedBoard?.pin_definitions?.[pin] || {};
                    const altPins = Array.isArray(pinDef.alternatives) ? pinDef.alternatives : [];
                    const isNumeric = typeof defaultPin === 'number' && Number.isFinite(defaultPin);
                    
                    tr.innerHTML = `
                        <td>${module.name}</td>
                        <td>${pin.toUpperCase()}</td>
                        <td><input type="${isNumeric ? 'number' : 'text'}" class="pin-input" value="${defaultPin}" data-pin="${pin}" data-pin-type="${isNumeric ? 'number' : 'text'}" ${isNumeric ? 'min="-1" max="40"' : ''}></td>
                        <td>
                            <select class="pin-alt" data-pin="${pin}">
                                <option value="${defaultPin}">Default</option>
                                ${altPins.map(p => `<option value="${p}">${p}</option>`).join('')}
                                <option value="-1">Disabled</option>
                            </select>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });

                if (module.id === 'uart') {
                    const extraPins = getModulePinSignals(module).filter(p => !module.pins.includes(p));
                    extraPins.forEach(pin => {
                        const tr = document.createElement('tr');
                        const defaultPin = selectedBoard && selectedBoard.pins[pin] !== undefined
                            ? selectedBoard.pins[pin]
                            : -1;
                        const pinDef = selectedBoard?.pin_definitions?.[pin] || {};
                        const altPins = Array.isArray(pinDef.alternatives) ? pinDef.alternatives : [];
                        const isNumeric = typeof defaultPin === 'number' && Number.isFinite(defaultPin);
                        tr.innerHTML = `
                            <td>${module.name}</td>
                            <td>${pin.toUpperCase()}</td>
                            <td><input type="${isNumeric ? 'number' : 'text'}" class="pin-input" value="${defaultPin}" data-pin="${pin}" data-pin-type="${isNumeric ? 'number' : 'text'}" ${isNumeric ? 'min="-1" max="40"' : ''}></td>
                            <td>
                                <select class="pin-alt" data-pin="${pin}">
                                    <option value="${defaultPin}">Default</option>
                                    ${altPins.map(p => `<option value="${p}">${p}</option>`).join('')}
                                    <option value="-1">Disabled</option>
                                </select>
                            </td>
                        `;
                        tbody.appendChild(tr);
                    });
                }
            });

            enabledDerived.forEach(({ module, pins }) => {
                pins.forEach(pin => {
                    const tr = document.createElement('tr');
                    const defaultPin = selectedBoard && selectedBoard.pins[pin] !== undefined
                        ? selectedBoard.pins[pin]
                        : -1;
                    const pinDef = selectedBoard?.pin_definitions?.[pin] || {};
                    const altPins = Array.isArray(pinDef.alternatives) ? pinDef.alternatives : [];
                    const isNumeric = typeof defaultPin === 'number' && Number.isFinite(defaultPin);
                    tr.innerHTML = `
                        <td>${module.name}</td>
                        <td>${pin.toUpperCase()}</td>
                        <td><input type="${isNumeric ? 'number' : 'text'}" class="pin-input" value="${defaultPin}" data-pin="${pin}" data-pin-type="${isNumeric ? 'number' : 'text'}" ${isNumeric ? 'min="-1" max="40"' : ''}></td>
                        <td>
                            <select class="pin-alt" data-pin="${pin}">
                                <option value="${defaultPin}">Default</option>
                                ${altPins.map(p => `<option value="${p}">${p}</option>`).join('')}
                                <option value="-1">Disabled</option>
                            </select>
                        </td>
                    `;
                    tbody.appendChild(tr);
                });
            });

            if (selectedBoard && selectedBoard.pins && Object.prototype.hasOwnProperty.call(selectedBoard.pins, 'led')) {
                const hasLedRow = !!tbody.querySelector('.pin-input[data-pin="led"]');
                if (!hasLedRow) {
                    const pin = 'led';
                    const tr = document.createElement('tr');
                    const defaultPin = selectedBoard.pins[pin];
                    const pinDef = selectedBoard?.pin_definitions?.[pin] || {};
                    const altPins = Array.isArray(pinDef.alternatives) ? pinDef.alternatives : [];
                    const isNumeric = typeof defaultPin === 'number' && Number.isFinite(defaultPin);
                    tr.innerHTML = `
                        <td>board</td>
                        <td>${pin.toUpperCase()}</td>
                        <td><input type="${isNumeric ? 'number' : 'text'}" class="pin-input" value="${defaultPin}" data-pin="${pin}" data-pin-type="${isNumeric ? 'number' : 'text'}" ${isNumeric ? 'min="-1" max="255"' : ''}></td>
                        <td>
                            <select class="pin-alt" data-pin="${pin}">
                                <option value="${defaultPin}">Default</option>
                                ${altPins.map(p => `<option value="${p}">${p}</option>`).join('')}
                                <option value="-1">Disabled</option>
                            </select>
                        </td>
                    `;
                    tbody.appendChild(tr);
                }
            }

            tbody.querySelectorAll('.pin-alt').forEach(select => {
                select.addEventListener('change', () => {
                    const pin = select.dataset.pin;
                    const input = tbody.querySelector(`.pin-input[data-pin="${pin}"]`);
                    if (input) {
                        input.value = select.value;
                        checkPinConflicts();
                    }
                });
            });

            tbody.querySelectorAll('.pin-input').forEach(input => {
                input.addEventListener('change', () => {
                    checkPinConflicts();
                });
            });

            checkPinConflicts();
        }

        async function generateConfigPreview() {
            const previewEl = document.getElementById('config-preview');
            renderValidationReport();
            const advancedPinConfig = document.getElementById('advanced-pin-config');
            const ledInput = (advancedPinConfig && advancedPinConfig.open)
                ? document.querySelector('#pin-table-body input[data-pin="led"]')
                : null;
            const ledPin = ledInput ? String(ledInput.value || '').trim() : (selectedBoard?.pins?.led ?? 'n/a');

            // Summary
            const summary = document.getElementById('config-summary');
            summary.innerHTML = `
                <div class="board-specs">
                    <div class="spec-item">
                        <div class="spec-label">Board</div>
                        <div class="spec-value">${selectedBoard ? selectedBoard.name : 'None'}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Platform</div>
                        <div class="spec-value">${selectedPlatform.toUpperCase()}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Target</div>
                        <div class="spec-value">${selectedBoard?.target_profile || '—'}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Drivers Enabled</div>
                        <div class="spec-value">${modules.filter(m => m.enabled).length}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Starter Apps Enabled</div>
                        <div class="spec-value">${applets.filter(a => appletStates[a]).length}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">Catalog Apps</div>
                        <div class="spec-value">${marketApps.filter(a => marketAppStates[a]).length}</div>
                    </div>
                    <div class="spec-item">
                        <div class="spec-label">LED Pin</div>
                        <div class="spec-value">${ledPin}</div>
                    </div>
                </div>
            `;

            const isHttp = window.location.protocol.startsWith('http');
            if (!isHttp || !selectedBoard) {
                previewEl.textContent = 'Select a board to preview configuration.';
                return;
            }
            const payload = collectCurrentConfigPayload();

            try {
                const data = await apiFetchJson('/api/preview/basalt_config_h', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!data.success) throw new Error(data.error || 'Preview failed');
                previewEl.textContent = data.content;
            } catch (err) {
                previewEl.textContent = `Preview failed: ${err.message || err}`;
                notify(`Preview failed: ${err.message || err}`, 'error');
            }
            updateMemoryEstimatePanels();
            
        }

        function buildValidationIssues({ includePins = true } = {}) {
            const issues = [];

            modules.filter(m => m.enabled).forEach(module => {
                const depends = Array.isArray(module.depends) ? module.depends : [];
                depends.forEach(depId => {
                    const depModule = modules.find(m => m.id === depId);
                    if (!depModule || !depModule.enabled) {
                        issues.push({
                            type: 'error',
                            message: `Driver "${module.name}" requires "${depId}" which is not enabled`
                        });
                    }
                });

                const conflicts = Array.isArray(module.conflicts) ? module.conflicts : [];
                conflicts.forEach(conflictId => {
                    const conflictModule = modules.find(m => m.id === conflictId);
                    if (conflictModule && conflictModule.enabled) {
                        issues.push({
                            type: 'warning',
                            message: `Driver "${module.name}" conflicts with "${conflictModule.name}"`
                        });
                    }
                });
            });

            const mic = modules.find(m => m.id === 'mic');
            if (mic && mic.enabled) {
                const source = String(getModuleOptionValue('mic', 'source') ?? 'adc').toLowerCase();
                const depId = source === 'i2s' ? 'i2s' : 'adc';
                const depModule = modules.find(m => m.id === depId);
                if (!depModule || !depModule.enabled) {
                    issues.push({
                        type: 'error',
                        message: `Driver "Microphone Input" with source "${source}" requires "${depId}" to be enabled`
                    });
                }
            }

            if (includePins) {
                const pinResult = checkPinConflicts();
                if ((pinResult.errors || []).length > 0) {
                    issues.push({
                        type: 'error',
                        message: `${pinResult.errors.length} pin assignment error(s) detected`
                    });
                }
            }

            const targetId = selectedBoard?.target_profile;
            const target = targetId ? targets[targetId] : null;
            const enabledModules = modules.filter(m => m.enabled).map(m => m.id);

            if (target?.module_policy?.allowed?.length) {
                const allowed = new Set(target.module_policy.allowed);
                const blocked = enabledModules.filter(m => !allowed.has(m));
                if (blocked.length > 0) {
                    issues.push({
                        type: 'error',
                        message: `Target "${targetId}" does not allow: ${blocked.join(', ')}.`
                    });
                }
            }

            if (selectedBoard?.capabilities?.length) {
                const caps = new Set(selectedBoard.capabilities);
                const requires = {
                    wifi: 'wifi',
                    bluetooth: 'bluetooth',
                    tft: 'tft',
                    touch: 'touch',
                    psram: 'psram',
                    fs_sd: 'sd_card',
                    display_ssd1306: 'i2c',
                    rtc: 'i2c',
                    imu: 'i2c',
                    dht22: 'gpio',
                    mic: 'adc'
                };

                Object.entries(requires).forEach(([moduleId, cap]) => {
                    if (enabledModules.includes(moduleId) && !caps.has(cap)) {
                        issues.push({
                            type: 'warning',
                            message: `Board capabilities do not list "${cap}" but driver "${moduleId}" is enabled.`
                        });
                    }
                });
            }

            if (target?.applets?.length) {
                const allowedApplets = new Set(target.applets);
                const enabledApplets = applets.filter(a => appletStates[a]);
                const invalid = enabledApplets.filter(a => !allowedApplets.has(a));
                if (invalid.length > 0) {
                    issues.push({
                        type: 'warning',
                        message: `Selected starter apps not supported by target: ${invalid.join(', ')}.`
                    });
                }
            } else if (applets.length > 0) {
                const allowedApplets = new Set(availableAppletsForBoard(selectedBoard));
                const enabledApplets = applets.filter(a => appletStates[a]);
                const invalid = enabledApplets.filter(a => !allowedApplets.has(a));
                if (invalid.length > 0) {
                    issues.push({
                        type: 'warning',
                        message: `Selected starter apps not supported by board/platform: ${invalid.join(', ')}.`
                    });
                }
            }

            if (marketApps.length > 0) {
                const allowedMarket = new Set(availableMarketAppsForBoard(selectedBoard).map(x => x.id));
                const enabledMarket = marketApps.filter(a => marketAppStates[a]);
                const invalid = enabledMarket.filter(a => !allowedMarket.has(a));
                if (invalid.length > 0) {
                    issues.push({
                        type: 'warning',
                        message: `Selected market apps not supported by board/platform: ${invalid.join(', ')}.`
                    });
                }
            }

            const module_config = collectModuleConfigFromUI();
            for (const moduleId of ['display_ssd1306', 'tft']) {
                const cfg = module_config[moduleId];
                if (cfg && String(cfg.boot_splash || '') === 'local_file_upload' && !cfg.boot_splash_file_content_b64) {
                    issues.push({
                        type: 'warning',
                        message: `${moduleId}: Local file upload selected, but no custom_image.c file is attached yet.`
                    });
                }
            }
            const uartAssignments = [];
            Object.entries(module_config).forEach(([modId, opts]) => {
                if (!opts || typeof opts !== 'object') return;
                const port = opts.uart_port !== undefined ? opts.uart_port : opts.uart_num;
                if (port === undefined || port === null || port === '') return;
                uartAssignments.push({ modId, port: Number(port) });
            });

            if (targetId === 'mega2560' && uartAssignments.length > 0) {
                const invalid = uartAssignments.filter(a => Number.isNaN(a.port) || a.port < 0 || a.port > 3);
                if (invalid.length > 0) {
                    issues.push({
                        type: 'warning',
                        message: 'UART port must be 0-3 on Mega 2560.'
                    });
                }
                const seen = {};
                uartAssignments.forEach(a => {
                    const key = String(a.port);
                    if (!seen[key]) seen[key] = [];
                    seen[key].push(a.modId);
                });
                Object.entries(seen).forEach(([port, mods]) => {
                    if (mods.length > 1) {
                        issues.push({
                            type: 'warning',
                            message: `UART${port} is selected by multiple drivers: ${mods.join(', ')}.`
                        });
                    }
                });
            }

            // On AVR bootloader boards, USB serial shell is on UART0 by default.
            if ((targetId === 'mega2560' || targetId === 'atmega328p') && modules.some(m => (m.id === 'shell_full' || m.id === 'shell_min' || m.id === 'shell_tiny') && m.enabled)) {
                const uartCfg = module_config.uart || {};
                const uartNum = Number(uartCfg.uart_num ?? 0);
                if (!Number.isNaN(uartNum) && uartNum !== 0) {
                    issues.push({
                        type: 'warning',
                        message: `Shell is enabled but UART${uartNum} is selected. USB serial monitor is usually UART0 on this board.`
                    });
                }
            }

            const isAvrLike = selectedPlatform === 'avr' || selectedPlatform === 'atmega' || ['mega2560', 'atmega328p', 'atmega32u4'].includes(String(targetId || '').toLowerCase());
            if (isAvrLike && enabledModules.includes('shell_full')) {
                issues.push({
                    type: 'warning',
                    message: 'Shell (Full) on AVR has high RAM/flash overhead. Prefer Shell (Tiny) unless full command coverage is required.'
                });
            }

            const mem = estimateMemoryUsage();
            const checkMem = (label, used, cap) => {
                if (!(cap > 0)) return;
                const ratio = used / cap;
                const pct = Math.round(ratio * 100);
                if (ratio > 1.0) {
                    issues.push({
                        type: 'error',
                        message: `${label} estimate exceeds device capacity (${pct}%). Reduce enabled drivers/apps.`
                    });
                } else if (ratio >= 0.85) {
                    issues.push({
                        type: 'warning',
                        message: `${label} is high (${pct}%). Target <85% for stability margin.`
                    });
                }
            };
            checkMem('Program flash', mem.usage.prog, mem.caps.prog);
            checkMem('RAM', mem.usage.ram, mem.caps.ram);
            checkMem('Data flash', mem.usage.data, mem.caps.data);

            return issues;
        }

        function renderValidationReport() {
            const reportEl = document.getElementById('validation-report');
            if (!reportEl) return;

            if (!selectedBoard) {
                reportEl.innerHTML = `
                    <div class="validation-item info">
                        <span class="validation-icon">ℹ️</span>
                        <div>Select a board to view validation status.</div>
                    </div>
                `;
                return;
            }

            const issues = buildValidationIssues({ includePins: isAdvancedPinConfigOpen() });
            if (issues.length === 0) {
                reportEl.innerHTML = `
                    <div class="validation-item info">
                        <span class="validation-icon">✅</span>
                        <div>All checks passed for this configuration.</div>
                    </div>
                `;
                return;
            }

            reportEl.innerHTML = issues.map(issue => `
                <div class="validation-item ${issue.type}">
                    <span class="validation-icon">
                        ${issue.type === 'error' ? '❌' : issue.type === 'warning' ? '⚠️' : 'ℹ️'}
                    </span>
                    <div>${issue.message}</div>
                </div>
            `).join('');
        }

        function hasBlockingErrors({ includePins = true } = {}) {
            return buildValidationIssues({ includePins }).some(i => i.type === 'error');
        }

        function updateFinalActionState() {
            const btnGenerate = document.getElementById('btn-generate');
            const btnGenerateBuild = document.getElementById('btn-generate-build');
            const blocking = selectedBoard ? hasBlockingErrors({ includePins: isAdvancedPinConfigOpen() }) : true;
            const reason = !selectedBoard
                ? 'Select a board first.'
                : 'Fix blocking validation errors before generating.';
            if (btnGenerate) {
                btnGenerate.disabled = blocking;
                btnGenerate.title = blocking ? reason : '';
            }
            if (btnGenerateBuild) {
                btnGenerateBuild.disabled = blocking;
                btnGenerateBuild.title = blocking ? reason : '';
            }
        }

        function getCurrentStepReadiness(step = currentStep) {
            if (step === 1) {
                if (!selectedBoard) {
                    return { ready: false, reason: 'Select a board to continue to Drivers.' };
                }
                return { ready: true, reason: `Board selected: ${selectedBoard.name}` };
            }
            if (step === 2) {
                const issues = buildValidationIssues({ includePins: false });
                const errors = issues.filter(i => i.type === 'error');
                if (errors.length > 0) {
                    return { ready: false, reason: 'Resolve driver dependency/conflict errors before continuing.' };
                }
                return { ready: true, reason: 'Driver set is valid. Continue to Runtime Options.' };
            }
            if (step === 3) {
                const issues = buildValidationIssues({ includePins: isAdvancedPinConfigOpen() });
                const errors = issues.filter(i => i.type === 'error');
                if (errors.length > 0) {
                    return { ready: false, reason: 'Resolve runtime or pin errors before review/generate.' };
                }
                return { ready: true, reason: 'Runtime options look good. Continue to Generate.' };
            }
            return { ready: true, reason: 'Review output and generate files.' };
        }

        function renderReviewChecklist() {
            const wrap = document.getElementById('review-checklist');
            if (!wrap) return;
            const issues = buildValidationIssues({ includePins: isAdvancedPinConfigOpen() });
            const errors = issues.filter(i => i.type === 'error');
            const warnings = issues.filter(i => i.type === 'warning');
            const enabledDriverCount = modules.filter(m => m.enabled).length;
            const starterCount = applets.filter(a => appletStates[a]).length;
            const marketCount = marketApps.filter(a => marketAppStates[a]).length;

            const item = (ok, label, detail) => `
                <div class="validation-item ${ok ? 'info' : 'warning'}">
                    <span class="validation-icon">${ok ? '✅' : '⚠️'}</span>
                    <div><strong>${label}</strong> ${detail ? `- ${detail}` : ''}</div>
                </div>
            `;

            wrap.innerHTML = [
                item(Boolean(selectedBoard), 'Board selected', selectedBoard ? selectedBoard.name : 'No board selected'),
                item(enabledDriverCount > 0, 'Drivers selected', `${enabledDriverCount} enabled`),
                item(errors.length === 0, 'Blocking errors', errors.length === 0 ? 'None' : `${errors.length} error(s) must be fixed`),
                item(warnings.length === 0, 'Warnings', warnings.length === 0 ? 'None' : `${warnings.length} warning(s), review before shipping`),
                item(true, 'Runtime app set', `${starterCount} starter app(s), ${marketCount} market app(s)`)
            ].join('');
        }

        function updateStepGuidance() {
            const hint = document.getElementById('step-guidance');
            const btnNext = document.getElementById('btn-next');
            const btnPrev = document.getElementById('btn-prev');
            if (!hint || !btnNext) return;
            const labels = {
                1: 'Platform & Board',
                2: 'Drivers',
                3: 'Runtime Options',
                4: 'Generate'
            };
            const stepTitle = wizardSteps[currentStep - 1]?.title || labels[currentStep] || 'Flow';
            const nextTitle = wizardSteps[currentStep]?.title || labels[currentStep + 1] || 'Next';
            const prevTitle = wizardSteps[currentStep - 2]?.title || labels[currentStep - 1] || 'Previous';
            const readiness = getCurrentStepReadiness(currentStep);
            const finalBlocked = currentStep === FINAL_STEP && hasBlockingErrors({ includePins: isAdvancedPinConfigOpen() });
            hint.classList.toggle('error', !readiness.ready);
            const msg = finalBlocked ? 'Fix blocking validation errors before generating files.' : readiness.reason;
            hint.innerHTML = `<strong>Step ${currentStep} - ${stepTitle}:</strong>&nbsp;${msg}`;
            if (currentStep < FINAL_STEP) {
                btnNext.disabled = !readiness.ready;
                btnNext.title = readiness.ready ? '' : readiness.reason;
                btnNext.textContent = `Next: ${nextTitle} →`;
            } else {
                btnNext.disabled = false;
                btnNext.title = '';
            }
            if (btnPrev) {
                btnPrev.textContent = currentStep > 1 ? `← Back: ${prevTitle}` : '← Previous';
            }
        }

        function maybeScrollActiveSectionIntoView() {
            const section = document.querySelector('.content-section.active');
            if (!section) return;
            const rect = section.getBoundingClientRect();
            if (rect.top < 90 || rect.top > (window.innerHeight * 0.55)) {
                try {
                    section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                } catch (_err) {
                    section.scrollIntoView();
                }
            }
        }

        function updateFlowContext() {
            const host = document.getElementById('flow-context');
            if (!host) return;
            const enabledDriverCount = Array.isArray(modules) ? modules.filter(m => m.enabled).length : 0;
            const starterCount = Array.isArray(applets) ? applets.filter(a => appletStates[a]).length : 0;
            const marketCount = Array.isArray(marketApps) ? marketApps.filter(a => marketAppStates[a]).length : 0;
            const boardText = selectedBoard ? selectedBoard.name : 'No board selected yet';
            const boardClass = selectedBoard ? '' : ' warn';
            host.innerHTML = [
                `<span class="flow-pill${boardClass}">Board: ${boardText}</span>`,
                `<span class="flow-pill">Platform: ${(selectedPlatform || '—').toUpperCase()}</span>`,
                `<span class="flow-pill">Drivers: ${enabledDriverCount}</span>`,
                `<span class="flow-pill">Apps: ${starterCount} starter / ${marketCount} market</span>`
            ].join('');
        }

        function updateFlowProgress() {
            const fill = document.getElementById('flow-progress-fill');
            const title = document.getElementById('flow-progress-title');
            const meta = document.getElementById('flow-progress-meta');
            const saveChip = document.getElementById('flow-save-chip');
            if (!fill || !title || !meta) return;
            const stepTitle = wizardSteps[currentStep - 1]?.title || `Step ${currentStep}`;
            const pct = Math.max(0, Math.min(100, Math.round((currentStep / Math.max(1, FINAL_STEP)) * 100)));
            const readiness = getCurrentStepReadiness(currentStep);
            title.textContent = `${stepTitle} ${readiness.ready ? 'ready' : 'needs attention'}`;
            meta.textContent = `Step ${currentStep}/${FINAL_STEP} (${pct}%)`;
            fill.style.width = `${pct}%`;
            if (saveChip) {
                if (lastDraftSavedAt > 0) {
                    saveChip.textContent = `Saved ${new Date(lastDraftSavedAt).toLocaleTimeString()}`;
                } else {
                    saveChip.textContent = 'Not saved yet';
                }
            }
        }

        function updateFlowAlert() {
            const alertEl = document.getElementById('flow-alert');
            if (!alertEl) return;
            if (selectedBoard) {
                alertEl.classList.remove('active');
                alertEl.innerHTML = '';
                return;
            }
            const stepsBlocked = currentStep >= 2;
            alertEl.classList.toggle('active', stepsBlocked);
            if (!stepsBlocked) {
                alertEl.innerHTML = '';
                return;
            }
            alertEl.innerHTML = [
                '<strong>Board required:</strong> pick a board in Step 1 to unlock Drivers, Runtime, and Generate.',
                '<div class="flow-alert-actions">',
                '<button id="btn-alert-m5-quick" class="btn btn-secondary" type="button" style="padding:7px 10px; font-size:12px;">Quick Pick: M5Stack Plus2</button>',
                '<button id="btn-alert-esp32-quick" class="btn btn-secondary" type="button" style="padding:7px 10px; font-size:12px;">Quick Start ESP32</button>',
                '<button id="btn-alert-go-step1" class="btn btn-primary" type="button" style="padding:7px 10px; font-size:12px;">Go To Step 1</button>',
                '</div>'
            ].join('');
            const btnM5 = document.getElementById('btn-alert-m5-quick');
            const btnEsp = document.getElementById('btn-alert-esp32-quick');
            const btnStep1 = document.getElementById('btn-alert-go-step1');
            if (btnM5) {
                btnM5.onclick = async () => {
                    await quickPickBoardByName(['M5StickC Plus2', 'M5StackC Plus2', 'M5StickC', 'm5stickc_plus2']);
                    currentStep = 1;
                    updateWizardSteps();
                };
            }
            if (btnEsp) btnEsp.onclick = async () => applyQuickStartEsp32();
            if (btnStep1) btnStep1.onclick = () => {
                currentStep = 1;
                updateWizardSteps();
            };
        }

        function collectCurrentConfigPayload() {
            const enabled_drivers = modules.filter(m => m.enabled).map(m => m.id);
            const driver_config = collectModuleConfigFromUI();
            const enabled_applets = applets.filter(a => appletStates[a]);
            const market_apps = marketApps.filter(a => marketAppStates[a]);
            const custom_pins = {};
            const advancedPinConfig = document.getElementById('advanced-pin-config');
            if (advancedPinConfig && advancedPinConfig.open) {
                document.querySelectorAll('#pin-table-body input[data-pin]').forEach(input => {
                    const key = input.dataset.pin;
                    const raw = (input.value || '').trim();
                    if (!raw) return;
                    if (input.dataset.pinType === 'number') {
                        const val = parseInt(raw, 10);
                        if (!Number.isNaN(val)) custom_pins[key] = val;
                    } else {
                        custom_pins[key] = raw;
                    }
                });
            }
            if (avrTargetSelected()) {
                readAvrSettingsFromUi();
            }
            return {
                platform: selectedPlatform,
                board_id: selectedBoard?.id,
                target_profile: selectedBoard?.target_profile || null,
                enabled_drivers,
                enabled_modules: enabled_drivers,
                applets: enabled_applets,
                market_apps,
                driver_config,
                module_config: driver_config,
                custom_pins,
                clock: avrTargetSelected() ? avrSettings.clock : undefined,
                fuses: avrTargetSelected() ? avrSettings.fuses : undefined,
                upload: avrTargetSelected() ? avrSettings.upload : undefined
            };
        }

        function bindAdvancedPinConfigToggle() {
            const advanced = document.getElementById('advanced-pin-config');
            if (!advanced || advanced.dataset.bound === '1') return;
            advanced.dataset.bound = '1';
            advanced.addEventListener('toggle', () => {
                if (advanced.open) {
                    populatePinTable();
                    checkPinConflicts();
                }
            });
        }

        function updateWizardSteps() {
            if (currentStep < 1) currentStep = 1;
            if (currentStep > FINAL_STEP) currentStep = FINAL_STEP;

            document.querySelectorAll('.wizard-steps .step').forEach((step, index) => {
                step.classList.remove('active', 'completed');
                if (index + 1 === currentStep) {
                    step.classList.add('active');
                } else if (index + 1 < currentStep) {
                    step.classList.add('completed');
                }
            });
            
            // Show/hide content sections
            getWizardSections().forEach((section, index) => {
                section.classList.remove('active');
                const visible = index + 1 <= FINAL_STEP;
                section.style.display = visible ? '' : 'none';
                if (visible && index + 1 === currentStep) {
                    section.classList.add('active');
                }
            });
            
            // Update buttons
            document.getElementById('btn-prev').style.display = currentStep > 1 ? 'block' : 'none';
            document.getElementById('btn-next').style.display = currentStep < FINAL_STEP ? 'block' : 'none';
            document.getElementById('btn-generate').style.display = currentStep === FINAL_STEP ? 'block' : 'none';
            const btnGenerateBuild = document.getElementById('btn-generate-build');
            if (btnGenerateBuild) {
                btnGenerateBuild.style.display = (currentStep === FINAL_STEP && selectedPlatform === 'esp32') ? 'block' : 'none';
            }
            
            // Populate data for current step
            if (currentStep === 3) {
                syncModuleStatesFromUI();
                renderRuntimeOptionsPanel();
                applyAvrSettingsToUi();
                const advanced = document.getElementById('advanced-pin-config');
                if (advanced && advanced.open) {
                    populatePinTable();
                }
            } else if (currentStep === 2) {
                updateValidation();
                renderSelectedAppsVisibility();
            } else if (currentStep === FINAL_STEP) {
                generateConfigPreview();
                renderReviewChecklist();
                refreshWebFlasher({ silent: true });
                refreshAvrFlasher({ silent: true });
                refreshSerialTerminalVisibility();
                updateFinalActionState();
            } else {
                refreshSerialTerminalVisibility();
            }
            renderBuildHealthBar();
            updateStepGuidance();
            updateFlowContext();
            updateFlowProgress();
            updateFlowAlert();
            saveConfigDraft();
            maybeScrollActiveSectionIntoView();
        }

        function nextStep() {
            if (currentStep >= FINAL_STEP) return;
            const readiness = getCurrentStepReadiness(currentStep);
            if (!readiness.ready) {
                notify(readiness.reason, 'warning');
                updateStepGuidance();
                return;
            }
            currentStep++;
            updateWizardSteps();
        }

        function prevStep() {
            if (currentStep > 1) {
                currentStep--;
                updateWizardSteps();
            }
        }

        async function generateFiles() {
            clearInlineOutput();
            if (!selectedBoard) {
                notify('Select a board first.', 'warning');
                return;
            }
            const payload = collectCurrentConfigPayload();

            const btnGenerate = document.getElementById('btn-generate');
            if (btnGenerate) {
                btnGenerate.disabled = true;
                btnGenerate.textContent = 'Generating...';
            }
            try {
                const data = await apiFetchJson('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!data.success) throw new Error(data.error || 'Generate failed');

                const fileLines = Object.keys(data.files || {}).map(k => `${k}: ${data.files[k]}`).join('\n');
                const buildMsg = selectedPlatform === 'avr'
                    ? [
                        `Build with (Arduino CLI):`,
                        `arduino-cli compile --fqbn ${avrSettings.upload?.fqbn || 'arduino:avr:mega'} .`,
                        '',
                        'Upload with (Arduino CLI bootloader):',
                        `arduino-cli upload -p <PORT> --fqbn ${avrSettings.upload?.fqbn || 'arduino:avr:mega'} .`,
                        '',
                        'Or use the AVR Build + Flash panel below for bootloader/ISP/UPDI.'
                    ]
                    : [
                        'Build with (ESP32 targets):',
                        'SDKCONFIG_DEFAULTS=config/generated/sdkconfig.defaults idf.py -B build build flash monitor'
                    ];

                const msg = [
                    'Generated configuration files:',
                    fileLines || '(none)',
                    '',
                    ...buildMsg
                ].join('\n');

                showInlineOutput(msg, 'success');
                notify('Configuration files generated successfully.', 'success');
                refreshWebFlasher({ silent: true });
                refreshAvrFlasher({ silent: true });
            } catch (err) {
                const msg = `Generate failed: ${err.message || err}`;
                showInlineOutput(msg, 'error');
                notify(msg, 'error');
            } finally {
                if (btnGenerate) {
                    btnGenerate.disabled = false;
                    btnGenerate.textContent = 'Generate Files';
                }
            }
        }

        async function generateAndBuildEsp32() {
            clearInlineOutput();
            if (!selectedBoard) {
                notify('Select a board first.', 'warning');
                return;
            }
            if (selectedPlatform !== 'esp32') {
                notify('Generate + Build is currently implemented for ESP32 only.', 'warning');
                return;
            }

            const payload = collectCurrentConfigPayload();
            const btn = document.getElementById('btn-generate-build');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Generating + Building...';
            }
            try {
                const gen = await apiFetchJson('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!gen.success) throw new Error(gen.error || 'Generate failed');

                const buildResp = await fetch('/api/build/esp32', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const raw = await buildResp.text();
                let build = null;
                try { build = raw ? JSON.parse(raw) : null; } catch (_e) { build = null; }

                if (!buildResp.ok || !build?.success) {
                    const msg = build?.error || raw || `HTTP ${buildResp.status}`;
                    const details = build?.output || raw || '';
                    showInlineOutput(`Generate succeeded, but build failed: ${msg}\n\n${details}`.trim(), 'error');
                    notify(`Build failed: ${msg}`, 'error');
                    return;
                }

                const genLines = Object.keys(gen.files || {}).map(k => `${k}: ${gen.files[k]}`).join('\n');
                const output = build.output ? String(build.output) : '(no build output)';
                const msg = [
                    'Generate + Build completed successfully.',
                    '',
                    'Generated files:',
                    genLines || '(none)',
                    '',
                    'Build output (tail):',
                    output
                ].join('\n');
                showInlineOutput(msg, 'success');
                notify('ESP32 firmware rebuilt. Web Flasher now uses latest selection.', 'success');
                refreshWebFlasher({ silent: true });
            } catch (err) {
                const msg = `Generate + Build failed: ${err.message || err}`;
                showInlineOutput(msg, 'error');
                notify(msg, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Generate + Build ESP32';
                }
            }
        }

        function attachEventListeners() {
            const closeDiyBtn = document.getElementById('btn-close-diy-board');
            if (closeDiyBtn) closeDiyBtn.addEventListener('click', () => closeDIYBoardModal());
            const cancelDiyBtn = document.getElementById('btn-cancel-diy-board');
            if (cancelDiyBtn) cancelDiyBtn.addEventListener('click', () => closeDIYBoardModal());
            const saveDiyBtn = document.getElementById('btn-save-diy-board');
            if (saveDiyBtn) saveDiyBtn.addEventListener('click', () => saveDIYBoard());

            const overflowBtn = document.getElementById('btn-overflow-menu');
            if (overflowBtn) {
                overflowBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleOverflowMenu();
                });
            }
            const menuDiyBoard = document.getElementById('menu-diy-board');
            if (menuDiyBoard) menuDiyBoard.addEventListener('click', () => {
                toggleOverflowMenu(false);
                openDIYBoardModal();
            });
            document.addEventListener('click', (e) => {
                const menuWrap = document.querySelector('.topbar-menu');
                if (!menuWrap) return;
                const target = e.target;
                if (target instanceof Node && !menuWrap.contains(target)) {
                    toggleOverflowMenu(false);
                }
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') toggleOverflowMenu(false);
                const activeTag = String(document.activeElement?.tagName || '').toLowerCase();
                const isTyping = activeTag === 'input' || activeTag === 'textarea' || activeTag === 'select' || document.activeElement?.isContentEditable;
                if (isTyping) return;

                if (e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
                    if (['1', '2', '3', '4'].includes(e.key)) {
                        e.preventDefault();
                        const target = Number(e.key);
                        if (target >= 1 && target <= FINAL_STEP) {
                            if (target > currentStep) {
                                for (let s = currentStep; s < target; s++) {
                                    const readiness = getCurrentStepReadiness(s);
                                    if (!readiness.ready) {
                                        notify(readiness.reason, 'warning');
                                        updateStepGuidance();
                                        return;
                                    }
                                }
                            }
                            currentStep = target;
                            updateWizardSteps();
                        }
                    }
                }

                if (e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey && String(e.key).toLowerCase() === 'g') {
                    if (currentStep === FINAL_STEP) {
                        e.preventDefault();
                        generateFiles();
                    }
                }
            });

            const startBtn = document.getElementById('btn-start-config');
            if (startBtn) startBtn.addEventListener('click', () => enterConfigurator(1));
            const quickM5Btn = document.getElementById('btn-quick-m5');
            if (quickM5Btn) {
                quickM5Btn.addEventListener('click', async () => {
                    await quickPickBoardByName([
                        'M5StickC Plus2',
                        'M5StackC Plus2',
                        'M5StickC',
                        'm5stickc_plus2'
                    ]);
                });
            }
            const startEsp32Btn = document.getElementById('btn-start-esp32');
            if (startEsp32Btn) {
                startEsp32Btn.addEventListener('click', async () => applyQuickStartEsp32());
            }
            const resumeBtn = document.getElementById('btn-resume-last');
            if (resumeBtn) resumeBtn.addEventListener('click', async () => resumeLastSession());
            const topOpenBtn = document.getElementById('btn-open-config');
            if (topOpenBtn) topOpenBtn.addEventListener('click', () => enterConfigurator());
            const topHomeBtn = document.getElementById('btn-home');
            if (topHomeBtn) topHomeBtn.addEventListener('click', () => showLanding());
            const btnOptimizeSize = document.getElementById('btn-optimize-size');
            if (btnOptimizeSize) btnOptimizeSize.addEventListener('click', optimizeForSize);
            const btnBoardDefaults = document.getElementById('btn-board-defaults');
            if (btnBoardDefaults) {
                btnBoardDefaults.addEventListener('click', () => {
                    if (!selectedBoard) {
                        notify('Select a board first.', 'warning');
                        return;
                    }
                    applyBoardAndTemplateDefaults(selectedBoard, null);
                    notify('Board recommended defaults applied.', 'success');
                    updateValidation();
                });
            }
            const driverTabWrap = document.getElementById('driver-tabs');
            if (driverTabWrap) {
                driverTabWrap.querySelectorAll('[data-driver-view]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        driverView = String(btn.getAttribute('data-driver-view') || 'all');
                        driverTabWrap.querySelectorAll('[data-driver-view]').forEach(el => {
                            el.classList.toggle('active', el === btn);
                        });
                        populateModuleGrid();
                    });
                });
            }
            const btnBuildHealthFix = document.getElementById('btn-build-health-fix');
            if (btnBuildHealthFix) btnBuildHealthFix.addEventListener('click', () => applyQuickFixes());

            document.getElementById('platform-select').onchange = async (e) => {
                selectedPlatform = e.target.value;
                if (selectedPlatform) {
                    const demoBoard = (boards[selectedPlatform] || [])[0] || null;
                    if (demoBoard) {
                        const tx = boardTaxonomy(demoBoard);
                        selectedManufacturer = tx.manufacturer;
                        selectedArchitecture = '';
                        selectedFamily = '';
                        selectedSilicon = '';
                    }
                } else {
                    selectedManufacturer = '';
                    selectedArchitecture = '';
                    selectedFamily = '';
                    selectedSilicon = '';
                }
                activeTemplateId = null;
                selectedBoard = null;
                const boardDetails = document.getElementById('board-details');
                if (boardDetails) boardDetails.style.display = 'none';
                if (selectedPlatform !== 'avr') {
                    const panel = document.getElementById('avr-config-panel');
                    if (panel) panel.style.display = 'none';
                }
                await refreshTaxonomyOptionsFromApi().catch(err => {
                    console.warn('Failed to refresh taxonomy options:', err);
                    taxonomyOptions = null;
                });
                await refreshBoardsForCurrentFilters({ force: true });
                populateBoardList();
                if (selectedPlatform) {
                    await refreshModulesForPlatform(selectedPlatform);
                    await refreshMarketCatalogForPlatform(selectedPlatform);
                } else {
                    modules = [];
                    marketCatalog = [];
                    loadedPlatformForModules = '';
                    loadedPlatformForMarket = '';
                }
                updateLandingStats();
                populateModuleGrid();
                renderSelectedAppsVisibility();
                clearInlineOutput();
                refreshWebFlasher({ silent: true });
                refreshAvrFlasher({ silent: true });
                updateMemoryEstimatePanels();
                persistFilterStateToUrl();
            };

            const manufacturerSel = document.getElementById('manufacturer-select');
            if (manufacturerSel) {
                manufacturerSel.addEventListener('change', async () => {
                    selectedManufacturer = String(manufacturerSel.value || '');
                    selectedArchitecture = '';
                    selectedFamily = '';
                    selectedSilicon = '';
                    selectedBoard = null;
                    const boardDetails = document.getElementById('board-details');
                    if (boardDetails) boardDetails.style.display = 'none';
                    await refreshTaxonomyOptionsFromApi().catch(err => {
                        console.warn('Failed to refresh taxonomy options:', err);
                        taxonomyOptions = null;
                    });
                    await refreshBoardsForCurrentFilters({ force: true });
                    populateBoardList();
                    updateMemoryEstimatePanels();
                    persistFilterStateToUrl();
                });
            }

            const architectureSel = document.getElementById('architecture-select');
            if (architectureSel) {
                architectureSel.addEventListener('change', async () => {
                    selectedArchitecture = String(architectureSel.value || '');
                    selectedFamily = '';
                    selectedSilicon = '';
                    selectedBoard = null;
                    const boardDetails = document.getElementById('board-details');
                    if (boardDetails) boardDetails.style.display = 'none';
                    await refreshTaxonomyOptionsFromApi().catch(err => {
                        console.warn('Failed to refresh taxonomy options:', err);
                        taxonomyOptions = null;
                    });
                    await refreshBoardsForCurrentFilters({ force: true });
                    populateBoardList();
                    updateMemoryEstimatePanels();
                    persistFilterStateToUrl();
                });
            }

            const familySel = document.getElementById('family-select');
            if (familySel) {
                familySel.addEventListener('change', async () => {
                    selectedFamily = String(familySel.value || '');
                    selectedSilicon = '';
                    selectedBoard = null;
                    const boardDetails = document.getElementById('board-details');
                    if (boardDetails) boardDetails.style.display = 'none';
                    await refreshTaxonomyOptionsFromApi().catch(err => {
                        console.warn('Failed to refresh taxonomy options:', err);
                        taxonomyOptions = null;
                    });
                    await refreshBoardsForCurrentFilters({ force: true });
                    populateBoardList();
                    updateMemoryEstimatePanels();
                    persistFilterStateToUrl();
                });
            }

            const siliconSel = document.getElementById('silicon-select');
            if (siliconSel) {
                siliconSel.addEventListener('change', async () => {
                    selectedSilicon = String(siliconSel.value || '');
                    selectedBoard = null;
                    const boardDetails = document.getElementById('board-details');
                    if (boardDetails) boardDetails.style.display = 'none';
                    await refreshTaxonomyOptionsFromApi().catch(err => {
                        console.warn('Failed to refresh taxonomy options:', err);
                        taxonomyOptions = null;
                    });
                    await refreshBoardsForCurrentFilters({ force: true });
                    populateBoardList();
                    updateMemoryEstimatePanels();
                    persistFilterStateToUrl();
                });
            }

            const boardSearch = document.getElementById('board-search');
            if (boardSearch) {
                boardSearch.oninput = () => {
                    persistFilterStateToUrl();
                    scheduleBoardSearchRefresh();
                };
                boardSearch.onkeydown = async (event) => {
                    if (event.key === 'ArrowDown') {
                        event.preventDefault();
                        if (boardKeyboardFlatItems.length > 0) {
                            await focusBoardKeyboardIndex(boardKeyboardIndex >= 0 ? boardKeyboardIndex : 0, { select: false });
                        }
                    }
                };
            }

            const boardList = document.getElementById('board-list');
            if (boardList) {
                boardList.addEventListener('keydown', async (event) => {
                    await handleBoardListKeydown(event);
                });
                boardList.addEventListener('focus', async () => {
                    if (boardKeyboardFlatItems.length === 0) return;
                    const idx = boardKeyboardIndex >= 0 ? boardKeyboardIndex : (selectedBoard ? boardFlatIndexById(selectedBoard.id) : 0);
                    await focusBoardKeyboardIndex(idx >= 0 ? idx : 0, { select: false });
                });
            }

            document.getElementById('btn-next').onclick = nextStep;
            document.getElementById('btn-prev').onclick = prevStep;
            document.getElementById('btn-generate').onclick = generateFiles;
            const btnGenerateBuild = document.getElementById('btn-generate-build');
            if (btnGenerateBuild) btnGenerateBuild.onclick = generateAndBuildEsp32;
            const btnCopyIdfBuild = document.getElementById('btn-copy-idf-build');
            if (btnCopyIdfBuild) {
                btnCopyIdfBuild.onclick = async () => {
                    const text = [
                        'SDKCONFIG_DEFAULTS=config/generated/sdkconfig.defaults idf.py -B build set-target <target>',
                        'SDKCONFIG_DEFAULTS=config/generated/sdkconfig.defaults idf.py -B build build'
                    ].join('\n');
                    try {
                        await navigator.clipboard.writeText(text);
                        notify('ESP-IDF build commands copied.', 'success');
                    } catch (_) {
                        notify('Could not access clipboard. Copy from README quick start.', 'warning');
                    }
                };
            }
            const btnOpenFirstSuccess = document.getElementById('btn-open-first-success');
            if (btnOpenFirstSuccess) {
                btnOpenFirstSuccess.onclick = () => {
                    window.open('/docs/ESP32_FIRST_SUCCESS_10_MIN.md', '_blank', 'noopener');
                };
            }
            const expandBtn = document.getElementById('btn-expand-modules');
            if (expandBtn) expandBtn.onclick = () => setAllModuleSections(true);
            const collapseBtn = document.getElementById('btn-collapse-modules');
            if (collapseBtn) collapseBtn.onclick = () => setAllModuleSections(false);
            renderStatusChips();
            renderBuildHealthBar();
            updateFinalActionState();
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
