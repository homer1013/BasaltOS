#!/usr/bin/env python3
"""
AVR Arduino-style codegen backend for BasaltOS configurator.
Generates a minimal sketch scaffold and config header.
"""
from __future__ import annotations

from pathlib import Path
from typing import Dict, List, Optional


def _mkdir(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)


def _emit_basalt_config_h(
    out_path: Path,
    board_id: str,
    target_id: str,
    enabled_modules: List[str],
    pins: Dict[str, str],
    module_config: Optional[dict] = None,
    clock: Optional[dict] = None,
) -> None:
    lines: List[str] = []
    lines.append("#pragma once")
    lines.append("")
    lines.append("// Generated by BasaltOS configurator (AVR target)")
    lines.append(f"#define BASALT_TARGET_{target_id.upper()} 1")
    lines.append(f"#define BASALT_BOARD_ID \"{board_id}\"")

    if clock:
        lines.append(f"#define BASALT_CLOCK_HZ {int(clock.get('freq_hz', 16000000))}")

    lines.append("")
    lines.append("// Enabled modules")
    for mid in sorted(enabled_modules):
        macro = f"BASALT_ENABLE_{mid.upper()}"
        lines.append(f"#define {macro} 1")

    lines.append("")
    lines.append("// Pin mappings")
    for key, val in pins.items():
        macro = f"BASALT_PIN_{key.upper()}"
        lines.append(f"#define {macro} {val}")

    if module_config:
        lines.append("")
        lines.append("// Module configuration")
        for module_id, options in module_config.items():
            if not isinstance(options, dict):
                continue
            for key, val in options.items():
                macro = f"BASALT_CFG_{str(module_id).upper()}_{str(key).upper()}"
                if isinstance(val, bool):
                    lines.append(f"#define {macro} {1 if val else 0}")
                elif isinstance(val, (int, float)) and int(val) == val:
                    lines.append(f"#define {macro} {int(val)}")
                else:
                    lines.append(f"#define {macro} \"{val}\"")

    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def _emit_main_ino(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "basalt_config.h"

void app_init(void);
void app_loop(void);

void setup() {
    app_init();
}

void loop() {
    app_loop();
}
""",
        encoding="utf-8",
    )


def _emit_app_cpp(out_path: Path, applets: Optional[List[str]] = None) -> None:
    applets = applets or []
    decls: List[str] = []
    init_calls: List[str] = []
    loop_calls: List[str] = []
    for applet in applets:
        safe = applet.strip().replace("-", "_")
        decls.append(f"void applet_{safe}_init(void) __attribute__((weak));")
        decls.append(f"void applet_{safe}_loop(void) __attribute__((weak));")
        decls.append(f"void applet_{safe}_init(void) {{}}")
        decls.append(f"void applet_{safe}_loop(void) {{}}")
        init_calls.append(f"    applet_{safe}_init();")
        loop_calls.append(f"    applet_{safe}_loop();")

    out_path.write_text(
        "\n".join(
            [
                "#include <Arduino.h>",
                '#include "basalt_config.h"',
                "",
                *decls,
                "",
                "void app_init(void) {",
                "    // TODO: application init",
                *init_calls,
                "}",
                "",
                "void app_loop(void) {",
                "    // TODO: application loop",
                *loop_calls,
                "}",
                "",
            ]
        ),
        encoding="utf-8",
    )


def _emit_gpio_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

void basalt_gpio_mode(uint8_t pin, uint8_t mode) {
    pinMode(pin, mode);
}

void basalt_gpio_write(uint8_t pin, uint8_t value) {
    digitalWrite(pin, value ? HIGH : LOW);
}

int basalt_gpio_read(uint8_t pin) {
    return digitalRead(pin);
}
""",
        encoding="utf-8",
    )


def _emit_uart_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

static HardwareSerial &basalt_uart_port() {
#if defined(BASALT_CFG_UART_UART_NUM)
#if BASALT_CFG_UART_UART_NUM == 1
    return Serial1;
#elif BASALT_CFG_UART_UART_NUM == 2
    return Serial2;
#elif BASALT_CFG_UART_UART_NUM == 3
    return Serial3;
#else
    return Serial;
#endif
#else
    return Serial;
#endif
}

void basalt_uart_init() {
    const unsigned long baud =
#if defined(BASALT_CFG_UART_UART_BAUDRATE)
        (unsigned long)BASALT_CFG_UART_UART_BAUDRATE;
#else
        115200UL;
#endif
    basalt_uart_port().begin(baud);
}

int basalt_uart_available() {
    return basalt_uart_port().available();
}

int basalt_uart_read() {
    return basalt_uart_port().read();
}

size_t basalt_uart_write(uint8_t b) {
    return basalt_uart_port().write(b);
}
""",
        encoding="utf-8",
    )


def _emit_i2c_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include <Wire.h>
#include "../basalt_config.h"

void basalt_i2c_init() {
    Wire.begin();
}

void basalt_i2c_begin_tx(uint8_t addr) {
    Wire.beginTransmission(addr);
}

size_t basalt_i2c_write(uint8_t val) {
    return Wire.write(val);
}

uint8_t basalt_i2c_end_tx(bool stop) {
    return Wire.endTransmission(stop);
}

int basalt_i2c_request(uint8_t addr, size_t len) {
    return Wire.requestFrom((int)addr, (int)len);
}

int basalt_i2c_read() {
    return Wire.read();
}
""",
        encoding="utf-8",
    )


def _emit_spi_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include <SPI.h>
#include "../basalt_config.h"

void basalt_spi_init() {
    SPI.begin();
}

uint8_t basalt_spi_transfer(uint8_t val) {
    return SPI.transfer(val);
}

void basalt_spi_begin_transaction(uint32_t speed_hz) {
    SPI.beginTransaction(SPISettings(speed_hz, MSBFIRST, SPI_MODE0));
}

void basalt_spi_end_transaction() {
    SPI.endTransaction();
}
""",
        encoding="utf-8",
    )


def _emit_adc_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

int basalt_adc_read(uint8_t pin) {
    return analogRead(pin);
}
""",
        encoding="utf-8",
    )


def _emit_pwm_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

void basalt_pwm_write(uint8_t pin, uint8_t value) {
    analogWrite(pin, value);
}
""",
        encoding="utf-8",
    )


def _emit_timer_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

void basalt_delay_ms(uint32_t ms) {
    delay(ms);
}

uint32_t basalt_millis() {
    return millis();
}
""",
        encoding="utf-8",
    )


def _emit_eeprom_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include <EEPROM.h>
#include "../basalt_config.h"

uint8_t basalt_eeprom_read(int addr) {
    return EEPROM.read(addr);
}

void basalt_eeprom_write(int addr, uint8_t val) {
    EEPROM.update(addr, val);
}
""",
        encoding="utf-8",
    )


def _emit_remote_node_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

// Minimal placeholder for a UART-based remote node protocol.
// Implement your framing/protocol on top of basalt_uart_* helpers.
void basalt_remote_node_init() {}
void basalt_remote_node_poll() {}
""",
        encoding="utf-8",
    )


def _emit_applet_blink(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

#ifndef BASALT_PIN_LED
#define BASALT_PIN_LED LED_BUILTIN
#endif

static uint32_t s_last_toggle = 0;
static uint8_t s_led_state = LOW;

void applet_blink_init(void) {
    pinMode(BASALT_PIN_LED, OUTPUT);
}

void applet_blink_loop(void) {
    const uint32_t now = millis();
    if (now - s_last_toggle >= 500) {
        s_last_toggle = now;
        s_led_state = s_led_state ? LOW : HIGH;
        digitalWrite(BASALT_PIN_LED, s_led_state);
    }
}
""",
        encoding="utf-8",
    )


def _emit_applet_uart_echo(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

int basalt_uart_available();
int basalt_uart_read();
size_t basalt_uart_write(uint8_t b);
void basalt_uart_init();

void applet_uart_echo_init(void) {
    basalt_uart_init();
}

void applet_uart_echo_loop(void) {
    while (basalt_uart_available() > 0) {
        int ch = basalt_uart_read();
        if (ch >= 0) {
            basalt_uart_write((uint8_t)ch);
        }
    }
}
""",
        encoding="utf-8",
    )


def _emit_applet_remote_node(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

void basalt_remote_node_init();
void basalt_remote_node_poll();

void applet_remote_node_init(void) {
    basalt_remote_node_init();
}

void applet_remote_node_loop(void) {
    basalt_remote_node_poll();
}
""",
        encoding="utf-8",
    )


def generate_avr_project(
    out_dir: Path,
    board_id: str,
    target_id: str,
    enabled_modules: List[str],
    pins: Dict[str, str],
    module_config: Optional[dict] = None,
    clock: Optional[dict] = None,
    applets: Optional[List[str]] = None,
) -> Dict[str, str]:
    include_dir = out_dir / "include"
    src_dir = out_dir / "src"
    drivers_dir = src_dir / "drivers"
    apps_dir = src_dir / "apps"

    _mkdir(include_dir)
    _mkdir(src_dir)
    _mkdir(drivers_dir)
    _mkdir(apps_dir)

    basalt_h = out_dir / "basalt_config.h"
    _emit_basalt_config_h(
        basalt_h,
        board_id=board_id,
        target_id=target_id,
        enabled_modules=enabled_modules,
        pins=pins,
        module_config=module_config,
        clock=clock,
    )
    _emit_basalt_config_h(
        include_dir / "basalt_config.h",
        board_id=board_id,
        target_id=target_id,
        enabled_modules=enabled_modules,
        pins=pins,
        module_config=module_config,
        clock=clock,
    )
    _emit_basalt_config_h(
        src_dir / "basalt_config.h",
        board_id=board_id,
        target_id=target_id,
        enabled_modules=enabled_modules,
        pins=pins,
        module_config=module_config,
        clock=clock,
    )

    sketch_name = out_dir.name
    # Remove any stale sketches so Arduino CLI only sees one
    for ino in out_dir.glob("*.ino"):
        if ino.name != f"{sketch_name}.ino":
            ino.unlink()
    _emit_main_ino(out_dir / f"{sketch_name}.ino")
    _emit_app_cpp(out_dir / "app.cpp", applets=applets)

    module_to_driver = {
        "gpio": _emit_gpio_driver,
        "uart": _emit_uart_driver,
        "i2c": _emit_i2c_driver,
        "spi": _emit_spi_driver,
        "adc": _emit_adc_driver,
        "pwm": _emit_pwm_driver,
        "timer": _emit_timer_driver,
        "eeprom": _emit_eeprom_driver,
        "remote_node": _emit_remote_node_driver,
    }

    for mid, emitter in module_to_driver.items():
        if mid in enabled_modules:
            emitter(drivers_dir / f"{mid}.cpp")

    for applet in applets or []:
        safe = applet.strip().replace("-", "_")
        if safe == "blink":
            _emit_applet_blink(apps_dir / "applet_blink.cpp")
        elif safe == "uart_echo":
            _emit_applet_uart_echo(apps_dir / "applet_uart_echo.cpp")
        elif safe == "remote_node":
            _emit_applet_remote_node(apps_dir / "applet_remote_node.cpp")
        else:
            (apps_dir / f"applet_{safe}.cpp").write_text(
                f"// Applet: {safe}\n// TODO: implement\n",
                encoding="utf-8",
            )

    platformio = out_dir / "platformio.ini"
    platformio.write_text(
        """[env:mega2560]
platform = atmelavr
board = megaatmega2560
framework = arduino
build_flags =
    -Iinclude
""",
        encoding="utf-8",
    )

    arduino_meta = out_dir / "arduino.json"
    arduino_meta.write_text(
        """{
  "board": "arduino:avr:mega",
  "cpu": "atmega2560",
  "clock_hz": 16000000
}
""",
        encoding="utf-8",
    )

    readme = out_dir / "README.md"
    readme.write_text(
        """# BasaltOS AVR Project

Generated by the BasaltOS configurator.

## Build (Arduino CLI)
arduino-cli compile --fqbn arduino:avr:mega .

## Upload (Arduino CLI)
arduino-cli upload -p /dev/ttyACM0 --fqbn arduino:avr:mega .

## Build (Arduino IDE)
Open BasaltOS.ino with Arduino IDE.

## Build (PlatformIO)
Use platformio.ini with `pio run`.
""",
        encoding="utf-8",
    )

    return {
        "basalt_config.h": str(basalt_h),
        f"{sketch_name}.ino": str(out_dir / f"{sketch_name}.ino"),
        "app.cpp": str(out_dir / "app.cpp"),
        "platformio.ini": str(platformio),
        "arduino.json": str(arduino_meta),
        "drivers_dir": str(drivers_dir),
        "apps_dir": str(apps_dir),
        "README.md": str(readme),
    } 


def render_basalt_config_preview(
    board_id: str,
    target_id: str,
    enabled_modules: List[str],
    pins: Dict[str, str],
    module_config: Optional[dict] = None,
    clock: Optional[dict] = None,
) -> str:
    tmp = Path("/tmp") / "basalt_avr_preview.h"
    _emit_basalt_config_h(
        tmp,
        board_id=board_id,
        target_id=target_id,
        enabled_modules=enabled_modules,
        pins=pins,
        module_config=module_config,
        clock=clock,
    )
    return tmp.read_text(encoding="utf-8")
