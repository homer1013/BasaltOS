#!/usr/bin/env python3
"""
AVR Arduino-style codegen backend for BasaltOS configurator.
Generates a minimal sketch scaffold and config header.
"""
from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List, Optional


def _mkdir(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)


def _emit_basalt_config_h(
    out_path: Path,
    board_id: str,
    target_id: str,
    enabled_modules: List[str],
    pins: Dict[str, str],
    module_config: Optional[dict] = None,
    clock: Optional[dict] = None,
    fuses: Optional[dict] = None,
    applets: Optional[List[str]] = None,
) -> None:
    lines: List[str] = []
    lines.append("#pragma once")
    lines.append("")
    lines.append("// Generated by BasaltOS configurator (AVR target)")
    lines.append(f"#define BASALT_TARGET_{target_id.upper()} 1")
    lines.append(f"#define BASALT_BOARD_ID \"{board_id}\"")

    if clock:
        lines.append(f"#define BASALT_CLOCK_HZ {int(clock.get('freq_hz', 16000000))}")
    if fuses:
        for key in ("lfuse", "hfuse", "efuse", "lock"):
            if key in fuses and str(fuses.get(key)).strip():
                lines.append(f"#define BASALT_FUSE_{key.upper()} \"{str(fuses.get(key)).strip()}\"")
    applets = applets or []
    lines.append(f"#define BASALT_APPLET_COUNT {len(applets)}")
    lines.append(f"#define BASALT_APPLETS_CSV \"{','.join(applets)}\"")

    lines.append("")
    lines.append("// Enabled modules")
    for mid in sorted(enabled_modules):
        macro = f"BASALT_ENABLE_{mid.upper()}"
        lines.append(f"#define {macro} 1")

    lines.append("")
    lines.append("// Pin mappings")
    for key, val in pins.items():
        macro = f"BASALT_PIN_{key.upper()}"
        lines.append(f"#define {macro} {val}")

    if module_config:
        lines.append("")
        lines.append("// Module configuration")
        for module_id, options in module_config.items():
            if not isinstance(options, dict):
                continue
            for key, val in options.items():
                macro = f"BASALT_CFG_{str(module_id).upper()}_{str(key).upper()}"
                if isinstance(val, bool):
                    lines.append(f"#define {macro} {1 if val else 0}")
                elif isinstance(val, (int, float)) and int(val) == val:
                    lines.append(f"#define {macro} {int(val)}")
                else:
                    lines.append(f"#define {macro} \"{val}\"")

    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def _emit_main_ino(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "basalt_config.h"

void app_init(void);
void app_loop(void);

void setup() {
    app_init();
}

void loop() {
    app_loop();
}
""",
        encoding="utf-8",
    )


def _emit_app_cpp(out_path: Path, applets: Optional[List[str]] = None) -> None:
    applets = applets or []
    decls: List[str] = []
    init_ptrs: List[str] = []
    loop_ptrs: List[str] = []
    names: List[str] = []
    for applet in applets:
        safe = applet.strip().replace("-", "_")
        decls.append(f"void applet_{safe}_init(void) __attribute__((weak));")
        decls.append(f"void applet_{safe}_loop(void) __attribute__((weak));")
        decls.append(f"void applet_{safe}_init(void) {{}}")
        decls.append(f"void applet_{safe}_loop(void) {{}}")
        init_ptrs.append(f"    applet_{safe}_init,")
        loop_ptrs.append(f"    applet_{safe}_loop,")
        names.append(f"    \"{safe}\",")

    out_path.write_text(
        "\n".join(
            [
                "#include <Arduino.h>",
                "#include <string.h>",
                '#include "basalt_config.h"',
                "",
                "typedef void (*applet_fn_t)(void);",
                "",
                *decls,
                "",
                f"static const size_t k_applet_count = {len(applets)};",
                "static const char *k_applet_names[] = {",
                *names,
                "};",
                "static applet_fn_t k_applet_init[] = {",
                *init_ptrs,
                "};",
                "static applet_fn_t k_applet_loop[] = {",
                *loop_ptrs,
                "};",
                "static bool k_applet_inited[64] = {false};",
                "static int g_active_applet = -1;",
                "",
                "size_t basalt_app_count(void) {",
                "    return k_applet_count;",
                "}",
                "",
                "const char *basalt_app_name(size_t idx) {",
                "    if (idx >= k_applet_count) return nullptr;",
                "    return k_applet_names[idx];",
                "}",
                "",
                "const char *basalt_app_active_name(void) {",
                "    if (g_active_applet < 0 || (size_t)g_active_applet >= k_applet_count) return nullptr;",
                "    return k_applet_names[g_active_applet];",
                "}",
                "",
                "bool basalt_app_run(const char *name) {",
                "    if (!name || !*name) return false;",
                "    for (size_t i = 0; i < k_applet_count; ++i) {",
                "        if (strcmp(k_applet_names[i], name) == 0) {",
                "            g_active_applet = (int)i;",
                "            return true;",
                "        }",
                "    }",
                "    return false;",
                "}",
                "",
                "void basalt_app_stop(void) {",
                "    g_active_applet = -1;",
                "}",
                "",
                "#if defined(BASALT_ENABLE_SHELL_MIN) || defined(BASALT_ENABLE_SHELL_FULL)",
                "void basalt_shell_init(void);",
                "void basalt_shell_poll(void);",
                "#endif",
                "",
                "void app_init(void) {",
                "    // TODO: application init",
                "#if defined(BASALT_ENABLE_SHELL_MIN) || defined(BASALT_ENABLE_SHELL_FULL)",
                "    basalt_shell_init();",
                "#endif",
                "}",
                "",
                "void app_loop(void) {",
                "#if defined(BASALT_ENABLE_SHELL_MIN) || defined(BASALT_ENABLE_SHELL_FULL)",
                "    basalt_shell_poll();",
                "#endif",
                "    if (g_active_applet < 0 || (size_t)g_active_applet >= k_applet_count) return;",
                "    if (!k_applet_inited[g_active_applet]) {",
                "        k_applet_inited[g_active_applet] = true;",
                "        k_applet_init[g_active_applet]();",
                "    }",
                "    k_applet_loop[g_active_applet]();",
                "}",
                "",
            ]
        ),
        encoding="utf-8",
    )


def _emit_gpio_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

void basalt_gpio_mode(uint8_t pin, uint8_t mode) {
    pinMode(pin, mode);
}

void basalt_gpio_write(uint8_t pin, uint8_t value) {
    digitalWrite(pin, value ? HIGH : LOW);
}

int basalt_gpio_read(uint8_t pin) {
    return digitalRead(pin);
}
""",
        encoding="utf-8",
    )


def _emit_uart_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

static HardwareSerial &basalt_uart_port() {
#if defined(BASALT_CFG_UART_UART_NUM)
#if BASALT_CFG_UART_UART_NUM == 1
    return Serial1;
#elif BASALT_CFG_UART_UART_NUM == 2
    return Serial2;
#elif BASALT_CFG_UART_UART_NUM == 3
    return Serial3;
#else
    return Serial;
#endif
#else
    return Serial;
#endif
}

void basalt_uart_init() {
    const unsigned long baud =
#if defined(BASALT_CFG_UART_UART_BAUDRATE)
        (unsigned long)BASALT_CFG_UART_UART_BAUDRATE;
#else
        115200UL;
#endif
    basalt_uart_port().begin(baud);
}

int basalt_uart_available() {
    return basalt_uart_port().available();
}

int basalt_uart_read() {
    return basalt_uart_port().read();
}

size_t basalt_uart_write(uint8_t b) {
    return basalt_uart_port().write(b);
}
""",
        encoding="utf-8",
    )


def _emit_i2c_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include <Wire.h>
#include "../basalt_config.h"

void basalt_i2c_init() {
    Wire.begin();
}

void basalt_i2c_begin_tx(uint8_t addr) {
    Wire.beginTransmission(addr);
}

size_t basalt_i2c_write(uint8_t val) {
    return Wire.write(val);
}

uint8_t basalt_i2c_end_tx(bool stop) {
    return Wire.endTransmission(stop);
}

int basalt_i2c_request(uint8_t addr, size_t len) {
    return Wire.requestFrom((int)addr, (int)len);
}

int basalt_i2c_read() {
    return Wire.read();
}
""",
        encoding="utf-8",
    )


def _emit_spi_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include <SPI.h>
#include "../basalt_config.h"

void basalt_spi_init() {
    SPI.begin();
}

uint8_t basalt_spi_transfer(uint8_t val) {
    return SPI.transfer(val);
}

void basalt_spi_begin_transaction(uint32_t speed_hz) {
    SPI.beginTransaction(SPISettings(speed_hz, MSBFIRST, SPI_MODE0));
}

void basalt_spi_end_transaction() {
    SPI.endTransaction();
}
""",
        encoding="utf-8",
    )


def _emit_adc_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

int basalt_adc_read(uint8_t pin) {
    return analogRead(pin);
}
""",
        encoding="utf-8",
    )


def _emit_pwm_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

void basalt_pwm_write(uint8_t pin, uint8_t value) {
    analogWrite(pin, value);
}
""",
        encoding="utf-8",
    )


def _emit_timer_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

void basalt_delay_ms(uint32_t ms) {
    delay(ms);
}

uint32_t basalt_millis() {
    return millis();
}
""",
        encoding="utf-8",
    )


def _emit_eeprom_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include <EEPROM.h>
#include "../basalt_config.h"

uint8_t basalt_eeprom_read(int addr) {
    return EEPROM.read(addr);
}

void basalt_eeprom_write(int addr, uint8_t val) {
    EEPROM.update(addr, val);
}
""",
        encoding="utf-8",
    )


def _emit_remote_node_driver(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

// Minimal placeholder for a UART-based remote node protocol.
// Implement your framing/protocol on top of basalt_uart_* helpers.
void basalt_remote_node_init() {}
void basalt_remote_node_poll() {}
""",
        encoding="utf-8",
    )


def _emit_applet_blink(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

#ifndef BASALT_PIN_LED
#define BASALT_PIN_LED LED_BUILTIN
#endif

static uint32_t s_last_toggle = 0;
static uint8_t s_led_state = LOW;

void applet_blink_init(void) {
    pinMode(BASALT_PIN_LED, OUTPUT);
}

void applet_blink_loop(void) {
    const uint32_t now = millis();
    if (now - s_last_toggle >= 500) {
        s_last_toggle = now;
        s_led_state = s_led_state ? LOW : HIGH;
        digitalWrite(BASALT_PIN_LED, s_led_state);
    }
}
""",
        encoding="utf-8",
    )


def _emit_applet_uart_echo(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

int basalt_uart_available();
int basalt_uart_read();
size_t basalt_uart_write(uint8_t b);
void basalt_uart_init();

void applet_uart_echo_init(void) {
    basalt_uart_init();
}

void applet_uart_echo_loop(void) {
    while (basalt_uart_available() > 0) {
        int ch = basalt_uart_read();
        if (ch >= 0) {
            basalt_uart_write((uint8_t)ch);
        }
    }
}
""",
        encoding="utf-8",
    )


def _emit_applet_remote_node(out_path: Path) -> None:
    out_path.write_text(
        """#include <Arduino.h>
#include "../basalt_config.h"

void basalt_remote_node_init();
void basalt_remote_node_poll();

void applet_remote_node_init(void) {
    basalt_remote_node_init();
}

void applet_remote_node_loop(void) {
    basalt_remote_node_poll();
}
""",
        encoding="utf-8",
    )


def _emit_shell_runtime(out_path: Path, full_shell: bool) -> None:
    unsupported_cmds = [
        "cat", "cd", "mkdir", "cp", "mv", "rm", "edit", "install", "remove", "logs", "wifi", "bluetooth", "imu"
    ] if full_shell else [
        "cat", "cd", "mkdir", "cp", "mv", "rm", "edit", "install", "remove", "logs", "wifi", "bluetooth", "imu"
    ]
    unsupported_list = ", ".join([f"\"{c}\"" for c in unsupported_cmds])
    out_path.write_text(
        f"""#include <Arduino.h>
#include <string.h>
#include <stdlib.h>
#include "basalt_config.h"

size_t basalt_app_count(void);
const char *basalt_app_name(size_t idx);
const char *basalt_app_active_name(void);
bool basalt_app_run(const char *name);
void basalt_app_stop(void);

static HardwareSerial &shell_port() {{
#if defined(BASALT_CFG_UART_UART_NUM)
#if BASALT_CFG_UART_UART_NUM == 1
    return Serial1;
#elif BASALT_CFG_UART_UART_NUM == 2
    return Serial2;
#elif BASALT_CFG_UART_UART_NUM == 3
    return Serial3;
#else
    return Serial;
#endif
#else
    return Serial;
#endif
}}

static unsigned long shell_baud() {{
#if defined(BASALT_CFG_UART_UART_BAUDRATE)
    return (unsigned long)BASALT_CFG_UART_UART_BAUDRATE;
#else
    return 115200UL;
#endif
}}

static char g_line[128];
static size_t g_line_len = 0;

static void sh_print_prompt() {{
    shell_port().print("basalt> ");
}}

static bool sh_equals(const char *a, const char *b) {{
    return a && b && strcmp(a, b) == 0;
}}

static void sh_help(const char *arg) {{
    if (!arg || !*arg) {{
        shell_port().println("Basalt shell. Type 'help -commands' for list.");
        return;
    }}
    if (sh_equals(arg, "-commands")) {{
        shell_port().println("help, pwd, ls, apps, run <app>, stop, led_test [pin], drivers, reboot");
        shell_port().println("cat, cd, mkdir, cp, mv, rm, edit, install, remove, logs, wifi, bluetooth, imu (stubs)");
        return;
    }}
    if (sh_equals(arg, "run")) {{
        shell_port().println("run <app>: run one selected applet by name");
        return;
    }}
    if (sh_equals(arg, "apps")) {{
        shell_port().println("apps: list compiled applets");
        return;
    }}
    shell_port().print("help: no detailed entry for ");
    shell_port().println(arg);
}}

static void sh_led_test(const char *arg) {{
    long pin = -1;
    if (arg && *arg) pin = strtol(arg, nullptr, 10);
#ifdef BASALT_PIN_LED
    if (pin < 0) pin = BASALT_PIN_LED;
#endif
    if (pin < 0) {{
        shell_port().println("led_test: no LED pin configured");
        return;
    }}
    pinMode((uint8_t)pin, OUTPUT);
    shell_port().print("led_test pin=");
    shell_port().println((int)pin);
    for (int i = 0; i < 8; ++i) {{
        digitalWrite((uint8_t)pin, (i & 1) ? HIGH : LOW);
        delay(110);
    }}
    digitalWrite((uint8_t)pin, LOW);
}}

static void sh_drivers() {{
    shell_port().println("drivers:");
#ifdef BASALT_ENABLE_GPIO
    shell_port().println("  gpio: enabled");
#else
    shell_port().println("  gpio: disabled");
#endif
#ifdef BASALT_ENABLE_UART
    shell_port().println("  uart: enabled");
#else
    shell_port().println("  uart: disabled");
#endif
#ifdef BASALT_ENABLE_I2C
    shell_port().println("  i2c: enabled");
#else
    shell_port().println("  i2c: disabled");
#endif
#ifdef BASALT_ENABLE_SPI
    shell_port().println("  spi: enabled");
#else
    shell_port().println("  spi: disabled");
#endif
#ifdef BASALT_ENABLE_SHELL_FULL
    shell_port().println("  shell: full");
#elif defined(BASALT_ENABLE_SHELL_MIN)
    shell_port().println("  shell: minimal");
#else
    shell_port().println("  shell: off");
#endif
}}

static void sh_apps() {{
    const size_t n = basalt_app_count();
    if (n == 0) {{
        shell_port().println("apps: none");
        return;
    }}
    for (size_t i = 0; i < n; ++i) {{
        shell_port().print("- ");
        shell_port().println(basalt_app_name(i));
    }}
}}

static void sh_handle_line(char *line) {{
    while (*line == ' ' || *line == '\\t') line++;
    if (!*line) return;

    char *cmd = strtok(line, " \\t");
    char *arg = strtok(nullptr, "");
    while (arg && (*arg == ' ' || *arg == '\\t')) arg++;

    if (sh_equals(cmd, "help")) {{
        sh_help(arg);
        return;
    }}
    if (sh_equals(cmd, "pwd")) {{
        shell_port().println("/");
        return;
    }}
    if (sh_equals(cmd, "ls")) {{
        shell_port().println("apps");
        return;
    }}
    if (sh_equals(cmd, "apps")) {{
        sh_apps();
        return;
    }}
    if (sh_equals(cmd, "run")) {{
        if (!arg || !*arg) {{
            shell_port().println("run: missing app name");
            return;
        }}
        if (basalt_app_run(arg)) {{
            shell_port().print("run: ");
            shell_port().println(arg);
        }} else {{
            shell_port().print("run: unknown app: ");
            shell_port().println(arg);
        }}
        return;
    }}
    if (sh_equals(cmd, "stop")) {{
        basalt_app_stop();
        shell_port().println("stop: ok");
        return;
    }}
    if (sh_equals(cmd, "led_test")) {{
        sh_led_test(arg);
        return;
    }}
    if (sh_equals(cmd, "drivers")) {{
        sh_drivers();
        return;
    }}
    if (sh_equals(cmd, "reboot")) {{
        shell_port().println("rebooting...");
        delay(50);
        void (*reset_fn)(void) = 0;
        reset_fn();
        return;
    }}

    static const char *k_unsupported[] = {{{unsupported_list}}};
    for (size_t i = 0; i < sizeof(k_unsupported) / sizeof(k_unsupported[0]); ++i) {{
        if (sh_equals(cmd, k_unsupported[i])) {{
            shell_port().print(cmd);
            shell_port().println(": not supported on AVR runtime yet");
            return;
        }}
    }}

    shell_port().print("unknown command: ");
    shell_port().println(cmd);
}}

void basalt_shell_init(void) {{
    shell_port().begin(shell_baud());
    delay(20);
    shell_port().println("Basalt shell (AVR) ready. Type 'help'.");
    sh_print_prompt();
}}

void basalt_shell_poll(void) {{
    while (shell_port().available() > 0) {{
        const int ch = shell_port().read();
        if (ch < 0) break;
        if (ch == '\\r' || ch == '\\n') {{
            shell_port().println();
            g_line[g_line_len] = 0;
            sh_handle_line(g_line);
            g_line_len = 0;
            sh_print_prompt();
            continue;
        }}
        if (ch == 8 || ch == 127) {{
            if (g_line_len > 0) g_line_len--;
            continue;
        }}
        if (g_line_len + 1 < sizeof(g_line)) {{
            g_line[g_line_len++] = (char)ch;
        }}
    }}
}}
""",
        encoding="utf-8",
    )


def generate_avr_project(
    out_dir: Path,
    board_id: str,
    target_id: str,
    enabled_modules: List[str],
    pins: Dict[str, str],
    module_config: Optional[dict] = None,
    clock: Optional[dict] = None,
    fuses: Optional[dict] = None,
    applets: Optional[List[str]] = None,
    upload_profile: Optional[dict] = None,
) -> Dict[str, str]:
    include_dir = out_dir / "include"
    src_dir = out_dir / "src"
    drivers_dir = src_dir / "drivers"
    apps_dir = src_dir / "apps"

    _mkdir(include_dir)
    _mkdir(src_dir)
    _mkdir(drivers_dir)
    _mkdir(apps_dir)

    basalt_h = out_dir / "basalt_config.h"
    _emit_basalt_config_h(
        basalt_h,
        board_id=board_id,
        target_id=target_id,
        enabled_modules=enabled_modules,
        pins=pins,
        module_config=module_config,
        clock=clock,
        fuses=fuses,
        applets=applets,
    )
    _emit_basalt_config_h(
        include_dir / "basalt_config.h",
        board_id=board_id,
        target_id=target_id,
        enabled_modules=enabled_modules,
        pins=pins,
        module_config=module_config,
        clock=clock,
        fuses=fuses,
        applets=applets,
    )
    _emit_basalt_config_h(
        src_dir / "basalt_config.h",
        board_id=board_id,
        target_id=target_id,
        enabled_modules=enabled_modules,
        pins=pins,
        module_config=module_config,
        clock=clock,
        fuses=fuses,
        applets=applets,
    )

    sketch_name = out_dir.name
    # Remove any stale sketches so Arduino CLI only sees one
    for ino in out_dir.glob("*.ino"):
        if ino.name != f"{sketch_name}.ino":
            ino.unlink()
    _emit_main_ino(out_dir / f"{sketch_name}.ino")
    _emit_app_cpp(out_dir / "app.cpp", applets=applets)

    module_to_driver = {
        "gpio": _emit_gpio_driver,
        "uart": _emit_uart_driver,
        "i2c": _emit_i2c_driver,
        "spi": _emit_spi_driver,
        "adc": _emit_adc_driver,
        "pwm": _emit_pwm_driver,
        "timer": _emit_timer_driver,
        "eeprom": _emit_eeprom_driver,
        "remote_node": _emit_remote_node_driver,
    }

    for mid, emitter in module_to_driver.items():
        if mid in enabled_modules:
            emitter(drivers_dir / f"{mid}.cpp")

    if "shell_min" in enabled_modules or "shell_full" in enabled_modules:
        _emit_shell_runtime(src_dir / "shell.cpp", full_shell=("shell_full" in enabled_modules))

    for applet in applets or []:
        safe = applet.strip().replace("-", "_")
        if safe == "blink":
            _emit_applet_blink(apps_dir / "applet_blink.cpp")
        elif safe == "uart_echo":
            _emit_applet_uart_echo(apps_dir / "applet_uart_echo.cpp")
        elif safe == "remote_node":
            _emit_applet_remote_node(apps_dir / "applet_remote_node.cpp")
        else:
            (apps_dir / f"applet_{safe}.cpp").write_text(
                f"// Applet: {safe}\n// TODO: implement\n",
                encoding="utf-8",
            )

    platformio = out_dir / "platformio.ini"
    platformio.write_text(
        """[env:mega2560]
platform = atmelavr
board = megaatmega2560
framework = arduino
build_flags =
    -Iinclude
""",
        encoding="utf-8",
    )

    up = upload_profile or {}
    arduino_meta = out_dir / "arduino.json"
    arduino_meta.write_text(
        (
            "{\n"
            f"  \"board\": \"{up.get('fqbn', 'arduino:avr:mega')}\",\n"
            f"  \"cpu\": \"{up.get('mcu', 'atmega2560')}\",\n"
            f"  \"clock_hz\": {int((clock or {}).get('freq_hz', 16000000))},\n"
            f"  \"upload_method\": \"{up.get('method', 'bootloader')}\",\n"
            f"  \"programmer\": \"{up.get('programmer', 'wiring')}\",\n"
            f"  \"baud\": {int(up.get('baud', 115200))},\n"
            f"  \"fuses\": {json.dumps(fuses or {}, indent=2)}\n"
            "}\n"
        ),
        encoding="utf-8",
    )

    readme = out_dir / "README.md"
    readme.write_text(
        """# BasaltOS AVR Project

Generated by the BasaltOS configurator.

## Build (Arduino CLI)
arduino-cli compile --fqbn arduino:avr:mega .

## Upload (Arduino CLI)
arduino-cli upload -p /dev/ttyACM0 --fqbn arduino:avr:mega .

## Build (Arduino IDE)
Open BasaltOS.ino with Arduino IDE.

## Build (PlatformIO)
Use platformio.ini with `pio run`.
""",
        encoding="utf-8",
    )

    result = {
        "basalt_config.h": str(basalt_h),
        f"{sketch_name}.ino": str(out_dir / f"{sketch_name}.ino"),
        "app.cpp": str(out_dir / "app.cpp"),
        "platformio.ini": str(platformio),
        "arduino.json": str(arduino_meta),
        "drivers_dir": str(drivers_dir),
        "apps_dir": str(apps_dir),
        "README.md": str(readme),
    }
    if "shell_min" in enabled_modules or "shell_full" in enabled_modules:
        result["shell.cpp"] = str(src_dir / "shell.cpp")
    return result


def render_basalt_config_preview(
    board_id: str,
    target_id: str,
    enabled_modules: List[str],
    pins: Dict[str, str],
    module_config: Optional[dict] = None,
    clock: Optional[dict] = None,
    fuses: Optional[dict] = None,
) -> str:
    tmp = Path("/tmp") / "basalt_avr_preview.h"
    _emit_basalt_config_h(
        tmp,
        board_id=board_id,
        target_id=target_id,
        enabled_modules=enabled_modules,
        pins=pins,
        module_config=module_config,
        clock=clock,
        fuses=fuses,
    )
    return tmp.read_text(encoding="utf-8")
