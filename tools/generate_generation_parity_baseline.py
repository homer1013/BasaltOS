#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import subprocess
from pathlib import Path
from typing import Dict, List, Tuple


REPRESENTATIVE_BOARDS: Dict[str, str] = {
    "atmega": "arduino_uno_r3",
    "atsam": "adafruit_circuit_playground_express",
    "avr": "mega2560",
    "esp32": "esp32-c3-supermini",
    "linux-sbc": "raspberry_pi_4b",
    "pic16": "curiosity_nano_pic16f13145",
    "renesas_ra": "arduino_uno_r4_wifi",
    "renesas_rx": "rx65n_envision_kit",
    "rp2040": "raspberry_pi_pico",
    "stm32": "nucleo_f401re",
}

REQUIRED_ARTIFACTS = [
    "basalt_config.h",
    "basalt.features.json",
    "sdkconfig.defaults",
    "basalt_config.json",
]


def run_case(root: Path, platform: str, board: str, out_root: Path) -> Dict[str, object]:
    outdir = out_root / platform / board
    outdir.mkdir(parents=True, exist_ok=True)
    log_path = outdir / "run.log"
    cmd = [
        "python3",
        "tools/configure.py",
        "--platform",
        platform,
        "--board",
        board,
        "--outdir",
        str(outdir),
    ]
    p = subprocess.run(cmd, cwd=root, capture_output=True, text=True)
    log_path.write_text((p.stdout or "") + ("\n" if p.stdout else "") + (p.stderr or ""), encoding="utf-8")
    artifacts = {name: (outdir / name).exists() for name in REQUIRED_ARTIFACTS}
    missing = [k for k, ok in artifacts.items() if not ok]
    board_json = root / "boards" / platform / board / "board.json"
    board_defaults: List[str] = []
    if board_json.exists():
        try:
            board_data = json.loads(board_json.read_text(encoding="utf-8"))
            board_defaults = sorted(
                str(x).strip()
                for x in (((board_data.get("defaults") or {}).get("modules") or []))
                if str(x).strip()
            )
        except Exception:
            board_defaults = []
    enabled_modules: List[str] = []
    features_json = outdir / "basalt.features.json"
    if features_json.exists():
        try:
            features_data = json.loads(features_json.read_text(encoding="utf-8"))
            enabled_modules = sorted(str(x).strip() for x in (features_data.get("modules") or []) if str(x).strip())
        except Exception:
            enabled_modules = []
    missing_defaults = sorted(set(board_defaults) - set(enabled_modules))
    parity = {
        "enabled_module_count": len(enabled_modules),
        "default_module_count": len(board_defaults),
        "missing_default_module_count": len(missing_defaults),
        "missing_default_modules": missing_defaults,
    }
    return {
        "platform": platform,
        "board_dir": board,
        "command": " ".join(cmd),
        "exit_code": int(p.returncode),
        "artifacts": artifacts,
        "missing_artifacts": missing,
        "status": "PASS" if p.returncode == 0 and not missing else "FAIL",
        "log_path": str(log_path.relative_to(root)),
        "module_parity": parity,
    }


def write_json(path: Path, payload: Dict[str, object]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(payload, indent=2) + "\n", encoding="utf-8")


def build_gap_summary(rows: List[Dict[str, object]]) -> Dict[str, object]:
    max_enabled = max((int((r.get("module_parity") or {}).get("enabled_module_count", 0)) for r in rows), default=0)
    max_defaults = max((int((r.get("module_parity") or {}).get("default_module_count", 0)) for r in rows), default=0)
    with_missing = [r for r in rows if int((r.get("module_parity") or {}).get("missing_default_module_count", 0)) > 0]
    by_platform: Dict[str, Dict[str, int]] = {}
    for r in rows:
        parity = r.get("module_parity") or {}
        by_platform[str(r.get("platform"))] = {
            "enabled_module_count": int(parity.get("enabled_module_count", 0)),
            "default_module_count": int(parity.get("default_module_count", 0)),
            "missing_default_module_count": int(parity.get("missing_default_module_count", 0)),
            "enabled_gap_to_max": max_enabled - int(parity.get("enabled_module_count", 0)),
            "default_gap_to_max": max_defaults - int(parity.get("default_module_count", 0)),
        }
    return {
        "max_enabled_module_count": max_enabled,
        "max_default_module_count": max_defaults,
        "platforms_with_missing_defaults": len(with_missing),
        "platforms_without_missing_defaults": len(rows) - len(with_missing),
        "by_platform": by_platform,
    }


def write_md(path: Path, rows: List[Dict[str, object]], out_root: Path, gap_summary: Dict[str, object]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    pass_count = sum(1 for r in rows if r["status"] == "PASS")
    fail_count = len(rows) - pass_count
    lines: List[str] = []
    lines.append("# Cross-Platform Generation Parity Baseline")
    lines.append("")
    lines.append("Auto-generated by `tools/generate_generation_parity_baseline.py`.")
    lines.append("")
    lines.append(f"- Platforms covered: {len(rows)}")
    lines.append(f"- PASS: {pass_count}")
    lines.append(f"- FAIL: {fail_count}")
    lines.append(f"- Artifact root: `{out_root}`")
    lines.append(f"- Max enabled modules on any representative board: {gap_summary['max_enabled_module_count']}")
    lines.append(f"- Max default modules on any representative board: {gap_summary['max_default_module_count']}")
    lines.append(f"- Platforms with missing default modules in baseline run: {gap_summary['platforms_with_missing_defaults']}")
    lines.append("")
    lines.append("| Platform | Representative Board | Status | Missing Artifacts | Log |")
    lines.append("|---|---|---|---|---|")
    for r in rows:
        miss = ", ".join(r["missing_artifacts"]) if r["missing_artifacts"] else "-"
        lines.append(
            f"| {r['platform']} | {r['board_dir']} | {r['status']} | {miss} | `{r['log_path']}` |"
        )
    lines.append("")
    lines.append("## Driver/Module Parity Counts")
    lines.append("")
    lines.append("| Platform | Enabled Modules | Board Default Modules | Missing Default Modules |")
    lines.append("|---|---|---|---|")
    for r in rows:
        parity = r.get("module_parity") or {}
        lines.append(
            f"| {r['platform']} | {parity.get('enabled_module_count', 0)} | {parity.get('default_module_count', 0)} | {parity.get('missing_default_module_count', 0)} |"
        )
    lines.append("")
    lines.append("## Gap Summary")
    lines.append("")
    for r in rows:
        parity = r.get("module_parity") or {}
        missing = parity.get("missing_default_modules") or []
        if missing:
            lines.append(f"- {r['platform']}: missing default modules -> {', '.join(missing)}")
        else:
            lines.append(f"- {r['platform']}: no default module gap")
    lines.append("")
    path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


def main() -> int:
    ap = argparse.ArgumentParser(description="Generate cross-platform configure parity baseline artifacts.")
    ap.add_argument("--out-json", default="docs/planning/GENERATION_PARITY_BASELINE.json", help="JSON output path")
    ap.add_argument("--out-md", default="docs/planning/GENERATION_PARITY_BASELINE.md", help="Markdown output path")
    ap.add_argument(
        "--artifact-root",
        default="tmp/generation_parity_baseline",
        help="Output root for per-platform configure artifacts/logs",
    )
    args = ap.parse_args()

    root = Path(__file__).resolve().parent.parent
    out_json = (root / args.out_json).resolve()
    out_md = (root / args.out_md).resolve()
    artifact_root = (root / args.artifact_root).resolve()

    rows: List[Dict[str, object]] = []
    for platform in sorted(REPRESENTATIVE_BOARDS.keys()):
        rows.append(run_case(root, platform, REPRESENTATIVE_BOARDS[platform], artifact_root))
    gap_summary = build_gap_summary(rows)

    payload = {
        "version": "1.1.0",
        "representative_boards": REPRESENTATIVE_BOARDS,
        "required_artifacts": REQUIRED_ARTIFACTS,
        "rows": rows,
        "module_parity_gap_summary": gap_summary,
        "summary": {
            "platform_count": len(rows),
            "pass_count": sum(1 for r in rows if r["status"] == "PASS"),
            "fail_count": sum(1 for r in rows if r["status"] != "PASS"),
        },
    }
    write_json(out_json, payload)
    write_md(out_md, rows, artifact_root.relative_to(root), gap_summary)

    print(f"[parity] wrote: {out_json}")
    print(f"[parity] wrote: {out_md}")
    print(f"[parity] artifact root: {artifact_root}")
    if payload["summary"]["fail_count"] > 0:
        print(f"[parity] failures: {payload['summary']['fail_count']}")
        return 1
    print("[parity] all representative platforms passed")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
