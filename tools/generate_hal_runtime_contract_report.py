#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import re
from pathlib import Path
from typing import Any, Dict, List, Set, Tuple


PRIMITIVES: List[str] = ["gpio", "i2c", "uart"]


def _read_json(path: Path) -> Dict[str, Any]:
    return json.loads(path.read_text(encoding="utf-8"))


def _required_ports(root: Path) -> List[str]:
    payload = _read_json(root / "docs/planning/HAL_PLATFORM_ADAPTER_COMPLETENESS.json")
    ports = [str(r.get("port") or "") for r in (payload.get("rows") or [])]
    return sorted([p for p in ports if p])


def _scan_file_for_contract_symbols(path: Path, primitive: str) -> Tuple[int, Set[str]]:
    text = path.read_text(encoding="utf-8", errors="ignore")
    defs = re.findall(rf"\bint\s+(hal_{primitive}_[a-z0-9_]+)\s*\([^;{{}}]*\)\s*\{{", text)
    return len(defs), set(defs)


def _build_report(root: Path) -> Dict[str, Any]:
    policy = _read_json(root / "docs/planning/HAL_RUNTIME_CONTRACT_POLICY.json")
    required = _required_ports(root)
    ports_root = root / "basalt_hal" / "ports"

    ack_missing_impl = set(policy.get("acknowledged_missing_runtime_impl_ports") or [])

    rows: List[Dict[str, Any]] = []
    blocking_gaps = 0

    for port in required:
        primitive_rows: List[Dict[str, Any]] = []
        missing_impl_primitives: List[str] = []
        for primitive in PRIMITIVES:
            p = ports_root / port / f"hal_{primitive}.c"
            if not p.exists():
                primitive_rows.append(
                    {
                        "primitive": primitive,
                        "file": str(p.relative_to(root)),
                        "file_exists": False,
                        "function_definitions": 0,
                        "symbols_found": [],
                        "state": "missing_file",
                    }
                )
                missing_impl_primitives.append(primitive)
                continue

            defs_count, symbols = _scan_file_for_contract_symbols(p, primitive)
            state = "runtime_impl_present" if defs_count > 0 else "declaration_only_or_empty"
            if defs_count == 0:
                missing_impl_primitives.append(primitive)

            primitive_rows.append(
                {
                    "primitive": primitive,
                    "file": str(p.relative_to(root)),
                    "file_exists": True,
                    "function_definitions": defs_count,
                    "symbols_found": sorted(symbols),
                    "state": state,
                }
            )

        if not missing_impl_primitives:
            contract_state = "pass"
            reason = "Runtime implementations found for all tracked primitives."
        else:
            if port in ack_missing_impl:
                contract_state = "pass_acknowledged_missing_runtime_impl"
                reason = "Missing runtime implementations are explicitly acknowledged in policy."
            else:
                contract_state = "fail_unacknowledged_missing_runtime_impl"
                reason = "Runtime implementation gap is not acknowledged in policy."
                blocking_gaps += 1

        rows.append(
            {
                "port": port,
                "contract_state": contract_state,
                "reason": reason,
                "missing_runtime_impl_primitives": missing_impl_primitives,
                "primitives": primitive_rows,
            }
        )

    state_counts: Dict[str, int] = {}
    for row in rows:
        state = row["contract_state"]
        state_counts[state] = state_counts.get(state, 0) + 1

    return {
        "version": "1.0.0",
        "generator": "tools/generate_hal_runtime_contract_report.py",
        "sources": {
            "policy": "docs/planning/HAL_RUNTIME_CONTRACT_POLICY.json",
            "required_ports": "docs/planning/HAL_PLATFORM_ADAPTER_COMPLETENESS.json",
            "ports_glob": "basalt_hal/ports/<port>/hal_<primitive>.c",
        },
        "tracked_primitives": PRIMITIVES,
        "summary": {
            "required_port_count": len(required),
            "blocking_gaps": blocking_gaps,
            "contract_state_counts": state_counts,
        },
        "rows": rows,
    }


def _write_md(payload: Dict[str, Any], out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    summary = payload.get("summary") or {}
    rows = payload.get("rows") or []

    lines: List[str] = []
    lines.append("# HAL Runtime Contract Report v1")
    lines.append("")
    lines.append("Auto-generated by `tools/generate_hal_runtime_contract_report.py`.")
    lines.append("")
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- Required ports: {summary.get('required_port_count', 0)}")
    lines.append(f"- Blocking gaps: {summary.get('blocking_gaps', 0)}")
    lines.append("")
    lines.append("| Port | Contract State | Missing Runtime Primitives |")
    lines.append("|---|---|---|")
    for row in rows:
        missing = ", ".join(row.get("missing_runtime_impl_primitives") or []) or "-"
        lines.append(f"| {row.get('port')} | {row.get('contract_state')} | {missing} |")
    lines.append("")
    out_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


def main() -> int:
    ap = argparse.ArgumentParser(description="Generate HAL runtime init/status contract report artifacts.")
    ap.add_argument("--json-out", default="docs/planning/HAL_RUNTIME_CONTRACT_REPORT.json")
    ap.add_argument("--md-out", default="docs/planning/HAL_RUNTIME_CONTRACT_REPORT.md")
    args = ap.parse_args()

    root = Path(__file__).resolve().parent.parent
    payload = _build_report(root)

    json_out = (root / args.json_out).resolve()
    md_out = (root / args.md_out).resolve()
    json_out.parent.mkdir(parents=True, exist_ok=True)

    json_out.write_text(json.dumps(payload, indent=2) + "\n", encoding="utf-8")
    _write_md(payload, md_out)

    summary = payload["summary"]
    print(f"[hal-runtime] required ports: {summary['required_port_count']}")
    print(f"[hal-runtime] blocking gaps: {summary['blocking_gaps']}")
    print(f"[hal-runtime] wrote: {json_out}")
    print(f"[hal-runtime] wrote: {md_out}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
